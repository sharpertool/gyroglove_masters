
GyroAcc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a3d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000062a  00802000  0000a3d6  0000a46a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000005e3  0080262a  0080262a  0000aa94  2**0
                  ALLOC
  3 .stab         000019e0  00000000  00000000  0000aa94  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000704  00000000  00000000  0000c474  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000550  00000000  00000000  0000cb78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00002250  00000000  00000000  0000d0c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00015e7e  00000000  00000000  0000f318  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00004c29  00000000  00000000  00025196  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00008cd6  00000000  00000000  00029dbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001c60  00000000  00000000  00032a98  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000483b  00000000  00000000  000346f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00007378  00000000  00000000  00038f33  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000338  00000000  00000000  000402ab  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 00 01 	jmp	0x200	; 0x200 <__ctors_end>
       4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
       8:	0c 94 17 2d 	jmp	0x5a2e	; 0x5a2e <__vector_2>
       c:	0c 94 bd 2e 	jmp	0x5d7a	; 0x5d7a <__vector_3>
      10:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      14:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      18:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      1c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      20:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      24:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      28:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      2c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      30:	0c 94 cb 20 	jmp	0x4196	; 0x4196 <__vector_12>
      34:	0c 94 48 24 	jmp	0x4890	; 0x4890 <__vector_13>
      38:	0c 94 f8 35 	jmp	0x6bf0	; 0x6bf0 <__vector_14>
      3c:	0c 94 8f 34 	jmp	0x691e	; 0x691e <__vector_15>
      40:	0c 94 1f 3a 	jmp	0x743e	; 0x743e <__vector_16>
      44:	0c 94 e5 39 	jmp	0x73ca	; 0x73ca <__vector_17>
      48:	0c 94 ab 39 	jmp	0x7356	; 0x7356 <__vector_18>
      4c:	0c 94 71 39 	jmp	0x72e2	; 0x72e2 <__vector_19>
      50:	0c 94 4d 35 	jmp	0x6a9a	; 0x6a9a <__vector_20>
      54:	0c 94 e4 33 	jmp	0x67c8	; 0x67c8 <__vector_21>
      58:	0c 94 67 37 	jmp	0x6ece	; 0x6ece <__vector_22>
      5c:	0c 94 2d 37 	jmp	0x6e5a	; 0x6e5a <__vector_23>
      60:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      64:	0c 94 41 1e 	jmp	0x3c82	; 0x3c82 <__vector_25>
      68:	0c 94 4f 1b 	jmp	0x369e	; 0x369e <__vector_26>
      6c:	0c 94 5e 1b 	jmp	0x36bc	; 0x36bc <__vector_27>
      70:	0c 94 08 1e 	jmp	0x3c10	; 0x3c10 <__vector_28>
      74:	0c 94 6d 1b 	jmp	0x36da	; 0x36da <__vector_29>
      78:	0c 94 7c 1b 	jmp	0x36f8	; 0x36f8 <__vector_30>
      7c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      80:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      84:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      88:	0c 94 50 2d 	jmp	0x5aa0	; 0x5aa0 <__vector_34>
      8c:	0c 94 f6 2e 	jmp	0x5dec	; 0x5dec <__vector_35>
      90:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      94:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      98:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      9c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      a0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      a4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      a8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      ac:	0c 94 a5 2c 	jmp	0x594a	; 0x594a <__vector_43>
      b0:	0c 94 4b 2e 	jmp	0x5c96	; 0x5c96 <__vector_44>
      b4:	0c 94 da 20 	jmp	0x41b4	; 0x41b4 <__vector_45>
      b8:	0c 94 0f 24 	jmp	0x481e	; 0x481e <__vector_46>
      bc:	0c 94 86 35 	jmp	0x6b0c	; 0x6b0c <__vector_47>
      c0:	0c 94 1d 34 	jmp	0x683a	; 0x683a <__vector_48>
      c4:	0c 94 4f 38 	jmp	0x709e	; 0x709e <__vector_49>
      c8:	0c 94 15 38 	jmp	0x702a	; 0x702a <__vector_50>
      cc:	0c 94 db 37 	jmp	0x6fb6	; 0x6fb6 <__vector_51>
      d0:	0c 94 a1 37 	jmp	0x6f42	; 0x6f42 <__vector_52>
      d4:	0c 94 db 34 	jmp	0x69b6	; 0x69b6 <__vector_53>
      d8:	0c 94 72 33 	jmp	0x66e4	; 0x66e4 <__vector_54>
      dc:	0c 94 7f 36 	jmp	0x6cfe	; 0x6cfe <__vector_55>
      e0:	0c 94 45 36 	jmp	0x6c8a	; 0x6c8a <__vector_56>
      e4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
      e8:	0c 94 5d 1d 	jmp	0x3aba	; 0x3aba <__vector_58>
      ec:	0c 94 c7 1b 	jmp	0x378e	; 0x378e <__vector_59>
      f0:	0c 94 d6 1b 	jmp	0x37ac	; 0x37ac <__vector_60>
      f4:	0c 94 24 1d 	jmp	0x3a48	; 0x3a48 <__vector_61>
      f8:	0c 94 e5 1b 	jmp	0x37ca	; 0x37ca <__vector_62>
      fc:	0c 94 f4 1b 	jmp	0x37e8	; 0x37e8 <__vector_63>
     100:	0c 94 de 2c 	jmp	0x59bc	; 0x59bc <__vector_64>
     104:	0c 94 84 2e 	jmp	0x5d08	; 0x5d08 <__vector_65>
     108:	0c 94 89 2d 	jmp	0x5b12	; 0x5b12 <__vector_66>
     10c:	0c 94 2f 2f 	jmp	0x5e5e	; 0x5e5e <__vector_67>
     110:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     114:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     118:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     11c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     120:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     124:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     128:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     12c:	0c 94 e9 20 	jmp	0x41d2	; 0x41d2 <__vector_75>
     130:	0c 94 d6 23 	jmp	0x47ac	; 0x47ac <__vector_76>
     134:	0c 94 bf 35 	jmp	0x6b7e	; 0x6b7e <__vector_77>
     138:	0c 94 56 34 	jmp	0x68ac	; 0x68ac <__vector_78>
     13c:	0c 94 37 39 	jmp	0x726e	; 0x726e <__vector_79>
     140:	0c 94 fd 38 	jmp	0x71fa	; 0x71fa <__vector_80>
     144:	0c 94 c3 38 	jmp	0x7186	; 0x7186 <__vector_81>
     148:	0c 94 89 38 	jmp	0x7112	; 0x7112 <__vector_82>
     14c:	0c 94 14 35 	jmp	0x6a28	; 0x6a28 <__vector_83>
     150:	0c 94 ab 33 	jmp	0x6756	; 0x6756 <__vector_84>
     154:	0c 94 f3 36 	jmp	0x6de6	; 0x6de6 <__vector_85>
     158:	0c 94 b9 36 	jmp	0x6d72	; 0x6d72 <__vector_86>
     15c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     160:	0c 94 cf 1d 	jmp	0x3b9e	; 0x3b9e <__vector_88>
     164:	0c 94 8b 1b 	jmp	0x3716	; 0x3716 <__vector_89>
     168:	0c 94 9a 1b 	jmp	0x3734	; 0x3734 <__vector_90>
     16c:	0c 94 96 1d 	jmp	0x3b2c	; 0x3b2c <__vector_91>
     170:	0c 94 a9 1b 	jmp	0x3752	; 0x3752 <__vector_92>
     174:	0c 94 b8 1b 	jmp	0x3770	; 0x3770 <__vector_93>
     178:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     17c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     180:	0c 94 33 2c 	jmp	0x5866	; 0x5866 <__vector_96>
     184:	0c 94 d9 2d 	jmp	0x5bb2	; 0x5bb2 <__vector_97>
     188:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     18c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     190:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     194:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     198:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     19c:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1a0:	0c 94 6c 2c 	jmp	0x58d8	; 0x58d8 <__vector_104>
     1a4:	0c 94 12 2e 	jmp	0x5c24	; 0x5c24 <__vector_105>
     1a8:	0c 94 f8 20 	jmp	0x41f0	; 0x41f0 <__vector_106>
     1ac:	0c 94 9d 23 	jmp	0x473a	; 0x473a <__vector_107>
     1b0:	0c 94 75 3a 	jmp	0x74ea	; 0x74ea <__vector_108>
     1b4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1b8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1bc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1c0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1c4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1c8:	0c 94 b1 3a 	jmp	0x7562	; 0x7562 <__vector_114>
     1cc:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1d0:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1d4:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1d8:	0c 94 26 01 	jmp	0x24c	; 0x24c <__bad_interrupt>
     1dc:	0c 94 eb 1c 	jmp	0x39d6	; 0x39d6 <__vector_119>
     1e0:	0c 94 03 1c 	jmp	0x3806	; 0x3806 <__vector_120>
     1e4:	0c 94 12 1c 	jmp	0x3824	; 0x3824 <__vector_121>
     1e8:	0c 94 b2 1c 	jmp	0x3964	; 0x3964 <__vector_122>
     1ec:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__vector_123>
     1f0:	0c 94 30 1c 	jmp	0x3860	; 0x3860 <__vector_124>

000001f4 <__c.1988>:
     1f4:	63 64 69 6e 6f 70 73 75 78 58 5b 00                 cdinopsuxX[.

00000200 <__ctors_end>:
     200:	11 24       	eor	r1, r1
     202:	1f be       	out	0x3f, r1	; 63
     204:	cf ef       	ldi	r28, 0xFF	; 255
     206:	df e3       	ldi	r29, 0x3F	; 63
     208:	de bf       	out	0x3e, r29	; 62
     20a:	cd bf       	out	0x3d, r28	; 61
     20c:	00 e0       	ldi	r16, 0x00	; 0
     20e:	0c bf       	out	0x3c, r16	; 60
     210:	18 be       	out	0x38, r1	; 56
     212:	19 be       	out	0x39, r1	; 57
     214:	1a be       	out	0x3a, r1	; 58
     216:	1b be       	out	0x3b, r1	; 59

00000218 <__do_copy_data>:
     218:	16 e2       	ldi	r17, 0x26	; 38
     21a:	a0 e0       	ldi	r26, 0x00	; 0
     21c:	b0 e2       	ldi	r27, 0x20	; 32
     21e:	e6 ed       	ldi	r30, 0xD6	; 214
     220:	f3 ea       	ldi	r31, 0xA3	; 163
     222:	00 e0       	ldi	r16, 0x00	; 0
     224:	0b bf       	out	0x3b, r16	; 59
     226:	02 c0       	rjmp	.+4      	; 0x22c <__do_copy_data+0x14>
     228:	07 90       	elpm	r0, Z+
     22a:	0d 92       	st	X+, r0
     22c:	aa 32       	cpi	r26, 0x2A	; 42
     22e:	b1 07       	cpc	r27, r17
     230:	d9 f7       	brne	.-10     	; 0x228 <__do_copy_data+0x10>
     232:	1b be       	out	0x3b, r1	; 59

00000234 <__do_clear_bss>:
     234:	1c e2       	ldi	r17, 0x2C	; 44
     236:	aa e2       	ldi	r26, 0x2A	; 42
     238:	b6 e2       	ldi	r27, 0x26	; 38
     23a:	01 c0       	rjmp	.+2      	; 0x23e <.do_clear_bss_start>

0000023c <.do_clear_bss_loop>:
     23c:	1d 92       	st	X+, r1

0000023e <.do_clear_bss_start>:
     23e:	ad 30       	cpi	r26, 0x0D	; 13
     240:	b1 07       	cpc	r27, r17
     242:	e1 f7       	brne	.-8      	; 0x23c <.do_clear_bss_loop>
     244:	0e 94 9b 01 	call	0x336	; 0x336 <main>
     248:	0c 94 e9 51 	jmp	0xa3d2	; 0xa3d2 <_exit>

0000024c <__bad_interrupt>:
     24c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000250 <_ZN8MyDriver3errEh>:
    //@{
    
    //! Timer Error - ignored.
    virtual void err(uint8_t id)
    {
    }
     250:	08 95       	ret

00000252 <_ZN8MyDriver3ovfEh>:
    
    //! Timer Overflow Interrupt.
    //! Overflow fires when the timer reaches the top period value.
    //! This is setup to fire when we get a timer tick, with a default rate of 500us
    //! IMUManager has only one Timer so the ID is not needed.
    virtual void ovf(uint8_t id)
     252:	fc 01       	movw	r30, r24
        
        _Rate = 2;
    }

    void toggleLed() {
        if (bLedState) {
     254:	83 81       	ldd	r24, Z+3	; 0x03
     256:	a6 81       	ldd	r26, Z+6	; 0x06
     258:	b7 81       	ldd	r27, Z+7	; 0x07
     25a:	88 23       	and	r24, r24
     25c:	29 f0       	breq	.+10     	; 0x268 <_ZN8MyDriver3ovfEh+0x16>
            // Set State On
            bLedState = false;
     25e:	13 82       	std	Z+3, r1	; 0x03
            bPort->OUTCLR = PIN6_bm;
     260:	80 e4       	ldi	r24, 0x40	; 64
     262:	16 96       	adiw	r26, 0x06	; 6
     264:	8c 93       	st	X, r24
     266:	08 95       	ret
        } else {
            bLedState = true;
     268:	81 e0       	ldi	r24, 0x01	; 1
     26a:	83 83       	std	Z+3, r24	; 0x03
            bPort->OUTSET = PIN6_bm;
     26c:	80 e4       	ldi	r24, 0x40	; 64
     26e:	15 96       	adiw	r26, 0x05	; 5
     270:	8c 93       	st	X, r24
     272:	08 95       	ret

00000274 <_ZN8MyDriver3ccxEhh>:
    }
    
    //! Timer Capture Compare - not used.
    virtual void ccx(uint8_t id,uint8_t idx)
    {
    }
     274:	08 95       	ret

00000276 <_ZN8MyDriver14SetTimerPeriodEv>:
        _pTimer->IntLvlA(0,2);
        _pTimer->IntLvlB(0);
        _pTimer->Notify(this,0);
    }
    
    virtual void SetTimerPeriod()
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	8c 01       	movw	r16, r24
    {
        // Adjust the timer function to fire 10X faster
        // than the rate. At 200Hz, this will be 2Khz or 
        // every 500us. 
        unsigned long timerTicks = 31250/_Rate;
        _pTimer->Period(timerTicks);
     27c:	fc 01       	movw	r30, r24
     27e:	20 85       	ldd	r18, Z+8	; 0x08
     280:	31 85       	ldd	r19, Z+9	; 0x09
     282:	42 85       	ldd	r20, Z+10	; 0x0a
     284:	53 85       	ldd	r21, Z+11	; 0x0b
     286:	62 e1       	ldi	r22, 0x12	; 18
     288:	7a e7       	ldi	r23, 0x7A	; 122
     28a:	80 e0       	ldi	r24, 0x00	; 0
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
     292:	f8 01       	movw	r30, r16
     294:	84 85       	ldd	r24, Z+12	; 0x0c
     296:	95 85       	ldd	r25, Z+13	; 0x0d
     298:	b9 01       	movw	r22, r18
     29a:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <_ZN9TimerCntr6PeriodEj>
    }
     29e:	1f 91       	pop	r17
     2a0:	0f 91       	pop	r16
     2a2:	08 95       	ret

000002a4 <_ZN8MyDriver8SetTimerEP9TimerCntr>:
    //! this timer must run at 1 500us rate, etc. The default will
    //! be to run at 500us, then the timer can be slowed down
    //! if a slower rate is used, just to avoid as much overhead.
    //! The CPU Clock runs at 32Mhz, so the main timer clock is running
    //! at 32/8 or 4Mhz. 
    virtual void SetTimer(TimerCntr* pTimer)
     2a4:	0f 93       	push	r16
     2a6:	1f 93       	push	r17
     2a8:	8c 01       	movw	r16, r24
     2aa:	cb 01       	movw	r24, r22
    {
        _pTimer = pTimer;
     2ac:	d8 01       	movw	r26, r16
     2ae:	1c 96       	adiw	r26, 0x0c	; 12
     2b0:	6d 93       	st	X+, r22
     2b2:	7c 93       	st	X, r23
     2b4:	1d 97       	sbiw	r26, 0x0d	; 13
        
        //! This will be 2us period
        _pTimer->ClkSel(TC_CLKSEL_DIV256_gc);
     2b6:	66 e0       	ldi	r22, 0x06	; 6
     2b8:	0e 94 b6 32 	call	0x656c	; 0x656c <_ZN9TimerCntr6ClkSelE14TC_CLKSEL_enum>
        SetTimerPeriod();
     2bc:	d8 01       	movw	r26, r16
     2be:	ed 91       	ld	r30, X+
     2c0:	fc 91       	ld	r31, X
     2c2:	00 84       	ldd	r0, Z+8	; 0x08
     2c4:	f1 85       	ldd	r31, Z+9	; 0x09
     2c6:	e0 2d       	mov	r30, r0
     2c8:	c8 01       	movw	r24, r16
     2ca:	19 95       	eicall
        _pTimer->CCEnable(0);
     2cc:	f8 01       	movw	r30, r16
     2ce:	84 85       	ldd	r24, Z+12	; 0x0c
     2d0:	95 85       	ldd	r25, Z+13	; 0x0d
     2d2:	60 e0       	ldi	r22, 0x00	; 0
     2d4:	0e 94 bc 32 	call	0x6578	; 0x6578 <_ZN9TimerCntr8CCEnableEh>
        _pTimer->WaveformGenMode(TC_WGMODE_NORMAL_gc);
     2d8:	d8 01       	movw	r26, r16
     2da:	1c 96       	adiw	r26, 0x0c	; 12
     2dc:	8d 91       	ld	r24, X+
     2de:	9c 91       	ld	r25, X
     2e0:	1d 97       	sbiw	r26, 0x0d	; 13
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	0e 94 c7 32 	call	0x658e	; 0x658e <_ZN9TimerCntr15WaveformGenModeE14TC_WGMODE_enum>
        _pTimer->EventSetup(TC_EVACT_OFF_gc,TC_EVSEL_OFF_gc);
     2e8:	f8 01       	movw	r30, r16
     2ea:	84 85       	ldd	r24, Z+12	; 0x0c
     2ec:	95 85       	ldd	r25, Z+13	; 0x0d
     2ee:	60 e0       	ldi	r22, 0x00	; 0
     2f0:	40 e0       	ldi	r20, 0x00	; 0
     2f2:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <_ZN9TimerCntr10EventSetupE13TC_EVACT_enum13TC_EVSEL_enum>
        _pTimer->IntLvlA(0,2);
     2f6:	d8 01       	movw	r26, r16
     2f8:	1c 96       	adiw	r26, 0x0c	; 12
     2fa:	8d 91       	ld	r24, X+
     2fc:	9c 91       	ld	r25, X
     2fe:	1d 97       	sbiw	r26, 0x0d	; 13
     300:	60 e0       	ldi	r22, 0x00	; 0
     302:	42 e0       	ldi	r20, 0x02	; 2
     304:	0e 94 d7 32 	call	0x65ae	; 0x65ae <_ZN9TimerCntr7IntLvlAEhh>
        _pTimer->IntLvlB(0);
     308:	f8 01       	movw	r30, r16
     30a:	84 85       	ldd	r24, Z+12	; 0x0c
     30c:	95 85       	ldd	r25, Z+13	; 0x0d
     30e:	60 e0       	ldi	r22, 0x00	; 0
     310:	0e 94 e6 32 	call	0x65cc	; 0x65cc <_ZN9TimerCntr7IntLvlBEh>
        _pTimer->Notify(this,0);
     314:	d8 01       	movw	r26, r16
     316:	1c 96       	adiw	r26, 0x0c	; 12
     318:	8d 91       	ld	r24, X+
     31a:	9c 91       	ld	r25, X
     31c:	1d 97       	sbiw	r26, 0x0d	; 13
     31e:	b8 01       	movw	r22, r16
     320:	40 e0       	ldi	r20, 0x00	; 0
     322:	0e 94 5a 33 	call	0x66b4	; 0x66b4 <_ZN9TimerCntr6NotifyEP11TimerNotifyh>
    }
     326:	1f 91       	pop	r17
     328:	0f 91       	pop	r16
     32a:	08 95       	ret

0000032c <_Z4initv>:
//! Declared in TimerCore.cpp
extern void timer_init();

void init() {

    clksystem_init();
     32c:	0e 94 20 15 	call	0x2a40	; 0x2a40 <_Z14clksystem_initv>
    timer_init();
     330:	0e 94 59 3a 	call	0x74b2	; 0x74b2 <_Z10timer_initv>
}
     334:	08 95       	ret

00000336 <main>:
void processCmd(CmdProcessor& cmdproc);

HardwareSerial* pdbgserial = 0;
DebugPort*      pdbgport = 0;

int main()
     336:	4f 92       	push	r4
     338:	5f 92       	push	r5
     33a:	6f 92       	push	r6
     33c:	7f 92       	push	r7
     33e:	8f 92       	push	r8
     340:	9f 92       	push	r9
     342:	af 92       	push	r10
     344:	bf 92       	push	r11
     346:	cf 92       	push	r12
     348:	df 92       	push	r13
     34a:	ef 92       	push	r14
     34c:	ff 92       	push	r15
     34e:	0f 93       	push	r16
     350:	1f 93       	push	r17
     352:	df 93       	push	r29
     354:	cf 93       	push	r28
     356:	cd b7       	in	r28, 0x3d	; 61
     358:	de b7       	in	r29, 0x3e	; 62
     35a:	c5 51       	subi	r28, 0x15	; 21
     35c:	d5 40       	sbci	r29, 0x05	; 5
     35e:	cd bf       	out	0x3d, r28	; 61
     360:	de bf       	out	0x3e, r29	; 62
{
    char    buffer[100];
    init();
     362:	0e 94 96 01 	call	0x32c	; 0x32c <_Z4initv>

    PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
     366:	80 91 a2 00 	lds	r24, 0x00A2
     36a:	87 60       	ori	r24, 0x07	; 7
     36c:	e0 ea       	ldi	r30, 0xA0	; 160
     36e:	f0 e0       	ldi	r31, 0x00	; 0
     370:	82 83       	std	Z+2, r24	; 0x02
    sei();
     372:	78 94       	sei
    DebugPort dbgPort2(&PORTE);
    dbgPort2.PinMask(0xF0,5);
    dbgPort2.SetState(0);
#endif
    
    HardwareSerial dbgserial(&USARTF1, &PORTF, PIN6_bm, PIN7_bm);
     374:	0b e2       	ldi	r16, 0x2B	; 43
     376:	e0 2e       	mov	r14, r16
     378:	f1 2c       	mov	r15, r1
     37a:	ec 0e       	add	r14, r28
     37c:	fd 1e       	adc	r15, r29
     37e:	c7 01       	movw	r24, r14
     380:	60 eb       	ldi	r22, 0xB0	; 176
     382:	7b e0       	ldi	r23, 0x0B	; 11
     384:	40 ea       	ldi	r20, 0xA0	; 160
     386:	56 e0       	ldi	r21, 0x06	; 6
     388:	20 e4       	ldi	r18, 0x40	; 64
     38a:	00 e8       	ldi	r16, 0x80	; 128
     38c:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN14HardwareSerialC1EP12USART_structP11PORT_structhh>
    dbgserial.begin(115200);
     390:	c7 01       	movw	r24, r14
     392:	40 e0       	ldi	r20, 0x00	; 0
     394:	52 ec       	ldi	r21, 0xC2	; 194
     396:	61 e0       	ldi	r22, 0x01	; 1
     398:	70 e0       	ldi	r23, 0x00	; 0
     39a:	20 e0       	ldi	r18, 0x00	; 0
     39c:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_ZN14HardwareSerial5beginEla>
    pdbgserial = &dbgserial;
     3a0:	e0 92 2a 26 	sts	0x262A, r14
     3a4:	f0 92 2b 26 	sts	0x262B, r15
    pdbgserial->enable(false);
     3a8:	c7 01       	movw	r24, r14
     3aa:	60 e0       	ldi	r22, 0x00	; 0
     3ac:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <_ZN14HardwareSerial6enableEb>

    // Instantiate a commad processor.
    // Specify the USART, PORT, rxPin and txPin and the baud rate.
    HardwareSerial cmdSerial(&USARTD0, &PORTD, PIN2_bm, PIN3_bm);
     3b0:	1c e3       	ldi	r17, 0x3C	; 60
     3b2:	e1 2e       	mov	r14, r17
     3b4:	f1 2c       	mov	r15, r1
     3b6:	ec 0e       	add	r14, r28
     3b8:	fd 1e       	adc	r15, r29
     3ba:	c7 01       	movw	r24, r14
     3bc:	60 ea       	ldi	r22, 0xA0	; 160
     3be:	79 e0       	ldi	r23, 0x09	; 9
     3c0:	40 e6       	ldi	r20, 0x60	; 96
     3c2:	56 e0       	ldi	r21, 0x06	; 6
     3c4:	24 e0       	ldi	r18, 0x04	; 4
     3c6:	08 e0       	ldi	r16, 0x08	; 8
     3c8:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN14HardwareSerialC1EP12USART_structP11PORT_structhh>
    cmdSerial.begin(115200);
     3cc:	c7 01       	movw	r24, r14
     3ce:	40 e0       	ldi	r20, 0x00	; 0
     3d0:	52 ec       	ldi	r21, 0xC2	; 194
     3d2:	61 e0       	ldi	r22, 0x01	; 1
     3d4:	70 e0       	ldi	r23, 0x00	; 0
     3d6:	20 e0       	ldi	r18, 0x00	; 0
     3d8:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_ZN14HardwareSerial5beginEla>
    //cmdSerial.begin(285000);
    //cmdSerial.begin(921600);
    
    CCP = CCP_IOREG_gc;
     3dc:	88 ed       	ldi	r24, 0xD8	; 216
     3de:	84 bf       	out	0x34, r24	; 52
    MCU.MCUCR = MCU_JTAGD_bm;
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	e0 e9       	ldi	r30, 0x90	; 144
     3e4:	f0 e0       	ldi	r31, 0x00	; 0
     3e6:	86 83       	std	Z+6, r24	; 0x06
    DebugPort dbgPort(&PORTB);
     3e8:	8e 01       	movw	r16, r28
     3ea:	03 5f       	subi	r16, 0xF3	; 243
     3ec:	1f 4f       	sbci	r17, 0xFF	; 255
     3ee:	c8 01       	movw	r24, r16
     3f0:	60 e2       	ldi	r22, 0x20	; 32
     3f2:	76 e0       	ldi	r23, 0x06	; 6
     3f4:	0e 94 b3 20 	call	0x4166	; 0x4166 <_ZN9DebugPortC1EP11PORT_struct>
    dbgPort.PinMask(0xF0,4);
     3f8:	c8 01       	movw	r24, r16
     3fa:	60 ef       	ldi	r22, 0xF0	; 240
     3fc:	44 e0       	ldi	r20, 0x04	; 4
     3fe:	0e 94 94 20 	call	0x4128	; 0x4128 <_ZN9DebugPort7PinMaskEhh>
    dbgPort.SetState(0xf);
     402:	c8 01       	movw	r24, r16
     404:	6f e0       	ldi	r22, 0x0F	; 15
     406:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
    dbgPort.SetState(0);
     40a:	c8 01       	movw	r24, r16
     40c:	60 e0       	ldi	r22, 0x00	; 0
     40e:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
    pdbgport = &dbgPort;
     412:	00 93 2c 26 	sts	0x262C, r16
     416:	10 93 2d 26 	sts	0x262D, r17

    I2C_Master  *pMaster[4];
    I2C_Master hand(&TWIC);
     41a:	b6 eb       	ldi	r27, 0xB6	; 182
     41c:	ab 2e       	mov	r10, r27
     41e:	b2 e0       	ldi	r27, 0x02	; 2
     420:	bb 2e       	mov	r11, r27
     422:	ac 0e       	add	r10, r28
     424:	bd 1e       	adc	r11, r29
     426:	c5 01       	movw	r24, r10
     428:	60 e8       	ldi	r22, 0x80	; 128
     42a:	74 e0       	ldi	r23, 0x04	; 4
     42c:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <_ZN10I2C_MasterC1EP10TWI_struct>
    I2C_Master single(&TWID);
     430:	ae e4       	ldi	r26, 0x4E	; 78
     432:	ca 2e       	mov	r12, r26
     434:	a3 e0       	ldi	r26, 0x03	; 3
     436:	da 2e       	mov	r13, r26
     438:	cc 0e       	add	r12, r28
     43a:	dd 1e       	adc	r13, r29
     43c:	c6 01       	movw	r24, r12
     43e:	60 e9       	ldi	r22, 0x90	; 144
     440:	74 e0       	ldi	r23, 0x04	; 4
     442:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <_ZN10I2C_MasterC1EP10TWI_struct>
    I2C_Master pair1(&TWIE);
     446:	f6 ee       	ldi	r31, 0xE6	; 230
     448:	ef 2e       	mov	r14, r31
     44a:	f3 e0       	ldi	r31, 0x03	; 3
     44c:	ff 2e       	mov	r15, r31
     44e:	ec 0e       	add	r14, r28
     450:	fd 1e       	adc	r15, r29
     452:	c7 01       	movw	r24, r14
     454:	60 ea       	ldi	r22, 0xA0	; 160
     456:	74 e0       	ldi	r23, 0x04	; 4
     458:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <_ZN10I2C_MasterC1EP10TWI_struct>
    I2C_Master pair2(&TWIF);
     45c:	8e 01       	movw	r16, r28
     45e:	02 58       	subi	r16, 0x82	; 130
     460:	1b 4f       	sbci	r17, 0xFB	; 251
     462:	c8 01       	movw	r24, r16
     464:	60 eb       	ldi	r22, 0xB0	; 176
     466:	74 e0       	ldi	r23, 0x04	; 4
     468:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <_ZN10I2C_MasterC1EP10TWI_struct>

    pMaster[0] = &hand;
     46c:	ad 8a       	std	Y+21, r10	; 0x15
     46e:	be 8a       	std	Y+22, r11	; 0x16
    pMaster[1] = &single; // Pinkie
     470:	cf 8a       	std	Y+23, r12	; 0x17
     472:	d8 8e       	std	Y+24, r13	; 0x18
    pMaster[2] = &pair1;  // Ring + Middle
     474:	e9 8e       	std	Y+25, r14	; 0x19
     476:	fa 8e       	std	Y+26, r15	; 0x1a
    pMaster[3] = &pair2;  // Index + Thumb
     478:	0b 8f       	std	Y+27, r16	; 0x1b
     47a:	1c 8f       	std	Y+28, r17	; 0x1c
     47c:	8e 01       	movw	r16, r28
     47e:	0b 5e       	subi	r16, 0xEB	; 235
     480:	1f 4f       	sbci	r17, 0xFF	; 255
    
    for (int x=0;x<4;x++) {
     482:	ed e1       	ldi	r30, 0x1D	; 29
     484:	ee 2e       	mov	r14, r30
     486:	f1 2c       	mov	r15, r1
     488:	ec 0e       	add	r14, r28
     48a:	fd 1e       	adc	r15, r29
        if (pMaster[x]) {
     48c:	d8 01       	movw	r26, r16
     48e:	8d 91       	ld	r24, X+
     490:	9c 91       	ld	r25, X
     492:	00 97       	sbiw	r24, 0x00	; 0
     494:	31 f0       	breq	.+12     	; 0x4a2 <main+0x16c>
            pMaster[x]->begin(400e3);
     496:	40 e8       	ldi	r20, 0x80	; 128
     498:	5a e1       	ldi	r21, 0x1A	; 26
     49a:	66 e0       	ldi	r22, 0x06	; 6
     49c:	70 e0       	ldi	r23, 0x00	; 0
     49e:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <_ZN10I2C_Master5beginEm>
     4a2:	0e 5f       	subi	r16, 0xFE	; 254
     4a4:	1f 4f       	sbci	r17, 0xFF	; 255
    pMaster[0] = &hand;
    pMaster[1] = &single; // Pinkie
    pMaster[2] = &pair1;  // Ring + Middle
    pMaster[3] = &pair2;  // Index + Thumb
    
    for (int x=0;x<4;x++) {
     4a6:	0e 15       	cp	r16, r14
     4a8:	1f 05       	cpc	r17, r15
     4aa:	81 f7       	brne	.-32     	; 0x48c <main+0x156>
     4ac:	80 e1       	ldi	r24, 0x10	; 16
     4ae:	97 e2       	ldi	r25, 0x27	; 39
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
     4b0:	20 e2       	ldi	r18, 0x20	; 32
     4b2:	33 e0       	ldi	r19, 0x03	; 3
     4b4:	f9 01       	movw	r30, r18
     4b6:	31 97       	sbiw	r30, 0x01	; 1
     4b8:	f1 f7       	brne	.-4      	; 0x4b6 <main+0x180>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     4ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     4bc:	d9 f7       	brne	.-10     	; 0x4b4 <main+0x17e>
    _delay_ms(1000);
    
    // When constructed without a list of ID's, the IMU will query known
    // ID's 0xD0 and 0xD2 for the Gyro, and then 0x30 and 0x32 respectively
    // for the ACC.
    IMU     hand_imu(&hand);    
     4be:	78 e7       	ldi	r23, 0x78	; 120
     4c0:	67 2e       	mov	r6, r23
     4c2:	71 2c       	mov	r7, r1
     4c4:	6c 0e       	add	r6, r28
     4c6:	7d 1e       	adc	r7, r29
     4c8:	c3 01       	movw	r24, r6
     4ca:	be 01       	movw	r22, r28
     4cc:	6a 54       	subi	r22, 0x4A	; 74
     4ce:	7d 4f       	sbci	r23, 0xFD	; 253
     4d0:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <_ZN3IMUC1EP10I2C_Master>
    IMU     single_imu(&single);
     4d4:	6a ec       	ldi	r22, 0xCA	; 202
     4d6:	86 2e       	mov	r8, r22
     4d8:	91 2c       	mov	r9, r1
     4da:	8c 0e       	add	r8, r28
     4dc:	9d 1e       	adc	r9, r29
     4de:	c4 01       	movw	r24, r8
     4e0:	be 01       	movw	r22, r28
     4e2:	62 5b       	subi	r22, 0xB2	; 178
     4e4:	7c 4f       	sbci	r23, 0xFC	; 252
     4e6:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <_ZN3IMUC1EP10I2C_Master>
    IMU     pair1_imu(&pair1);  
     4ea:	5c e1       	ldi	r21, 0x1C	; 28
     4ec:	a5 2e       	mov	r10, r21
     4ee:	51 e0       	ldi	r21, 0x01	; 1
     4f0:	b5 2e       	mov	r11, r21
     4f2:	ac 0e       	add	r10, r28
     4f4:	bd 1e       	adc	r11, r29
     4f6:	c5 01       	movw	r24, r10
     4f8:	be 01       	movw	r22, r28
     4fa:	6a 51       	subi	r22, 0x1A	; 26
     4fc:	7c 4f       	sbci	r23, 0xFC	; 252
     4fe:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <_ZN3IMUC1EP10I2C_Master>
    IMU     pair2_imu(&pair2);  
     502:	4e e6       	ldi	r20, 0x6E	; 110
     504:	c4 2e       	mov	r12, r20
     506:	41 e0       	ldi	r20, 0x01	; 1
     508:	d4 2e       	mov	r13, r20
     50a:	cc 0e       	add	r12, r28
     50c:	dd 1e       	adc	r13, r29
     50e:	c6 01       	movw	r24, r12
     510:	be 01       	movw	r22, r28
     512:	62 58       	subi	r22, 0x82	; 130
     514:	7b 4f       	sbci	r23, 0xFB	; 251
     516:	0e 94 ab 0d 	call	0x1b56	; 0x1b56 <_ZN3IMUC1EP10I2C_Master>

    // These all share the debug port, so they must operate
    // in sequence. If I went back to a parallel operation, then
    // this would have to change.
    hand_imu.SetDebugPort(&dbgPort);
     51a:	8e 01       	movw	r16, r28
     51c:	03 5f       	subi	r16, 0xF3	; 243
     51e:	1f 4f       	sbci	r17, 0xFF	; 255
     520:	c3 01       	movw	r24, r6
     522:	b8 01       	movw	r22, r16
     524:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN3IMU12SetDebugPortEP9DebugPort>

    single_imu.SetDebugPort(&dbgPort);
     528:	c4 01       	movw	r24, r8
     52a:	b8 01       	movw	r22, r16
     52c:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN3IMU12SetDebugPortEP9DebugPort>

    pair1_imu.SetDebugPort(&dbgPort);
     530:	c5 01       	movw	r24, r10
     532:	b8 01       	movw	r22, r16
     534:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN3IMU12SetDebugPortEP9DebugPort>

    pair2_imu.SetDebugPort(&dbgPort);
     538:	c6 01       	movw	r24, r12
     53a:	b8 01       	movw	r22, r16
     53c:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN3IMU12SetDebugPortEP9DebugPort>
    pair2_imu.SetDebugPort2(&dbgPort2);
#endif
    
    //! Create timers for each of the IMU Masters. I use the TCx1 timers which are
    //! less capable, but it hardly matters as these are just setting a timer callback.
    TimerCntr   tcA(&TCC1);
     540:	7e 01       	movw	r14, r28
     542:	08 94       	sec
     544:	e1 1c       	adc	r14, r1
     546:	f1 1c       	adc	r15, r1
     548:	c7 01       	movw	r24, r14
     54a:	60 e4       	ldi	r22, 0x40	; 64
     54c:	78 e0       	ldi	r23, 0x08	; 8
     54e:	0e 94 1e 32 	call	0x643c	; 0x643c <_ZN9TimerCntrC1EP10TC1_struct>
    
    IMUManager imumgr(&cmdSerial);
     552:	8e 01       	movw	r16, r28
     554:	0c 5d       	subi	r16, 0xDC	; 220
     556:	1d 4f       	sbci	r17, 0xFD	; 253
     558:	3c e3       	ldi	r19, 0x3C	; 60
     55a:	43 2e       	mov	r4, r19
     55c:	51 2c       	mov	r5, r1
     55e:	4c 0e       	add	r4, r28
     560:	5d 1e       	adc	r5, r29
     562:	c8 01       	movw	r24, r16
     564:	b2 01       	movw	r22, r4
     566:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <_ZN10IMUManagerC1EP14HardwareSerial>
    imumgr.SetBlueLed(&PORTJ, PIN7_bm);
     56a:	c8 01       	movw	r24, r16
     56c:	60 e0       	ldi	r22, 0x00	; 0
     56e:	77 e0       	ldi	r23, 0x07	; 7
     570:	40 e8       	ldi	r20, 0x80	; 128
     572:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <_ZN10IMUManager10SetBlueLedEP11PORT_structh>
    imumgr.LedOff();
     576:	c8 01       	movw	r24, r16
     578:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <_ZN10IMUManager6LedOffEv>
    imumgr.SetTimer(&tcA);
     57c:	c8 01       	movw	r24, r16
     57e:	b7 01       	movw	r22, r14
     580:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <_ZN10IMUManager8SetTimerEP9TimerCntr>
    imumgr.AddIMU(&hand_imu);
     584:	c8 01       	movw	r24, r16
     586:	b3 01       	movw	r22, r6
     588:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <_ZN10IMUManager6AddIMUEP7IMUBase>
    imumgr.AddIMU(&single_imu);
     58c:	c8 01       	movw	r24, r16
     58e:	b4 01       	movw	r22, r8
     590:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <_ZN10IMUManager6AddIMUEP7IMUBase>
    imumgr.AddIMU(&pair1_imu);
     594:	c8 01       	movw	r24, r16
     596:	b5 01       	movw	r22, r10
     598:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <_ZN10IMUManager6AddIMUEP7IMUBase>
    imumgr.AddIMU(&pair2_imu);
     59c:	c8 01       	movw	r24, r16
     59e:	b6 01       	movw	r22, r12
     5a0:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <_ZN10IMUManager6AddIMUEP7IMUBase>
    imumgr.SampleRate(10); /// Give the rate a default value. Start low
     5a4:	c8 01       	movw	r24, r16
     5a6:	6a e0       	ldi	r22, 0x0A	; 10
     5a8:	70 e0       	ldi	r23, 0x00	; 0
     5aa:	0e 94 30 12 	call	0x2460	; 0x2460 <_ZN10IMUManager10SampleRateEj>
    
    GyroCmdProcessor cmdproc(&cmdSerial,&pMaster[0],&imumgr);
     5ae:	2d e4       	ldi	r18, 0x4D	; 77
     5b0:	e2 2e       	mov	r14, r18
     5b2:	f1 2c       	mov	r15, r1
     5b4:	ec 0e       	add	r14, r28
     5b6:	fd 1e       	adc	r15, r29
     5b8:	c7 01       	movw	r24, r14
     5ba:	b2 01       	movw	r22, r4
     5bc:	ae 01       	movw	r20, r28
     5be:	4b 5e       	subi	r20, 0xEB	; 235
     5c0:	5f 4f       	sbci	r21, 0xFF	; 255
     5c2:	98 01       	movw	r18, r16
     5c4:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN16GyroCmdProcessorC1EP14HardwareSerialPP10I2C_MasterP10IMUManager>

    sprintf(buffer,"Welcome to Gyro Glove.\nRev %d.%d.%d Date: %02d/%02d/%04d Built at: %02d:%02d\n",
        RevMajor, RevMinor, RevInc,
        DateMonth, DateDay, DateYear,
        TimeHour, TimeMin
        );
     5c8:	ed b7       	in	r30, 0x3d	; 61
     5ca:	fe b7       	in	r31, 0x3e	; 62
     5cc:	74 97       	sbiw	r30, 0x14	; 20
     5ce:	ed bf       	out	0x3d, r30	; 61
     5d0:	fe bf       	out	0x3e, r31	; 62
     5d2:	31 96       	adiw	r30, 0x01	; 1
     5d4:	90 ec       	ldi	r25, 0xC0	; 192
     5d6:	c9 2e       	mov	r12, r25
     5d8:	91 e0       	ldi	r25, 0x01	; 1
     5da:	d9 2e       	mov	r13, r25
     5dc:	cc 0e       	add	r12, r28
     5de:	dd 1e       	adc	r13, r29
     5e0:	ad b7       	in	r26, 0x3d	; 61
     5e2:	be b7       	in	r27, 0x3e	; 62
     5e4:	11 96       	adiw	r26, 0x01	; 1
     5e6:	cd 92       	st	X+, r12
     5e8:	dc 92       	st	X, r13
     5ea:	12 97       	sbiw	r26, 0x02	; 2
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	90 e2       	ldi	r25, 0x20	; 32
     5f0:	82 83       	std	Z+2, r24	; 0x02
     5f2:	93 83       	std	Z+3, r25	; 0x03
     5f4:	81 e0       	ldi	r24, 0x01	; 1
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	84 83       	std	Z+4, r24	; 0x04
     5fa:	95 83       	std	Z+5, r25	; 0x05
     5fc:	16 82       	std	Z+6, r1	; 0x06
     5fe:	17 82       	std	Z+7, r1	; 0x07
     600:	80 87       	std	Z+8, r24	; 0x08
     602:	91 87       	std	Z+9, r25	; 0x09
     604:	84 e0       	ldi	r24, 0x04	; 4
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	82 87       	std	Z+10, r24	; 0x0a
     60a:	93 87       	std	Z+11, r25	; 0x0b
     60c:	8b e1       	ldi	r24, 0x1B	; 27
     60e:	90 e0       	ldi	r25, 0x00	; 0
     610:	84 87       	std	Z+12, r24	; 0x0c
     612:	95 87       	std	Z+13, r25	; 0x0d
     614:	8b ed       	ldi	r24, 0xDB	; 219
     616:	97 e0       	ldi	r25, 0x07	; 7
     618:	86 87       	std	Z+14, r24	; 0x0e
     61a:	97 87       	std	Z+15, r25	; 0x0f
     61c:	82 e0       	ldi	r24, 0x02	; 2
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	80 8b       	std	Z+16, r24	; 0x10
     622:	91 8b       	std	Z+17, r25	; 0x11
     624:	83 e2       	ldi	r24, 0x23	; 35
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	82 8b       	std	Z+18, r24	; 0x12
     62a:	93 8b       	std	Z+19, r25	; 0x13
     62c:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    cmdSerial.print(buffer);
     630:	ed b7       	in	r30, 0x3d	; 61
     632:	fe b7       	in	r31, 0x3e	; 62
     634:	74 96       	adiw	r30, 0x14	; 20
     636:	ed bf       	out	0x3d, r30	; 61
     638:	fe bf       	out	0x3e, r31	; 62
     63a:	c2 01       	movw	r24, r4
     63c:	b6 01       	movw	r22, r12
     63e:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    
    //! This bit just toggles the light
    TimerCntr mdtc(&TCD0);
     642:	87 e0       	ldi	r24, 0x07	; 7
     644:	c8 2e       	mov	r12, r24
     646:	d1 2c       	mov	r13, r1
     648:	cc 0e       	add	r12, r28
     64a:	dd 1e       	adc	r13, r29
     64c:	c6 01       	movw	r24, r12
     64e:	60 e0       	ldi	r22, 0x00	; 0
     650:	79 e0       	ldi	r23, 0x09	; 9
     652:	0e 94 db 31 	call	0x63b6	; 0x63b6 <_ZN9TimerCntrC1EP10TC0_struct>
    volatile PORT_t*    bPort;
    
    unsigned long   _Rate;
    TimerCntr*      _pTimer;
    
    MyDriver() {
     656:	89 e6       	ldi	r24, 0x69	; 105
     658:	90 e2       	ldi	r25, 0x20	; 32
     65a:	8d 8f       	std	Y+29, r24	; 0x1d
     65c:	9e 8f       	std	Y+30, r25	; 0x1e
        bLedState = false;
     65e:	18 a2       	std	Y+32, r1	; 0x20
        bPort = (volatile PORT_t*)&PORTC;
     660:	e0 e4       	ldi	r30, 0x40	; 64
     662:	f6 e0       	ldi	r31, 0x06	; 6
     664:	eb a3       	std	Y+35, r30	; 0x23
     666:	fc a3       	std	Y+36, r31	; 0x24
        bPort->DIRSET = PIN6_bm;
     668:	80 e4       	ldi	r24, 0x40	; 64
     66a:	81 83       	std	Z+1, r24	; 0x01
        bPort->OUTSET = PIN6_bm; // Off when high
     66c:	85 83       	std	Z+5, r24	; 0x05
        
        _Rate = 2;
     66e:	82 e0       	ldi	r24, 0x02	; 2
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	a0 e0       	ldi	r26, 0x00	; 0
     674:	b0 e0       	ldi	r27, 0x00	; 0
     676:	8d a3       	std	Y+37, r24	; 0x25
     678:	9e a3       	std	Y+38, r25	; 0x26
     67a:	af a3       	std	Y+39, r26	; 0x27
     67c:	b8 a7       	std	Y+40, r27	; 0x28
    MyDriver md;
    md.SetTimer(&mdtc);
     67e:	ce 01       	movw	r24, r28
     680:	4d 96       	adiw	r24, 0x1d	; 29
     682:	b6 01       	movw	r22, r12
     684:	0e 94 52 01 	call	0x2a4	; 0x2a4 <_ZN8MyDriver8SetTimerEP9TimerCntr>
    
    cmdSerial.print("Starting endless loop\n");
     688:	c2 01       	movw	r24, r4
     68a:	6e e4       	ldi	r22, 0x4E	; 78
     68c:	70 e2       	ldi	r23, 0x20	; 32
     68e:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    
    while(1) {
        cmdproc.Loop();        
     692:	ae 2c       	mov	r10, r14
     694:	ef 2c       	mov	r14, r15
        imumgr.Loop();
     696:	c0 2e       	mov	r12, r16
     698:	01 2f       	mov	r16, r17
    md.SetTimer(&mdtc);
    
    cmdSerial.print("Starting endless loop\n");
    
    while(1) {
        cmdproc.Loop();        
     69a:	8a 2d       	mov	r24, r10
     69c:	9e 2d       	mov	r25, r14
     69e:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <_ZN16GyroCmdProcessor4LoopEv>
        imumgr.Loop();
     6a2:	8c 2d       	mov	r24, r12
     6a4:	90 2f       	mov	r25, r16
     6a6:	0e 94 91 13 	call	0x2722	; 0x2722 <_ZN10IMUManager4LoopEv>
     6aa:	f7 cf       	rjmp	.-18     	; 0x69a <main+0x364>

000006ac <_ZN3IMU7UseGyroEb>:
    virtual int Start();
    virtual int Stop();
    virtual int ForceStartStop();
    virtual bool Busy();
    virtual void ResetTimer();
    virtual void UseGyro(bool bEnable) { _bUseGyro = bEnable; };
     6ac:	fc 01       	movw	r30, r24
     6ae:	60 8f       	std	Z+24, r22	; 0x18
     6b0:	08 95       	ret

000006b2 <_ZN3IMU7NextIMUEP7IMUBase>:
    _bUseGyro   = false;
}

void IMU::NextIMU(IMUBase* pNext)
{
    _pNextIMU = pNext;
     6b2:	fc 01       	movw	r30, r24
     6b4:	e0 5b       	subi	r30, 0xB0	; 176
     6b6:	ff 4f       	sbci	r31, 0xFF	; 255
     6b8:	60 83       	st	Z, r22
     6ba:	71 83       	std	Z+1, r23	; 0x01
}
     6bc:	08 95       	ret

000006be <_ZN3IMU12SetDebugPortEP9DebugPort>:
    }
}

void IMU::SetDebugPort(DebugPort* pPort)
{
    _pDBGPort = pPort;
     6be:	fc 01       	movw	r30, r24
     6c0:	e4 5b       	subi	r30, 0xB4	; 180
     6c2:	ff 4f       	sbci	r31, 0xFF	; 255
     6c4:	60 83       	st	Z, r22
     6c6:	71 83       	std	Z+1, r23	; 0x01
}
     6c8:	08 95       	ret

000006ca <_ZN3IMU13SetDebugPort2EP9DebugPort>:

void IMU::SetDebugPort2(DebugPort* pPort)
{
    _pDBGPort2 = pPort;
     6ca:	fc 01       	movw	r30, r24
     6cc:	e2 5b       	subi	r30, 0xB2	; 178
     6ce:	ff 4f       	sbci	r31, 0xFF	; 255
     6d0:	60 83       	st	Z, r22
     6d2:	71 83       	std	Z+1, r23	; 0x01
}
     6d4:	08 95       	ret

000006d6 <_ZN3IMU4BusyEv>:
    SetState(sIdle);
    sei();
    return 0;
}

bool IMU::Busy()
     6d6:	fc 01       	movw	r30, r24
     6d8:	86 81       	ldd	r24, Z+6	; 0x06
     6da:	81 11       	cpse	r24, r1
     6dc:	81 e0       	ldi	r24, 0x01	; 1
{
    return _State != sIdle;
}
     6de:	08 95       	ret

000006e0 <_ZN3IMU9DataReadyEv>:
        SetState(_previousState);
        StartTransaction();
    }
}

bool IMU::DataReady()
     6e0:	fc 01       	movw	r30, r24
{
    if (_numChans == 0) return true;
     6e2:	84 85       	ldd	r24, Z+12	; 0x0c
     6e4:	88 23       	and	r24, r24
     6e6:	11 f4       	brne	.+4      	; 0x6ec <_ZN3IMU9DataReadyEv+0xc>
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	08 95       	ret
    
    bool bReady = false;
    cli();
     6ec:	f8 94       	cli
    if (_bDualChan) {
     6ee:	83 85       	ldd	r24, Z+11	; 0x0b
     6f0:	df 01       	movw	r26, r30
     6f2:	af 5b       	subi	r26, 0xBF	; 191
     6f4:	bf 4f       	sbci	r27, 0xFF	; 255
     6f6:	88 23       	and	r24, r24
     6f8:	51 f0       	breq	.+20     	; 0x70e <_ZN3IMU9DataReadyEv+0x2e>
        bReady =  _bDataReady[0] && _bDataReady[1];
     6fa:	8c 91       	ld	r24, X
     6fc:	88 23       	and	r24, r24
     6fe:	41 f0       	breq	.+16     	; 0x710 <_ZN3IMU9DataReadyEv+0x30>
     700:	ee 5b       	subi	r30, 0xBE	; 190
     702:	ff 4f       	sbci	r31, 0xFF	; 255
     704:	80 81       	ld	r24, Z
     706:	88 23       	and	r24, r24
     708:	19 f0       	breq	.+6      	; 0x710 <_ZN3IMU9DataReadyEv+0x30>
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	01 c0       	rjmp	.+2      	; 0x710 <_ZN3IMU9DataReadyEv+0x30>
    } else {
        bReady =  _bDataReady[0];
     70e:	8c 91       	ld	r24, X
    }
    sei();
     710:	78 94       	sei
    return bReady;
}
     712:	08 95       	ret

00000714 <_ZN3IMU8PushDataEh>:
}

//! Push the data in the temporary buffer onto the appropriate fifo
void IMU::PushData(uint8_t idx)
{
    _bDataReady[idx-1] = true;
     714:	fc 01       	movw	r30, r24
     716:	e6 0f       	add	r30, r22
     718:	f1 1d       	adc	r31, r1
     71a:	e0 5c       	subi	r30, 0xC0	; 192
     71c:	ff 4f       	sbci	r31, 0xFF	; 255
     71e:	81 e0       	ldi	r24, 0x01	; 1
     720:	80 83       	st	Z, r24
}
     722:	08 95       	ret

00000724 <_ZThn4_N3IMU3errEh>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
     724:	08 95       	ret

00000726 <_ZN3IMU3errEh>:
//@{

//! Timer Error - ignored.
void IMU::err(uint8_t id)
{
}
     726:	08 95       	ret

00000728 <_ZThn4_N3IMU3ccxEhh>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
     728:	08 95       	ret

0000072a <_ZN3IMU3ccxEhh>:
}

//! Timer Capture Compare - not used.
void IMU::ccx(uint8_t id,uint8_t idx)
{
}
     72a:	08 95       	ret

0000072c <_ZN3IMU8ReadWordEPj>:
{
    // Only a single write, the address, then read data.
    return _pMas->WriteRead(ID, &addr, 1, cnt);
}

void IMU::ReadWord(uint16_t* pData)
     72c:	0f 93       	push	r16
     72e:	1f 93       	push	r17
     730:	8b 01       	movw	r16, r22
{
    static uint8_t buffer[2];
    _pMas->ReadData(&buffer[0],2);
     732:	fc 01       	movw	r30, r24
     734:	81 85       	ldd	r24, Z+9	; 0x09
     736:	92 85       	ldd	r25, Z+10	; 0x0a
     738:	6e e2       	ldi	r22, 0x2E	; 46
     73a:	76 e2       	ldi	r23, 0x26	; 38
     73c:	42 e0       	ldi	r20, 0x02	; 2
     73e:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <_ZN10I2C_Master8ReadDataEPhh>
    *pData = (buffer[0] << 8 | buffer[1]);
     742:	90 91 2e 26 	lds	r25, 0x262E
     746:	80 e0       	ldi	r24, 0x00	; 0
     748:	20 91 2f 26 	lds	r18, 0x262F
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	82 2b       	or	r24, r18
     750:	93 2b       	or	r25, r19
     752:	f8 01       	movw	r30, r16
     754:	80 83       	st	Z, r24
     756:	91 83       	std	Z+1, r25	; 0x01
}
     758:	1f 91       	pop	r17
     75a:	0f 91       	pop	r16
     75c:	08 95       	ret

0000075e <_ZN3IMU12StoreAccDataEh>:
    _pMas->ReadData(&_dataBuffer[idx-1][0],8);
}

//! Add the accelerometer data to the buffer
//! I have the index there in case I need it later..
void IMU::StoreAccData(uint8_t idx)
     75e:	fc 01       	movw	r30, r24
{
    _pMas->ReadData(&_dataBuffer[idx-1][8],6);
     760:	70 e0       	ldi	r23, 0x00	; 0
     762:	61 50       	subi	r22, 0x01	; 1
     764:	70 40       	sbci	r23, 0x00	; 0
     766:	84 e1       	ldi	r24, 0x14	; 20
     768:	90 e0       	ldi	r25, 0x00	; 0
     76a:	9b 01       	movw	r18, r22
     76c:	28 9f       	mul	r18, r24
     76e:	b0 01       	movw	r22, r0
     770:	29 9f       	mul	r18, r25
     772:	70 0d       	add	r23, r0
     774:	38 9f       	mul	r19, r24
     776:	70 0d       	add	r23, r0
     778:	11 24       	eor	r1, r1
     77a:	6f 5d       	subi	r22, 0xDF	; 223
     77c:	7f 4f       	sbci	r23, 0xFF	; 255
     77e:	6e 0f       	add	r22, r30
     780:	7f 1f       	adc	r23, r31
     782:	81 85       	ldd	r24, Z+9	; 0x09
     784:	92 85       	ldd	r25, Z+10	; 0x0a
     786:	46 e0       	ldi	r20, 0x06	; 6
     788:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <_ZN10I2C_Master8ReadDataEPhh>
}
     78c:	08 95       	ret

0000078e <_ZN3IMU13StoreGyroDataEh>:
    return bReady;
}

//! Store the gyro read data while I get the Accelerometer data
//! I have the index there in case I need it later..
void IMU::StoreGyroData(uint8_t idx)
     78e:	fc 01       	movw	r30, r24
{
    _pMas->ReadData(&_dataBuffer[idx-1][0],8);
     790:	70 e0       	ldi	r23, 0x00	; 0
     792:	61 50       	subi	r22, 0x01	; 1
     794:	70 40       	sbci	r23, 0x00	; 0
     796:	84 e1       	ldi	r24, 0x14	; 20
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	9b 01       	movw	r18, r22
     79c:	28 9f       	mul	r18, r24
     79e:	b0 01       	movw	r22, r0
     7a0:	29 9f       	mul	r18, r25
     7a2:	70 0d       	add	r23, r0
     7a4:	38 9f       	mul	r19, r24
     7a6:	70 0d       	add	r23, r0
     7a8:	11 24       	eor	r1, r1
     7aa:	67 5e       	subi	r22, 0xE7	; 231
     7ac:	7f 4f       	sbci	r23, 0xFF	; 255
     7ae:	6e 0f       	add	r22, r30
     7b0:	7f 1f       	adc	r23, r31
     7b2:	81 85       	ldd	r24, Z+9	; 0x09
     7b4:	92 85       	ldd	r25, Z+10	; 0x0a
     7b6:	48 e0       	ldi	r20, 0x08	; 8
     7b8:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <_ZN10I2C_Master8ReadDataEPhh>
}
     7bc:	08 95       	ret

000007be <_ZN3IMU7RdAsyncEhhh>:
    sprintf(buffer,"WrAsync to %d\n",ID);
    if (pdbgserial) pdbgserial->print(buffer);
    return _pMas->WriteRead(ID, &bytes[0],2,0);
}

int IMU::RdAsync(uint8_t ID, uint8_t addr, uint8_t cnt)
     7be:	0f 93       	push	r16
     7c0:	df 93       	push	r29
     7c2:	cf 93       	push	r28
     7c4:	0f 92       	push	r0
     7c6:	cd b7       	in	r28, 0x3d	; 61
     7c8:	de b7       	in	r29, 0x3e	; 62
     7ca:	49 83       	std	Y+1, r20	; 0x01
     7cc:	02 2f       	mov	r16, r18
{
    // Only a single write, the address, then read data.
    return _pMas->WriteRead(ID, &addr, 1, cnt);
     7ce:	fc 01       	movw	r30, r24
     7d0:	81 85       	ldd	r24, Z+9	; 0x09
     7d2:	92 85       	ldd	r25, Z+10	; 0x0a
     7d4:	ae 01       	movw	r20, r28
     7d6:	4f 5f       	subi	r20, 0xFF	; 255
     7d8:	5f 4f       	sbci	r21, 0xFF	; 255
     7da:	21 e0       	ldi	r18, 0x01	; 1
     7dc:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <_ZN10I2C_Master9WriteReadEhPhhh>
     7e0:	28 2f       	mov	r18, r24
     7e2:	33 27       	eor	r19, r19
     7e4:	27 fd       	sbrc	r18, 7
     7e6:	30 95       	com	r19
}
     7e8:	c9 01       	movw	r24, r18
     7ea:	0f 90       	pop	r0
     7ec:	cf 91       	pop	r28
     7ee:	df 91       	pop	r29
     7f0:	0f 91       	pop	r16
     7f2:	08 95       	ret

000007f4 <_ZN3IMU16StartTransactionEv>:
    default:
        break;
    }
}

int IMU::StartTransaction()
     7f4:	cf 93       	push	r28
     7f6:	df 93       	push	r29
     7f8:	ec 01       	movw	r28, r24
{
    int retc = 0;
    switch(_State) {
     7fa:	8e 81       	ldd	r24, Y+6	; 0x06
     7fc:	89 30       	cpi	r24, 0x09	; 9
     7fe:	69 f0       	breq	.+26     	; 0x81a <_ZN3IMU16StartTransactionEv+0x26>
     800:	8a 30       	cpi	r24, 0x0A	; 10
     802:	18 f4       	brcc	.+6      	; 0x80a <_ZN3IMU16StartTransactionEv+0x16>
     804:	88 30       	cpi	r24, 0x08	; 8
     806:	b9 f4       	brne	.+46     	; 0x836 <_ZN3IMU16StartTransactionEv+0x42>
     808:	05 c0       	rjmp	.+10     	; 0x814 <_ZN3IMU16StartTransactionEv+0x20>
     80a:	8a 30       	cpi	r24, 0x0A	; 10
     80c:	49 f0       	breq	.+18     	; 0x820 <_ZN3IMU16StartTransactionEv+0x2c>
     80e:	8b 30       	cpi	r24, 0x0B	; 11
     810:	91 f4       	brne	.+36     	; 0x836 <_ZN3IMU16StartTransactionEv+0x42>
     812:	0b c0       	rjmp	.+22     	; 0x82a <_ZN3IMU16StartTransactionEv+0x36>
    case sReadGyro1:
        RdAsync(_gID[0], 0x1B, 8);
     814:	ce 01       	movw	r24, r28
     816:	6f 85       	ldd	r22, Y+15	; 0x0f
     818:	05 c0       	rjmp	.+10     	; 0x824 <_ZN3IMU16StartTransactionEv+0x30>
        break;
    case sReadAcc1:
        RdAsync(_aID[0], 0x80 | 0x28, 6);
     81a:	ce 01       	movw	r24, r28
     81c:	69 89       	ldd	r22, Y+17	; 0x11
     81e:	07 c0       	rjmp	.+14     	; 0x82e <_ZN3IMU16StartTransactionEv+0x3a>
        break;
    case sReadGyro2:
        RdAsync(_gID[1], 0x1B, 8);
     820:	ce 01       	movw	r24, r28
     822:	68 89       	ldd	r22, Y+16	; 0x10
     824:	4b e1       	ldi	r20, 0x1B	; 27
     826:	28 e0       	ldi	r18, 0x08	; 8
     828:	04 c0       	rjmp	.+8      	; 0x832 <_ZN3IMU16StartTransactionEv+0x3e>
        break;
    case sReadAcc2:
        RdAsync(_aID[1], 0x80 | 0x28, 6);
     82a:	ce 01       	movw	r24, r28
     82c:	6a 89       	ldd	r22, Y+18	; 0x12
     82e:	48 ea       	ldi	r20, 0xA8	; 168
     830:	26 e0       	ldi	r18, 0x06	; 6
     832:	0e 94 df 03 	call	0x7be	; 0x7be <_ZN3IMU7RdAsyncEhhh>
        if (_pDBGPort2) _pDBGPort2->SetState((uint8_t) p);
    }
    
    inline void ResetBusyTime()
    {
        _busyWaitTime = millis();
     836:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
     83a:	c6 5b       	subi	r28, 0xB6	; 182
     83c:	df 4f       	sbci	r29, 0xFF	; 255
     83e:	68 83       	st	Y, r22
     840:	79 83       	std	Y+1, r23	; 0x01
    default:
        break;
    }
    ResetBusyTime();
    return retc;
}
     842:	80 e0       	ldi	r24, 0x00	; 0
     844:	90 e0       	ldi	r25, 0x00	; 0
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	08 95       	ret

0000084c <_ZN3IMU7WrAsyncEhhh>:
        return retc;
    }
    return _pMas->ReadData(pData,cnt);
}

int IMU::WrAsync(uint8_t ID, uint8_t addr, uint8_t data)
     84c:	ff 92       	push	r15
     84e:	0f 93       	push	r16
     850:	1f 93       	push	r17
     852:	cf 93       	push	r28
     854:	df 93       	push	r29
     856:	8c 01       	movw	r16, r24
     858:	f6 2e       	mov	r15, r22
{
    static uint8_t  bytes[2];
    bytes[0] = addr;
     85a:	40 93 b0 26 	sts	0x26B0, r20
    bytes[1] = data;
     85e:	20 93 b1 26 	sts	0x26B1, r18
    sprintf(buffer,"WrAsync to %d\n",ID);
     862:	00 d0       	rcall	.+0      	; 0x864 <_ZN3IMU7WrAsyncEhhh+0x18>
     864:	00 d0       	rcall	.+0      	; 0x866 <_ZN3IMU7WrAsyncEhhh+0x1a>
     866:	ed b7       	in	r30, 0x3d	; 61
     868:	fe b7       	in	r31, 0x3e	; 62
     86a:	31 96       	adiw	r30, 0x01	; 1
     86c:	c0 e3       	ldi	r28, 0x30	; 48
     86e:	d6 e2       	ldi	r29, 0x26	; 38
     870:	ad b7       	in	r26, 0x3d	; 61
     872:	be b7       	in	r27, 0x3e	; 62
     874:	11 96       	adiw	r26, 0x01	; 1
     876:	cd 93       	st	X+, r28
     878:	dc 93       	st	X, r29
     87a:	12 97       	sbiw	r26, 0x02	; 2
     87c:	8d e7       	ldi	r24, 0x7D	; 125
     87e:	90 e2       	ldi	r25, 0x20	; 32
     880:	82 83       	std	Z+2, r24	; 0x02
     882:	93 83       	std	Z+3, r25	; 0x03
     884:	64 83       	std	Z+4, r22	; 0x04
     886:	15 82       	std	Z+5, r1	; 0x05
     888:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->print(buffer);
     88c:	80 91 2a 26 	lds	r24, 0x262A
     890:	90 91 2b 26 	lds	r25, 0x262B
     894:	ed b7       	in	r30, 0x3d	; 61
     896:	fe b7       	in	r31, 0x3e	; 62
     898:	36 96       	adiw	r30, 0x06	; 6
     89a:	ed bf       	out	0x3d, r30	; 61
     89c:	fe bf       	out	0x3e, r31	; 62
     89e:	00 97       	sbiw	r24, 0x00	; 0
     8a0:	19 f0       	breq	.+6      	; 0x8a8 <_ZN3IMU7WrAsyncEhhh+0x5c>
     8a2:	be 01       	movw	r22, r28
     8a4:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    return _pMas->WriteRead(ID, &bytes[0],2,0);
     8a8:	d8 01       	movw	r26, r16
     8aa:	19 96       	adiw	r26, 0x09	; 9
     8ac:	8d 91       	ld	r24, X+
     8ae:	9c 91       	ld	r25, X
     8b0:	1a 97       	sbiw	r26, 0x0a	; 10
     8b2:	6f 2d       	mov	r22, r15
     8b4:	40 eb       	ldi	r20, 0xB0	; 176
     8b6:	56 e2       	ldi	r21, 0x26	; 38
     8b8:	22 e0       	ldi	r18, 0x02	; 2
     8ba:	00 e0       	ldi	r16, 0x00	; 0
     8bc:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <_ZN10I2C_Master9WriteReadEhPhhh>
     8c0:	28 2f       	mov	r18, r24
     8c2:	33 27       	eor	r19, r19
     8c4:	27 fd       	sbrc	r18, 7
     8c6:	30 95       	com	r19
}
     8c8:	c9 01       	movw	r24, r18
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	1f 91       	pop	r17
     8d0:	0f 91       	pop	r16
     8d2:	ff 90       	pop	r15
     8d4:	08 95       	ret

000008d6 <_ZN3IMU2RdEhhhPh>:
    bytes[0] = addr;
    bytes[1] = data;
    return _pMas->WriteSync(ID, &bytes[0],2);
}

int IMU::Rd(uint8_t ID, uint8_t addr, uint8_t cnt, uint8_t* pData)
     8d6:	bf 92       	push	r11
     8d8:	cf 92       	push	r12
     8da:	df 92       	push	r13
     8dc:	ef 92       	push	r14
     8de:	ff 92       	push	r15
     8e0:	0f 93       	push	r16
     8e2:	1f 93       	push	r17
     8e4:	df 93       	push	r29
     8e6:	cf 93       	push	r28
     8e8:	0f 92       	push	r0
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
     8ee:	7c 01       	movw	r14, r24
     8f0:	49 83       	std	Y+1, r20	; 0x01
     8f2:	b2 2e       	mov	r11, r18
     8f4:	68 01       	movw	r12, r16
{
    // Only a single write, the address, then read data.
    int retc = _pMas->WriteReadSync(ID, &addr, 1, cnt);
     8f6:	fc 01       	movw	r30, r24
     8f8:	81 85       	ldd	r24, Z+9	; 0x09
     8fa:	92 85       	ldd	r25, Z+10	; 0x0a
     8fc:	ae 01       	movw	r20, r28
     8fe:	4f 5f       	subi	r20, 0xFF	; 255
     900:	5f 4f       	sbci	r21, 0xFF	; 255
     902:	21 e0       	ldi	r18, 0x01	; 1
     904:	0b 2d       	mov	r16, r11
     906:	0e 94 4a 28 	call	0x5094	; 0x5094 <_ZN10I2C_Master13WriteReadSyncEhPhhh>
     90a:	28 2f       	mov	r18, r24
     90c:	33 27       	eor	r19, r19
     90e:	27 fd       	sbrc	r18, 7
     910:	30 95       	com	r19
    if ( retc < 0 ) {
     912:	37 fd       	sbrc	r19, 7
     914:	09 c0       	rjmp	.+18     	; 0x928 <_ZN3IMU2RdEhhhPh+0x52>
        return retc;
    }
    return _pMas->ReadData(pData,cnt);
     916:	f7 01       	movw	r30, r14
     918:	81 85       	ldd	r24, Z+9	; 0x09
     91a:	92 85       	ldd	r25, Z+10	; 0x0a
     91c:	b6 01       	movw	r22, r12
     91e:	4b 2d       	mov	r20, r11
     920:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <_ZN10I2C_Master8ReadDataEPhh>
     924:	28 2f       	mov	r18, r24
     926:	30 e0       	ldi	r19, 0x00	; 0
}
     928:	c9 01       	movw	r24, r18
     92a:	0f 90       	pop	r0
     92c:	cf 91       	pop	r28
     92e:	df 91       	pop	r29
     930:	1f 91       	pop	r17
     932:	0f 91       	pop	r16
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	df 90       	pop	r13
     93a:	cf 90       	pop	r12
     93c:	bf 90       	pop	r11
     93e:	08 95       	ret

00000940 <_ZN3IMU2WrEhhh>:
//@}

int IMU::Wr(uint8_t ID, uint8_t addr, uint8_t data)
{
    static uint8_t  bytes[2];
    bytes[0] = addr;
     940:	40 93 b2 26 	sts	0x26B2, r20
    bytes[1] = data;
     944:	20 93 b3 26 	sts	0x26B3, r18
    return _pMas->WriteSync(ID, &bytes[0],2);
     948:	fc 01       	movw	r30, r24
     94a:	81 85       	ldd	r24, Z+9	; 0x09
     94c:	92 85       	ldd	r25, Z+10	; 0x0a
     94e:	42 eb       	ldi	r20, 0xB2	; 178
     950:	56 e2       	ldi	r21, 0x26	; 38
     952:	22 e0       	ldi	r18, 0x02	; 2
     954:	0e 94 89 28 	call	0x5112	; 0x5112 <_ZN10I2C_Master9WriteSyncEhPhh>
     958:	28 2f       	mov	r18, r24
     95a:	33 27       	eor	r19, r19
     95c:	27 fd       	sbrc	r18, 7
     95e:	30 95       	com	r19
}
     960:	c9 01       	movw	r24, r18
     962:	08 95       	ret

00000964 <_ZN3IMU9ConfigureEh>:

//! Configure the Gyro and Accelerometer device.
//! The input parameter selects the first or second channel.
//! Build an array of RegWrite types so that I can check
//! the return code of each write to insure they all pass.
int IMU::Configure(uint8_t idx)
     964:	8f 92       	push	r8
     966:	9f 92       	push	r9
     968:	af 92       	push	r10
     96a:	bf 92       	push	r11
     96c:	cf 92       	push	r12
     96e:	df 92       	push	r13
     970:	ef 92       	push	r14
     972:	ff 92       	push	r15
     974:	0f 93       	push	r16
     976:	1f 93       	push	r17
     978:	df 93       	push	r29
     97a:	cf 93       	push	r28
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
     980:	e6 97       	sbiw	r28, 0x36	; 54
     982:	cd bf       	out	0x3d, r28	; 61
     984:	de bf       	out	0x3e, r29	; 62
     986:	6c 01       	movw	r12, r24
     988:	26 2f       	mov	r18, r22
{
    // Value for the sensor register
    uint16_t gval = 1000/_Rate;
     98a:	fc 01       	movw	r30, r24
     98c:	66 89       	ldd	r22, Z+22	; 0x16
     98e:	77 89       	ldd	r23, Z+23	; 0x17
     990:	88 ee       	ldi	r24, 0xE8	; 232
     992:	93 e0       	ldi	r25, 0x03	; 3
     994:	0e 94 4d 49 	call	0x929a	; 0x929a <__udivmodhi4>
     998:	ab 01       	movw	r20, r22
        { _gID[idx], 0x15, gval},                     // Set sample rate
        { _gID[idx], 0x16, _DLPF | _FullScale << 3},
        { _gID[idx], 0x17, 0x00},
    //    { _gID[idx], 0x18, 0x80 | 0x28},              // Set burst address for Accelerometer, enable auto addr increment.
        { _gID[idx], 0x3E, _ClkSel},
    };
     99a:	de 01       	movw	r26, r28
     99c:	11 96       	adiw	r26, 0x01	; 1
     99e:	86 e3       	ldi	r24, 0x36	; 54
     9a0:	fd 01       	movw	r30, r26
     9a2:	11 92       	st	Z+, r1
     9a4:	8a 95       	dec	r24
     9a6:	e9 f7       	brne	.-6      	; 0x9a2 <_ZN3IMU9ConfigureEh+0x3e>
     9a8:	8d e3       	ldi	r24, 0x3D	; 61
     9aa:	8a 83       	std	Y+2, r24	; 0x02
     9ac:	9f e0       	ldi	r25, 0x0F	; 15
     9ae:	9b 83       	std	Y+3, r25	; 0x03
     9b0:	80 e2       	ldi	r24, 0x20	; 32
     9b2:	8d 83       	std	Y+5, r24	; 0x05
     9b4:	87 e3       	ldi	r24, 0x37	; 55
     9b6:	8e 83       	std	Y+6, r24	; 0x06
     9b8:	81 e2       	ldi	r24, 0x21	; 33
     9ba:	88 87       	std	Y+8, r24	; 0x08
     9bc:	82 e2       	ldi	r24, 0x22	; 34
     9be:	8b 87       	std	Y+11, r24	; 0x0b
     9c0:	83 e2       	ldi	r24, 0x23	; 35
     9c2:	8e 87       	std	Y+14, r24	; 0x0e
     9c4:	80 ec       	ldi	r24, 0xC0	; 192
     9c6:	8f 87       	std	Y+15, r24	; 0x0f
     9c8:	84 e2       	ldi	r24, 0x24	; 36
     9ca:	89 8b       	std	Y+17, r24	; 0x11
     9cc:	8c e0       	ldi	r24, 0x0C	; 12
     9ce:	8c 8b       	std	Y+20, r24	; 0x14
     9d0:	8d e0       	ldi	r24, 0x0D	; 13
     9d2:	8f 8b       	std	Y+23, r24	; 0x17
     9d4:	8e e0       	ldi	r24, 0x0E	; 14
     9d6:	8a 8f       	std	Y+26, r24	; 0x1a
     9d8:	9d 8f       	std	Y+29, r25	; 0x1d
     9da:	80 e1       	ldi	r24, 0x10	; 16
     9dc:	88 a3       	std	Y+32, r24	; 0x20
     9de:	81 e1       	ldi	r24, 0x11	; 17
     9e0:	8b a3       	std	Y+35, r24	; 0x23
     9e2:	82 e1       	ldi	r24, 0x12	; 18
     9e4:	8e a3       	std	Y+38, r24	; 0x26
     9e6:	8f ef       	ldi	r24, 0xFF	; 255
     9e8:	8f a3       	std	Y+39, r24	; 0x27
     9ea:	83 e1       	ldi	r24, 0x13	; 19
     9ec:	89 a7       	std	Y+41, r24	; 0x29
     9ee:	85 e1       	ldi	r24, 0x15	; 21
     9f0:	8c a7       	std	Y+44, r24	; 0x2c
     9f2:	86 e1       	ldi	r24, 0x16	; 22
     9f4:	8f a7       	std	Y+47, r24	; 0x2f
     9f6:	87 e1       	ldi	r24, 0x17	; 23
     9f8:	8a ab       	std	Y+50, r24	; 0x32
     9fa:	8e e3       	ldi	r24, 0x3E	; 62
     9fc:	8d ab       	std	Y+53, r24	; 0x35
     9fe:	f6 01       	movw	r30, r12
     a00:	e2 0f       	add	r30, r18
     a02:	f1 1d       	adc	r31, r1
     a04:	27 85       	ldd	r18, Z+15	; 0x0f
     a06:	29 83       	std	Y+1, r18	; 0x01
     a08:	81 89       	ldd	r24, Z+17	; 0x11
     a0a:	8c 83       	std	Y+4, r24	; 0x04
     a0c:	8f 83       	std	Y+7, r24	; 0x07
     a0e:	8a 87       	std	Y+10, r24	; 0x0a
     a10:	8d 87       	std	Y+13, r24	; 0x0d
     a12:	88 8b       	std	Y+16, r24	; 0x10
     a14:	2b 8b       	std	Y+19, r18	; 0x13
     a16:	2e 8b       	std	Y+22, r18	; 0x16
     a18:	29 8f       	std	Y+25, r18	; 0x19
     a1a:	2c 8f       	std	Y+28, r18	; 0x1c
     a1c:	2f 8f       	std	Y+31, r18	; 0x1f
     a1e:	2a a3       	std	Y+34, r18	; 0x22
     a20:	2d a3       	std	Y+37, r18	; 0x25
     a22:	28 a7       	std	Y+40, r18	; 0x28
     a24:	2b a7       	std	Y+43, r18	; 0x2b
     a26:	41 50       	subi	r20, 0x01	; 1
     a28:	50 40       	sbci	r21, 0x00	; 0
     a2a:	4d a7       	std	Y+45, r20	; 0x2d
     a2c:	2e a7       	std	Y+46, r18	; 0x2e
     a2e:	f6 01       	movw	r30, r12
     a30:	84 89       	ldd	r24, Z+20	; 0x14
     a32:	88 0f       	add	r24, r24
     a34:	88 0f       	add	r24, r24
     a36:	88 0f       	add	r24, r24
     a38:	93 89       	ldd	r25, Z+19	; 0x13
     a3a:	89 2b       	or	r24, r25
     a3c:	88 ab       	std	Y+48, r24	; 0x30
     a3e:	29 ab       	std	Y+49, r18	; 0x31
     a40:	2c ab       	std	Y+52, r18	; 0x34
     a42:	85 89       	ldd	r24, Z+21	; 0x15
     a44:	8e ab       	std	Y+54, r24	; 0x36
     a46:	7d 01       	movw	r14, r26
     a48:	9a e4       	ldi	r25, 0x4A	; 74
     a4a:	a9 2e       	mov	r10, r25
     a4c:	b1 2c       	mov	r11, r1
     a4e:	ac 0c       	add	r10, r12
     a50:	bd 1c       	adc	r11, r13
    
    uint8_t nItems = sizeof(config)/sizeof(RegWriteType);
    for (int idx = 0;idx <nItems;idx++) {
     a52:	87 e3       	ldi	r24, 0x37	; 55
     a54:	88 2e       	mov	r8, r24
     a56:	91 2c       	mov	r9, r1
     a58:	8c 0e       	add	r8, r28
     a5a:	9d 1e       	adc	r9, r29
        retc = Wr(config[idx].ID, 
            config[idx].Addr,
            config[idx].Data);
     a5c:	c6 01       	movw	r24, r12
     a5e:	f7 01       	movw	r30, r14
     a60:	60 81       	ld	r22, Z
     a62:	41 81       	ldd	r20, Z+1	; 0x01
     a64:	22 81       	ldd	r18, Z+2	; 0x02
     a66:	0e 94 a0 04 	call	0x940	; 0x940 <_ZN3IMU2WrEhhh>
     a6a:	8c 01       	movw	r16, r24
     a6c:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
     a70:	f5 01       	movw	r30, r10
     a72:	60 83       	st	Z, r22
     a74:	71 83       	std	Z+1, r23	; 0x01
        ResetBusyTime();
        
        if (retc < 0) {
     a76:	17 fd       	sbrc	r17, 7
     a78:	09 c0       	rjmp	.+18     	; 0xa8c <_ZN3IMU9ConfigureEh+0x128>
     a7a:	83 e0       	ldi	r24, 0x03	; 3
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	e8 0e       	add	r14, r24
     a80:	f9 1e       	adc	r15, r25
    //    { _gID[idx], 0x18, 0x80 | 0x28},              // Set burst address for Accelerometer, enable auto addr increment.
        { _gID[idx], 0x3E, _ClkSel},
    };
    
    uint8_t nItems = sizeof(config)/sizeof(RegWriteType);
    for (int idx = 0;idx <nItems;idx++) {
     a82:	e8 14       	cp	r14, r8
     a84:	f9 04       	cpc	r15, r9
     a86:	51 f7       	brne	.-44     	; 0xa5c <_ZN3IMU9ConfigureEh+0xf8>
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	10 e0       	ldi	r17, 0x00	; 0
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
     a8c:	c8 01       	movw	r24, r16
     a8e:	e6 96       	adiw	r28, 0x36	; 54
     a90:	cd bf       	out	0x3d, r28	; 61
     a92:	de bf       	out	0x3e, r29	; 62
     a94:	cf 91       	pop	r28
     a96:	df 91       	pop	r29
     a98:	1f 91       	pop	r17
     a9a:	0f 91       	pop	r16
     a9c:	ff 90       	pop	r15
     a9e:	ef 90       	pop	r14
     aa0:	df 90       	pop	r13
     aa2:	cf 90       	pop	r12
     aa4:	bf 90       	pop	r11
     aa6:	af 90       	pop	r10
     aa8:	9f 90       	pop	r9
     aaa:	8f 90       	pop	r8
     aac:	08 95       	ret

00000aae <_ZN3IMU14SetTimerPeriodEv>:
void IMU::ResetTimer()
{
    if (_pTimer) _pTimer->Counter(0);
}

void IMU::SetTimerPeriod()
     aae:	cf 93       	push	r28
     ab0:	df 93       	push	r29
     ab2:	fc 01       	movw	r30, r24
    // We set the timer to go off 5 times per IMU period.
    // This should range from 20ms for 10Hz, and 1 ms for 200
    // **** NoFifo
    // Set timer to fire at the rate.
    //unsigned long timerTicks = 100000/_Rate;
    unsigned long timerTicks = 500000/_Rate;
     ab4:	26 89       	ldd	r18, Z+22	; 0x16
     ab6:	37 89       	ldd	r19, Z+23	; 0x17
    if (timerTicks > 65000) {
        timerTicks = 65000;
    }
    if (_pTimer) _pTimer->Period(timerTicks);
     ab8:	ed 5b       	subi	r30, 0xBD	; 189
     aba:	ff 4f       	sbci	r31, 0xFF	; 255
     abc:	c0 81       	ld	r28, Z
     abe:	d1 81       	ldd	r29, Z+1	; 0x01
     ac0:	20 97       	sbiw	r28, 0x00	; 0
     ac2:	e1 f0       	breq	.+56     	; 0xafc <_ZN3IMU14SetTimerPeriodEv+0x4e>
    // We set the timer to go off 5 times per IMU period.
    // This should range from 20ms for 10Hz, and 1 ms for 200
    // **** NoFifo
    // Set timer to fire at the rate.
    //unsigned long timerTicks = 100000/_Rate;
    unsigned long timerTicks = 500000/_Rate;
     ac4:	40 e0       	ldi	r20, 0x00	; 0
     ac6:	50 e0       	ldi	r21, 0x00	; 0
     ac8:	60 e2       	ldi	r22, 0x20	; 32
     aca:	71 ea       	ldi	r23, 0xA1	; 161
     acc:	87 e0       	ldi	r24, 0x07	; 7
     ace:	90 e0       	ldi	r25, 0x00	; 0
     ad0:	0e 94 96 49 	call	0x932c	; 0x932c <__divmodsi4>
    if (timerTicks > 65000) {
        timerTicks = 65000;
    }
    if (_pTimer) _pTimer->Period(timerTicks);
     ad4:	c9 01       	movw	r24, r18
     ad6:	da 01       	movw	r26, r20
     ad8:	9c 01       	movw	r18, r24
     ada:	ad 01       	movw	r20, r26
     adc:	29 3e       	cpi	r18, 0xE9	; 233
     ade:	8d ef       	ldi	r24, 0xFD	; 253
     ae0:	38 07       	cpc	r19, r24
     ae2:	80 e0       	ldi	r24, 0x00	; 0
     ae4:	48 07       	cpc	r20, r24
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	58 07       	cpc	r21, r24
     aea:	20 f0       	brcs	.+8      	; 0xaf4 <_ZN3IMU14SetTimerPeriodEv+0x46>
     aec:	28 ee       	ldi	r18, 0xE8	; 232
     aee:	3d ef       	ldi	r19, 0xFD	; 253
     af0:	40 e0       	ldi	r20, 0x00	; 0
     af2:	50 e0       	ldi	r21, 0x00	; 0
     af4:	ce 01       	movw	r24, r28
     af6:	b9 01       	movw	r22, r18
     af8:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <_ZN9TimerCntr6PeriodEj>
}
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	08 95       	ret

00000b02 <_ZN3IMU10SampleRateEj>:
int IMU::ForceStartStop()
{
    return _pMas->ForceStartStop();
}

void IMU::SampleRate(uint16_t rate)
     b02:	cf 93       	push	r28
     b04:	df 93       	push	r29
     b06:	ec 01       	movw	r28, r24
{
    // Range Limit the rate.
    if (rate < 10) {
     b08:	6a 30       	cpi	r22, 0x0A	; 10
     b0a:	71 05       	cpc	r23, r1
     b0c:	18 f4       	brcc	.+6      	; 0xb14 <_ZN3IMU10SampleRateEj+0x12>
        _Rate = 10;
     b0e:	8a e0       	ldi	r24, 0x0A	; 10
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <_ZN3IMU10SampleRateEj+0x1c>
    } else if (rate > 200) {
     b14:	69 3c       	cpi	r22, 0xC9	; 201
     b16:	71 05       	cpc	r23, r1
     b18:	28 f0       	brcs	.+10     	; 0xb24 <_ZN3IMU10SampleRateEj+0x22>
        _Rate = 200;
     b1a:	88 ec       	ldi	r24, 0xC8	; 200
     b1c:	90 e0       	ldi	r25, 0x00	; 0
     b1e:	8e 8b       	std	Y+22, r24	; 0x16
     b20:	9f 8b       	std	Y+23, r25	; 0x17
     b22:	02 c0       	rjmp	.+4      	; 0xb28 <_ZN3IMU10SampleRateEj+0x26>
    } else {
        _Rate = rate;
     b24:	6e 8b       	std	Y+22, r22	; 0x16
     b26:	7f 8b       	std	Y+23, r23	; 0x17
    }
    
    uint16_t gval = 1000/rate;
    gval = gval - 1;
    
    if (pdbgserial) pdbgserial->print("Set Rate on IMU\n");
     b28:	80 91 2a 26 	lds	r24, 0x262A
     b2c:	90 91 2b 26 	lds	r25, 0x262B
     b30:	00 97       	sbiw	r24, 0x00	; 0
     b32:	21 f0       	breq	.+8      	; 0xb3c <_ZN3IMU10SampleRateEj+0x3a>
     b34:	6c e8       	ldi	r22, 0x8C	; 140
     b36:	70 e2       	ldi	r23, 0x20	; 32
     b38:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    
    SetTimerPeriod();
     b3c:	ce 01       	movw	r24, r28
     b3e:	0e 94 57 05 	call	0xaae	; 0xaae <_ZN3IMU14SetTimerPeriodEv>
}
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	08 95       	ret

00000b48 <_ZN3IMU10ResetTimerEv>:

//! Reset the counter value. The master uses this to get all of the
//! timers operating at the same time.
void IMU::ResetTimer()
{
    if (_pTimer) _pTimer->Counter(0);
     b48:	fc 01       	movw	r30, r24
     b4a:	ed 5b       	subi	r30, 0xBD	; 189
     b4c:	ff 4f       	sbci	r31, 0xFF	; 255
     b4e:	80 81       	ld	r24, Z
     b50:	91 81       	ldd	r25, Z+1	; 0x01
     b52:	00 97       	sbiw	r24, 0x00	; 0
     b54:	21 f0       	breq	.+8      	; 0xb5e <_ZN3IMU10ResetTimerEv+0x16>
     b56:	60 e0       	ldi	r22, 0x00	; 0
     b58:	70 e0       	ldi	r23, 0x00	; 0
     b5a:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <_ZN9TimerCntr7CounterEj>
     b5e:	08 95       	ret

00000b60 <_ZN3IMU8SetTimerEP9TimerCntr>:
//! if a slower rate is used, just to avoid as much overhead.
//! The CPU Clock runs at 32Mhz, so the main timer clock is running
//! at 32/64 or 500us period. 
//! Timer set to same interrupt level as the I2C so that those
//! interrupts won't ever stomp on each other.
void IMU::SetTimer(TimerCntr* pTimer)
     b60:	ef 92       	push	r14
     b62:	ff 92       	push	r15
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	8c 01       	movw	r16, r24
     b6a:	cb 01       	movw	r24, r22
{
    _pTimer = pTimer;
     b6c:	23 e4       	ldi	r18, 0x43	; 67
     b6e:	e2 2e       	mov	r14, r18
     b70:	f1 2c       	mov	r15, r1
     b72:	e0 0e       	add	r14, r16
     b74:	f1 1e       	adc	r15, r17
     b76:	f7 01       	movw	r30, r14
     b78:	60 83       	st	Z, r22
     b7a:	71 83       	std	Z+1, r23	; 0x01
    
    //! This will be 2us period
    _pTimer->ClkSel(TC_CLKSEL_DIV64_gc);
     b7c:	65 e0       	ldi	r22, 0x05	; 5
     b7e:	0e 94 b6 32 	call	0x656c	; 0x656c <_ZN9TimerCntr6ClkSelE14TC_CLKSEL_enum>
    SetTimerPeriod();
     b82:	c8 01       	movw	r24, r16
     b84:	0e 94 57 05 	call	0xaae	; 0xaae <_ZN3IMU14SetTimerPeriodEv>
    _pTimer->CCEnable(0);
     b88:	f7 01       	movw	r30, r14
     b8a:	80 81       	ld	r24, Z
     b8c:	91 81       	ldd	r25, Z+1	; 0x01
     b8e:	60 e0       	ldi	r22, 0x00	; 0
     b90:	0e 94 bc 32 	call	0x6578	; 0x6578 <_ZN9TimerCntr8CCEnableEh>
    _pTimer->WaveformGenMode(TC_WGMODE_NORMAL_gc);
     b94:	f7 01       	movw	r30, r14
     b96:	80 81       	ld	r24, Z
     b98:	91 81       	ldd	r25, Z+1	; 0x01
     b9a:	60 e0       	ldi	r22, 0x00	; 0
     b9c:	0e 94 c7 32 	call	0x658e	; 0x658e <_ZN9TimerCntr15WaveformGenModeE14TC_WGMODE_enum>
    _pTimer->EventSetup(TC_EVACT_OFF_gc,TC_EVSEL_OFF_gc);
     ba0:	f7 01       	movw	r30, r14
     ba2:	80 81       	ld	r24, Z
     ba4:	91 81       	ldd	r25, Z+1	; 0x01
     ba6:	60 e0       	ldi	r22, 0x00	; 0
     ba8:	40 e0       	ldi	r20, 0x00	; 0
     baa:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <_ZN9TimerCntr10EventSetupE13TC_EVACT_enum13TC_EVSEL_enum>
    _pTimer->IntLvlA(0,1);
     bae:	f7 01       	movw	r30, r14
     bb0:	80 81       	ld	r24, Z
     bb2:	91 81       	ldd	r25, Z+1	; 0x01
     bb4:	60 e0       	ldi	r22, 0x00	; 0
     bb6:	41 e0       	ldi	r20, 0x01	; 1
     bb8:	0e 94 d7 32 	call	0x65ae	; 0x65ae <_ZN9TimerCntr7IntLvlAEhh>
    _pTimer->IntLvlB(0);
     bbc:	f7 01       	movw	r30, r14
     bbe:	80 81       	ld	r24, Z
     bc0:	91 81       	ldd	r25, Z+1	; 0x01
     bc2:	60 e0       	ldi	r22, 0x00	; 0
     bc4:	0e 94 e6 32 	call	0x65cc	; 0x65cc <_ZN9TimerCntr7IntLvlBEh>
    _pTimer->Notify(this,0);
     bc8:	0c 5f       	subi	r16, 0xFC	; 252
     bca:	1f 4f       	sbci	r17, 0xFF	; 255
     bcc:	f7 01       	movw	r30, r14
     bce:	80 81       	ld	r24, Z
     bd0:	91 81       	ldd	r25, Z+1	; 0x01
     bd2:	b8 01       	movw	r22, r16
     bd4:	40 e0       	ldi	r20, 0x00	; 0
     bd6:	0e 94 5a 33 	call	0x66b4	; 0x66b4 <_ZN9TimerCntr6NotifyEP11TimerNotifyh>
}
     bda:	1f 91       	pop	r17
     bdc:	0f 91       	pop	r16
     bde:	ff 90       	pop	r15
     be0:	ef 90       	pop	r14
     be2:	08 95       	ret

00000be4 <_ZN3IMU8CheckIDsEP14HardwareSerial>:
    sei();
    return pData;
}

// Diagnostic Routines
void IMU::CheckIDs(HardwareSerial* pSerial)
     be4:	2f 92       	push	r2
     be6:	3f 92       	push	r3
     be8:	4f 92       	push	r4
     bea:	5f 92       	push	r5
     bec:	6f 92       	push	r6
     bee:	7f 92       	push	r7
     bf0:	8f 92       	push	r8
     bf2:	9f 92       	push	r9
     bf4:	af 92       	push	r10
     bf6:	bf 92       	push	r11
     bf8:	cf 92       	push	r12
     bfa:	df 92       	push	r13
     bfc:	ef 92       	push	r14
     bfe:	ff 92       	push	r15
     c00:	0f 93       	push	r16
     c02:	1f 93       	push	r17
     c04:	df 93       	push	r29
     c06:	cf 93       	push	r28
     c08:	cd b7       	in	r28, 0x3d	; 61
     c0a:	de b7       	in	r29, 0x3e	; 62
     c0c:	e2 97       	sbiw	r28, 0x32	; 50
     c0e:	cd bf       	out	0x3d, r28	; 61
     c10:	de bf       	out	0x3e, r29	; 62
     c12:	5c 01       	movw	r10, r24
     c14:	4b 01       	movw	r8, r22
    char buffer[50];
    for (int x=0;x<_numChans;x++) {
        int retc = _pMas->CheckID(_gID[x]); 
        if (retc == 0) {
            sprintf(buffer,"Gyro%d (0x%x):Ack.\n",x,_gID[x]);
            pSerial->print(buffer);
     c16:	8c 01       	movw	r16, r24
     c18:	ee 24       	eor	r14, r14
     c1a:	ff 24       	eor	r15, r15
     c1c:	6e 01       	movw	r12, r28
     c1e:	08 94       	sec
     c20:	c1 1c       	adc	r12, r1
     c22:	d1 1c       	adc	r13, r1
{
    char buffer[50];
    for (int x=0;x<_numChans;x++) {
        int retc = _pMas->CheckID(_gID[x]); 
        if (retc == 0) {
            sprintf(buffer,"Gyro%d (0x%x):Ack.\n",x,_gID[x]);
     c24:	5d e9       	ldi	r21, 0x9D	; 157
     c26:	25 2e       	mov	r2, r21
     c28:	50 e2       	ldi	r21, 0x20	; 32
     c2a:	35 2e       	mov	r3, r21
        retc = _pMas->CheckID(_aID[x]); 
        if (retc == 0) {
            sprintf(buffer,"Acc%d (0x%x):Ack.\n",x,_aID[x]);
            pSerial->print(buffer);
        } else {
            sprintf(buffer,"Acc%d (0x%x):NAck (%d).\n",x,_aID[x],retc);
     c2c:	4e ed       	ldi	r20, 0xDE	; 222
     c2e:	44 2e       	mov	r4, r20
     c30:	40 e2       	ldi	r20, 0x20	; 32
     c32:	54 2e       	mov	r5, r20
            pSerial->print(buffer);
        }
        Wr(_gID[x], 0x3D, 0x8);
        retc = _pMas->CheckID(_aID[x]); 
        if (retc == 0) {
            sprintf(buffer,"Acc%d (0x%x):Ack.\n",x,_aID[x]);
     c34:	3b ec       	ldi	r19, 0xCB	; 203
     c36:	63 2e       	mov	r6, r19
     c38:	30 e2       	ldi	r19, 0x20	; 32
     c3a:	73 2e       	mov	r7, r19
     c3c:	ae c0       	rjmp	.+348    	; 0xd9a <_ZN3IMU8CheckIDsEP14HardwareSerial+0x1b6>
// Diagnostic Routines
void IMU::CheckIDs(HardwareSerial* pSerial)
{
    char buffer[50];
    for (int x=0;x<_numChans;x++) {
        int retc = _pMas->CheckID(_gID[x]); 
     c3e:	d5 01       	movw	r26, r10
     c40:	19 96       	adiw	r26, 0x09	; 9
     c42:	8d 91       	ld	r24, X+
     c44:	9c 91       	ld	r25, X
     c46:	1a 97       	sbiw	r26, 0x0a	; 10
     c48:	f8 01       	movw	r30, r16
     c4a:	67 85       	ldd	r22, Z+15	; 0x0f
     c4c:	0e 94 9e 28 	call	0x513c	; 0x513c <_ZN10I2C_Master7CheckIDEh>
     c50:	28 2f       	mov	r18, r24
     c52:	33 27       	eor	r19, r19
     c54:	27 fd       	sbrc	r18, 7
     c56:	30 95       	com	r19
        if (retc == 0) {
     c58:	21 15       	cp	r18, r1
     c5a:	31 05       	cpc	r19, r1
     c5c:	e9 f4       	brne	.+58     	; 0xc98 <_ZN3IMU8CheckIDsEP14HardwareSerial+0xb4>
            sprintf(buffer,"Gyro%d (0x%x):Ack.\n",x,_gID[x]);
     c5e:	8d b7       	in	r24, 0x3d	; 61
     c60:	9e b7       	in	r25, 0x3e	; 62
     c62:	08 97       	sbiw	r24, 0x08	; 8
     c64:	8d bf       	out	0x3d, r24	; 61
     c66:	9e bf       	out	0x3e, r25	; 62
     c68:	ed b7       	in	r30, 0x3d	; 61
     c6a:	fe b7       	in	r31, 0x3e	; 62
     c6c:	31 96       	adiw	r30, 0x01	; 1
     c6e:	ad b7       	in	r26, 0x3d	; 61
     c70:	be b7       	in	r27, 0x3e	; 62
     c72:	11 96       	adiw	r26, 0x01	; 1
     c74:	cd 92       	st	X+, r12
     c76:	dc 92       	st	X, r13
     c78:	12 97       	sbiw	r26, 0x02	; 2
     c7a:	22 82       	std	Z+2, r2	; 0x02
     c7c:	33 82       	std	Z+3, r3	; 0x03
     c7e:	e4 82       	std	Z+4, r14	; 0x04
     c80:	f5 82       	std	Z+5, r15	; 0x05
     c82:	d8 01       	movw	r26, r16
     c84:	1f 96       	adiw	r26, 0x0f	; 15
     c86:	8c 91       	ld	r24, X
     c88:	86 83       	std	Z+6, r24	; 0x06
     c8a:	17 82       	std	Z+7, r1	; 0x07
     c8c:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
            pSerial->print(buffer);
     c90:	ed b7       	in	r30, 0x3d	; 61
     c92:	fe b7       	in	r31, 0x3e	; 62
     c94:	38 96       	adiw	r30, 0x08	; 8
     c96:	20 c0       	rjmp	.+64     	; 0xcd8 <_ZN3IMU8CheckIDsEP14HardwareSerial+0xf4>
        } else {
            sprintf(buffer,"Gyro%d (0x%x):NAck (%d).\n",x,_gID[x],retc);
     c98:	8d b7       	in	r24, 0x3d	; 61
     c9a:	9e b7       	in	r25, 0x3e	; 62
     c9c:	0a 97       	sbiw	r24, 0x0a	; 10
     c9e:	8d bf       	out	0x3d, r24	; 61
     ca0:	9e bf       	out	0x3e, r25	; 62
     ca2:	ed b7       	in	r30, 0x3d	; 61
     ca4:	fe b7       	in	r31, 0x3e	; 62
     ca6:	31 96       	adiw	r30, 0x01	; 1
     ca8:	ad b7       	in	r26, 0x3d	; 61
     caa:	be b7       	in	r27, 0x3e	; 62
     cac:	11 96       	adiw	r26, 0x01	; 1
     cae:	cd 92       	st	X+, r12
     cb0:	dc 92       	st	X, r13
     cb2:	12 97       	sbiw	r26, 0x02	; 2
     cb4:	81 eb       	ldi	r24, 0xB1	; 177
     cb6:	90 e2       	ldi	r25, 0x20	; 32
     cb8:	82 83       	std	Z+2, r24	; 0x02
     cba:	93 83       	std	Z+3, r25	; 0x03
     cbc:	e4 82       	std	Z+4, r14	; 0x04
     cbe:	f5 82       	std	Z+5, r15	; 0x05
     cc0:	d8 01       	movw	r26, r16
     cc2:	1f 96       	adiw	r26, 0x0f	; 15
     cc4:	8c 91       	ld	r24, X
     cc6:	86 83       	std	Z+6, r24	; 0x06
     cc8:	17 82       	std	Z+7, r1	; 0x07
     cca:	20 87       	std	Z+8, r18	; 0x08
     ccc:	31 87       	std	Z+9, r19	; 0x09
     cce:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
            pSerial->print(buffer);
     cd2:	ed b7       	in	r30, 0x3d	; 61
     cd4:	fe b7       	in	r31, 0x3e	; 62
     cd6:	3a 96       	adiw	r30, 0x0a	; 10
     cd8:	ed bf       	out	0x3d, r30	; 61
     cda:	fe bf       	out	0x3e, r31	; 62
     cdc:	c4 01       	movw	r24, r8
     cde:	b6 01       	movw	r22, r12
     ce0:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
        }
        Wr(_gID[x], 0x3D, 0x8);
     ce4:	c5 01       	movw	r24, r10
     ce6:	d8 01       	movw	r26, r16
     ce8:	1f 96       	adiw	r26, 0x0f	; 15
     cea:	6c 91       	ld	r22, X
     cec:	4d e3       	ldi	r20, 0x3D	; 61
     cee:	28 e0       	ldi	r18, 0x08	; 8
     cf0:	0e 94 a0 04 	call	0x940	; 0x940 <_ZN3IMU2WrEhhh>
        retc = _pMas->CheckID(_aID[x]); 
     cf4:	f5 01       	movw	r30, r10
     cf6:	81 85       	ldd	r24, Z+9	; 0x09
     cf8:	92 85       	ldd	r25, Z+10	; 0x0a
     cfa:	d8 01       	movw	r26, r16
     cfc:	51 96       	adiw	r26, 0x11	; 17
     cfe:	6c 91       	ld	r22, X
     d00:	0e 94 9e 28 	call	0x513c	; 0x513c <_ZN10I2C_Master7CheckIDEh>
     d04:	28 2f       	mov	r18, r24
     d06:	33 27       	eor	r19, r19
     d08:	27 fd       	sbrc	r18, 7
     d0a:	30 95       	com	r19
        if (retc == 0) {
     d0c:	21 15       	cp	r18, r1
     d0e:	31 05       	cpc	r19, r1
     d10:	d9 f4       	brne	.+54     	; 0xd48 <_ZN3IMU8CheckIDsEP14HardwareSerial+0x164>
            sprintf(buffer,"Acc%d (0x%x):Ack.\n",x,_aID[x]);
     d12:	ed b7       	in	r30, 0x3d	; 61
     d14:	fe b7       	in	r31, 0x3e	; 62
     d16:	38 97       	sbiw	r30, 0x08	; 8
     d18:	ed bf       	out	0x3d, r30	; 61
     d1a:	fe bf       	out	0x3e, r31	; 62
     d1c:	31 96       	adiw	r30, 0x01	; 1
     d1e:	ad b7       	in	r26, 0x3d	; 61
     d20:	be b7       	in	r27, 0x3e	; 62
     d22:	11 96       	adiw	r26, 0x01	; 1
     d24:	cd 92       	st	X+, r12
     d26:	dc 92       	st	X, r13
     d28:	12 97       	sbiw	r26, 0x02	; 2
     d2a:	62 82       	std	Z+2, r6	; 0x02
     d2c:	73 82       	std	Z+3, r7	; 0x03
     d2e:	e4 82       	std	Z+4, r14	; 0x04
     d30:	f5 82       	std	Z+5, r15	; 0x05
     d32:	d8 01       	movw	r26, r16
     d34:	51 96       	adiw	r26, 0x11	; 17
     d36:	8c 91       	ld	r24, X
     d38:	86 83       	std	Z+6, r24	; 0x06
     d3a:	17 82       	std	Z+7, r1	; 0x07
     d3c:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
            pSerial->print(buffer);
     d40:	ed b7       	in	r30, 0x3d	; 61
     d42:	fe b7       	in	r31, 0x3e	; 62
     d44:	38 96       	adiw	r30, 0x08	; 8
     d46:	1e c0       	rjmp	.+60     	; 0xd84 <_ZN3IMU8CheckIDsEP14HardwareSerial+0x1a0>
        } else {
            sprintf(buffer,"Acc%d (0x%x):NAck (%d).\n",x,_aID[x],retc);
     d48:	8d b7       	in	r24, 0x3d	; 61
     d4a:	9e b7       	in	r25, 0x3e	; 62
     d4c:	0a 97       	sbiw	r24, 0x0a	; 10
     d4e:	8d bf       	out	0x3d, r24	; 61
     d50:	9e bf       	out	0x3e, r25	; 62
     d52:	ed b7       	in	r30, 0x3d	; 61
     d54:	fe b7       	in	r31, 0x3e	; 62
     d56:	31 96       	adiw	r30, 0x01	; 1
     d58:	ad b7       	in	r26, 0x3d	; 61
     d5a:	be b7       	in	r27, 0x3e	; 62
     d5c:	11 96       	adiw	r26, 0x01	; 1
     d5e:	cd 92       	st	X+, r12
     d60:	dc 92       	st	X, r13
     d62:	12 97       	sbiw	r26, 0x02	; 2
     d64:	42 82       	std	Z+2, r4	; 0x02
     d66:	53 82       	std	Z+3, r5	; 0x03
     d68:	e4 82       	std	Z+4, r14	; 0x04
     d6a:	f5 82       	std	Z+5, r15	; 0x05
     d6c:	d8 01       	movw	r26, r16
     d6e:	51 96       	adiw	r26, 0x11	; 17
     d70:	8c 91       	ld	r24, X
     d72:	86 83       	std	Z+6, r24	; 0x06
     d74:	17 82       	std	Z+7, r1	; 0x07
     d76:	20 87       	std	Z+8, r18	; 0x08
     d78:	31 87       	std	Z+9, r19	; 0x09
     d7a:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
            pSerial->print(buffer);
     d7e:	ed b7       	in	r30, 0x3d	; 61
     d80:	fe b7       	in	r31, 0x3e	; 62
     d82:	3a 96       	adiw	r30, 0x0a	; 10
     d84:	ed bf       	out	0x3d, r30	; 61
     d86:	fe bf       	out	0x3e, r31	; 62
     d88:	c4 01       	movw	r24, r8
     d8a:	b6 01       	movw	r22, r12
     d8c:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>

// Diagnostic Routines
void IMU::CheckIDs(HardwareSerial* pSerial)
{
    char buffer[50];
    for (int x=0;x<_numChans;x++) {
     d90:	08 94       	sec
     d92:	e1 1c       	adc	r14, r1
     d94:	f1 1c       	adc	r15, r1
     d96:	0f 5f       	subi	r16, 0xFF	; 255
     d98:	1f 4f       	sbci	r17, 0xFF	; 255
     d9a:	d5 01       	movw	r26, r10
     d9c:	1c 96       	adiw	r26, 0x0c	; 12
     d9e:	8c 91       	ld	r24, X
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	e8 16       	cp	r14, r24
     da4:	f9 06       	cpc	r15, r25
     da6:	0c f4       	brge	.+2      	; 0xdaa <_ZN3IMU8CheckIDsEP14HardwareSerial+0x1c6>
     da8:	4a cf       	rjmp	.-364    	; 0xc3e <_ZN3IMU8CheckIDsEP14HardwareSerial+0x5a>
        } else {
            sprintf(buffer,"Acc%d (0x%x):NAck (%d).\n",x,_aID[x],retc);
            pSerial->print(buffer);
        }
    }
}
     daa:	e2 96       	adiw	r28, 0x32	; 50
     dac:	cd bf       	out	0x3d, r28	; 61
     dae:	de bf       	out	0x3e, r29	; 62
     db0:	cf 91       	pop	r28
     db2:	df 91       	pop	r29
     db4:	1f 91       	pop	r17
     db6:	0f 91       	pop	r16
     db8:	ff 90       	pop	r15
     dba:	ef 90       	pop	r14
     dbc:	df 90       	pop	r13
     dbe:	cf 90       	pop	r12
     dc0:	bf 90       	pop	r11
     dc2:	af 90       	pop	r10
     dc4:	9f 90       	pop	r9
     dc6:	8f 90       	pop	r8
     dc8:	7f 90       	pop	r7
     dca:	6f 90       	pop	r6
     dcc:	5f 90       	pop	r5
     dce:	4f 90       	pop	r4
     dd0:	3f 90       	pop	r3
     dd2:	2f 90       	pop	r2
     dd4:	08 95       	ret

00000dd6 <_ZN3IMU13QueryChannelsEv>:
        }
    }
    return 0;
}

void IMU::QueryChannels()
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	ec 01       	movw	r28, r24
{
    _numChans = 0;
     ddc:	1c 86       	std	Y+12, r1	; 0x0c
    _bDualChan = 0;
     dde:	1b 86       	std	Y+11, r1	; 0x0b
    // Check the first, lower ID.
    int retc = _pMas->CheckID(0xD2);
     de0:	89 85       	ldd	r24, Y+9	; 0x09
     de2:	9a 85       	ldd	r25, Y+10	; 0x0a
     de4:	62 ed       	ldi	r22, 0xD2	; 210
     de6:	0e 94 9e 28 	call	0x513c	; 0x513c <_ZN10I2C_Master7CheckIDEh>
    if (retc == 0) {
     dea:	88 23       	and	r24, r24
     dec:	51 f4       	brne	.+20     	; 0xe02 <_ZN3IMU13QueryChannelsEv+0x2c>
        _gID[_numChans] = 0xD2;
     dee:	9c 85       	ldd	r25, Y+12	; 0x0c
     df0:	fe 01       	movw	r30, r28
     df2:	e9 0f       	add	r30, r25
     df4:	f1 1d       	adc	r31, r1
     df6:	82 ed       	ldi	r24, 0xD2	; 210
     df8:	87 87       	std	Z+15, r24	; 0x0f
        _aID[_numChans] = 0x32; // Always high bit.
     dfa:	82 e3       	ldi	r24, 0x32	; 50
     dfc:	81 8b       	std	Z+17, r24	; 0x11
        _numChans++;
     dfe:	9f 5f       	subi	r25, 0xFF	; 255
     e00:	9c 87       	std	Y+12, r25	; 0x0c
    }
    retc = _pMas->CheckID(0xD0);
     e02:	89 85       	ldd	r24, Y+9	; 0x09
     e04:	9a 85       	ldd	r25, Y+10	; 0x0a
     e06:	60 ed       	ldi	r22, 0xD0	; 208
     e08:	0e 94 9e 28 	call	0x513c	; 0x513c <_ZN10I2C_Master7CheckIDEh>
    if (retc == 0) {
     e0c:	88 23       	and	r24, r24
     e0e:	51 f4       	brne	.+20     	; 0xe24 <_ZN3IMU13QueryChannelsEv+0x4e>
        _gID[_numChans] = 0xD0;
     e10:	9c 85       	ldd	r25, Y+12	; 0x0c
     e12:	fe 01       	movw	r30, r28
     e14:	e9 0f       	add	r30, r25
     e16:	f1 1d       	adc	r31, r1
     e18:	80 ed       	ldi	r24, 0xD0	; 208
     e1a:	87 87       	std	Z+15, r24	; 0x0f
        _aID[_numChans] = 0x30; // Always low bit.
     e1c:	80 e3       	ldi	r24, 0x30	; 48
     e1e:	81 8b       	std	Z+17, r24	; 0x11
        _numChans++;
     e20:	9f 5f       	subi	r25, 0xFF	; 255
     e22:	9c 87       	std	Y+12, r25	; 0x0c
    }
    
    if (_numChans > 1) {
     e24:	8c 85       	ldd	r24, Y+12	; 0x0c
     e26:	82 30       	cpi	r24, 0x02	; 2
     e28:	10 f0       	brcs	.+4      	; 0xe2e <_ZN3IMU13QueryChannelsEv+0x58>
        _bDualChan = true;
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	8b 87       	std	Y+11, r24	; 0x0b
    }
}
     e2e:	df 91       	pop	r29
     e30:	cf 91       	pop	r28
     e32:	08 95       	ret

00000e34 <_ZN3IMU13GetPacketDataEPh>:

//! Retrieve packet data from the stored packets.
//! If no packet data exists, this function will
//! fill the data pointer with null data - this way
//! any host software can continue, even if data is bad.    
uint8_t* IMU::GetPacketData(uint8_t* pData)
     e34:	0f 93       	push	r16
     e36:	1f 93       	push	r17
     e38:	cf 93       	push	r28
     e3a:	df 93       	push	r29
     e3c:	ec 01       	movw	r28, r24
     e3e:	db 01       	movw	r26, r22
{
    if (_numChans == 0) return pData;
     e40:	8c 85       	ldd	r24, Y+12	; 0x0c
     e42:	88 23       	and	r24, r24
     e44:	09 f4       	brne	.+2      	; 0xe48 <_ZN3IMU13GetPacketDataEPh+0x14>
     e46:	75 c0       	rjmp	.+234    	; 0xf32 <_ZN3IMU13GetPacketDataEPh+0xfe>

    cli();
     e48:	f8 94       	cli

    *pData++ = 0xa5;
     e4a:	fb 01       	movw	r30, r22
     e4c:	85 ea       	ldi	r24, 0xA5	; 165
     e4e:	81 93       	st	Z+, r24
    *pData++ = 0x5a;
     e50:	8a e5       	ldi	r24, 0x5A	; 90
     e52:	11 96       	adiw	r26, 0x01	; 1
     e54:	8c 93       	st	X, r24
     e56:	11 97       	sbiw	r26, 0x01	; 1
     e58:	8f 01       	movw	r16, r30
     e5a:	0f 5f       	subi	r16, 0xFF	; 255
     e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    if (_State == sIdle) {
     e5e:	8e 81       	ldd	r24, Y+6	; 0x06
     e60:	88 23       	and	r24, r24
     e62:	79 f4       	brne	.+30     	; 0xe82 <_ZN3IMU13GetPacketDataEPh+0x4e>
        if (_failType == fNack) {
     e64:	88 85       	ldd	r24, Y+8	; 0x08
     e66:	81 30       	cpi	r24, 0x01	; 1
     e68:	21 f4       	brne	.+8      	; 0xe72 <_ZN3IMU13GetPacketDataEPh+0x3e>
            memset(pData,'N',IMUPacket::PacketLen);
     e6a:	c8 01       	movw	r24, r16
     e6c:	6e e4       	ldi	r22, 0x4E	; 78
     e6e:	70 e0       	ldi	r23, 0x00	; 0
     e70:	03 c0       	rjmp	.+6      	; 0xe78 <_ZN3IMU13GetPacketDataEPh+0x44>
        } else {
            memset(pData,'I',IMUPacket::PacketLen);
     e72:	c8 01       	movw	r24, r16
     e74:	69 e4       	ldi	r22, 0x49	; 73
     e76:	70 e0       	ldi	r23, 0x00	; 0
     e78:	40 e1       	ldi	r20, 0x10	; 16
     e7a:	50 e0       	ldi	r21, 0x00	; 0
     e7c:	0e 94 40 4b 	call	0x9680	; 0x9680 <memset>
     e80:	14 c0       	rjmp	.+40     	; 0xeaa <_ZN3IMU13GetPacketDataEPh+0x76>
        }
        pData += IMUPacket::PacketLen;
    } else if (_bDataReady[0] == true) {
     e82:	cf 5b       	subi	r28, 0xBF	; 191
     e84:	df 4f       	sbci	r29, 0xFF	; 255
     e86:	88 81       	ld	r24, Y
     e88:	c1 54       	subi	r28, 0x41	; 65
     e8a:	d0 40       	sbci	r29, 0x00	; 0
     e8c:	88 23       	and	r24, r24
     e8e:	81 f0       	breq	.+32     	; 0xeb0 <_ZN3IMU13GetPacketDataEPh+0x7c>
        memcpy(pData,&_dataBuffer[0][0],IMUPacket::PacketLen);
     e90:	d8 01       	movw	r26, r16
     e92:	fe 01       	movw	r30, r28
     e94:	79 96       	adiw	r30, 0x19	; 25
     e96:	80 e1       	ldi	r24, 0x10	; 16
     e98:	01 90       	ld	r0, Z+
     e9a:	0d 92       	st	X+, r0
     e9c:	81 50       	subi	r24, 0x01	; 1
     e9e:	e1 f7       	brne	.-8      	; 0xe98 <_ZN3IMU13GetPacketDataEPh+0x64>
        _bDataReady[0] = false;
     ea0:	cf 5b       	subi	r28, 0xBF	; 191
     ea2:	df 4f       	sbci	r29, 0xFF	; 255
     ea4:	18 82       	st	Y, r1
     ea6:	c1 54       	subi	r28, 0x41	; 65
     ea8:	d0 40       	sbci	r29, 0x00	; 0
        pData += IMUPacket::PacketLen;
     eaa:	d8 01       	movw	r26, r16
     eac:	50 96       	adiw	r26, 0x10	; 16
     eae:	06 c0       	rjmp	.+12     	; 0xebc <_ZN3IMU13GetPacketDataEPh+0x88>
    } else {
        memset(pData,0,IMUPacket::PacketLen);
     eb0:	80 e1       	ldi	r24, 0x10	; 16
     eb2:	f8 01       	movw	r30, r16
     eb4:	11 92       	st	Z+, r1
     eb6:	8a 95       	dec	r24
     eb8:	e9 f7       	brne	.-6      	; 0xeb4 <_ZN3IMU13GetPacketDataEPh+0x80>
        pData += IMUPacket::PacketLen;
     eba:	52 96       	adiw	r26, 0x12	; 18
    }

    if (_bDualChan) {
     ebc:	8b 85       	ldd	r24, Y+11	; 0x0b
     ebe:	88 23       	and	r24, r24
     ec0:	b9 f1       	breq	.+110    	; 0xf30 <_ZN3IMU13GetPacketDataEPh+0xfc>
        *pData++ = 0xa5;
     ec2:	fd 01       	movw	r30, r26
     ec4:	85 ea       	ldi	r24, 0xA5	; 165
     ec6:	81 93       	st	Z+, r24
        *pData++ = 0x5a;
     ec8:	8a e5       	ldi	r24, 0x5A	; 90
     eca:	11 96       	adiw	r26, 0x01	; 1
     ecc:	8c 93       	st	X, r24
     ece:	11 97       	sbiw	r26, 0x01	; 1
     ed0:	8f 01       	movw	r16, r30
     ed2:	0f 5f       	subi	r16, 0xFF	; 255
     ed4:	1f 4f       	sbci	r17, 0xFF	; 255
        if (_State == sIdle) {
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	88 23       	and	r24, r24
     eda:	79 f4       	brne	.+30     	; 0xefa <_ZN3IMU13GetPacketDataEPh+0xc6>
            if (_failType == fNack) {
     edc:	88 85       	ldd	r24, Y+8	; 0x08
     ede:	81 30       	cpi	r24, 0x01	; 1
     ee0:	21 f4       	brne	.+8      	; 0xeea <_ZN3IMU13GetPacketDataEPh+0xb6>
                memset(pData,'N',IMUPacket::PacketLen);
     ee2:	c8 01       	movw	r24, r16
     ee4:	6e e4       	ldi	r22, 0x4E	; 78
     ee6:	70 e0       	ldi	r23, 0x00	; 0
     ee8:	03 c0       	rjmp	.+6      	; 0xef0 <_ZN3IMU13GetPacketDataEPh+0xbc>
            } else {
                memset(pData,'I',IMUPacket::PacketLen);
     eea:	c8 01       	movw	r24, r16
     eec:	69 e4       	ldi	r22, 0x49	; 73
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	40 e1       	ldi	r20, 0x10	; 16
     ef2:	50 e0       	ldi	r21, 0x00	; 0
     ef4:	0e 94 40 4b 	call	0x9680	; 0x9680 <memset>
     ef8:	12 c0       	rjmp	.+36     	; 0xf1e <_ZN3IMU13GetPacketDataEPh+0xea>
            }
            pData += IMUPacket::PacketLen;
        } else if (_bDataReady[1] == true) {
     efa:	ce 5b       	subi	r28, 0xBE	; 190
     efc:	df 4f       	sbci	r29, 0xFF	; 255
     efe:	88 81       	ld	r24, Y
     f00:	c2 54       	subi	r28, 0x42	; 66
     f02:	d0 40       	sbci	r29, 0x00	; 0
     f04:	88 23       	and	r24, r24
     f06:	71 f0       	breq	.+28     	; 0xf24 <_ZN3IMU13GetPacketDataEPh+0xf0>
            memcpy(pData,&_dataBuffer[1][0],IMUPacket::PacketLen);
     f08:	d8 01       	movw	r26, r16
     f0a:	fe 01       	movw	r30, r28
     f0c:	bd 96       	adiw	r30, 0x2d	; 45
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	01 90       	ld	r0, Z+
     f12:	0d 92       	st	X+, r0
     f14:	81 50       	subi	r24, 0x01	; 1
     f16:	e1 f7       	brne	.-8      	; 0xf10 <_ZN3IMU13GetPacketDataEPh+0xdc>
            _bDataReady[1] = false;
     f18:	ce 5b       	subi	r28, 0xBE	; 190
     f1a:	df 4f       	sbci	r29, 0xFF	; 255
     f1c:	18 82       	st	Y, r1
            pData += IMUPacket::PacketLen;
     f1e:	d8 01       	movw	r26, r16
     f20:	50 96       	adiw	r26, 0x10	; 16
     f22:	06 c0       	rjmp	.+12     	; 0xf30 <_ZN3IMU13GetPacketDataEPh+0xfc>
        } else {
            memset(pData,0,IMUPacket::PacketLen);
     f24:	80 e1       	ldi	r24, 0x10	; 16
     f26:	f8 01       	movw	r30, r16
     f28:	11 92       	st	Z+, r1
     f2a:	8a 95       	dec	r24
     f2c:	e9 f7       	brne	.-6      	; 0xf28 <_ZN3IMU13GetPacketDataEPh+0xf4>
            pData += IMUPacket::PacketLen;
     f2e:	52 96       	adiw	r26, 0x12	; 18
        }
    }
    sei();
     f30:	78 94       	sei
    return pData;
}
     f32:	cd 01       	movw	r24, r26
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	1f 91       	pop	r17
     f3a:	0f 91       	pop	r16
     f3c:	08 95       	ret

00000f3e <_ZN4MarkC1EP9DebugPorth>:

class Mark
{
    DebugPort* _pDbgPort;
public:
    Mark(DebugPort* dbgpport, uint8_t p) 
     f3e:	1f 93       	push	r17
     f40:	cf 93       	push	r28
     f42:	df 93       	push	r29
     f44:	ec 01       	movw	r28, r24
     f46:	14 2f       	mov	r17, r20
    {
        _pDbgPort = dbgpport;
     f48:	68 83       	st	Y, r22
     f4a:	79 83       	std	Y+1, r23	; 0x01
        if (_pDbgPort) {
     f4c:	61 15       	cp	r22, r1
     f4e:	71 05       	cpc	r23, r1
     f50:	61 f0       	breq	.+24     	; 0xf6a <_ZN4MarkC1EP9DebugPorth+0x2c>
            _pDbgPort->SetState((uint8_t) 1);
     f52:	cb 01       	movw	r24, r22
     f54:	61 e0       	ldi	r22, 0x01	; 1
     f56:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
	__asm__ volatile (
		"1: dec %0" "\n\t"
		"brne 1b"
		: "=r" (__count)
		: "0" (__count)
	);
     f5a:	80 e2       	ldi	r24, 0x20	; 32
     f5c:	8a 95       	dec	r24
     f5e:	f1 f7       	brne	.-4      	; 0xf5c <_ZN4MarkC1EP9DebugPorth+0x1e>
            _delay_us(3);
            _pDbgPort->SetState((uint8_t) p);
     f60:	88 81       	ld	r24, Y
     f62:	99 81       	ldd	r25, Y+1	; 0x01
     f64:	61 2f       	mov	r22, r17
     f66:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
        }
    }
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	1f 91       	pop	r17
     f70:	08 95       	ret

00000f72 <_ZN3IMU8SetStateENS_9StateTypeE>:
    void ReadWord(uint16_t *pData);
    void StoreGyroData(uint8_t idx);
    void StoreAccData(uint8_t idx);
    void PushData(uint8_t idx);
    
    inline void SetState(StateType s)
     f72:	fc 01       	movw	r30, r24
    {
        _previousState = _State;
     f74:	86 81       	ldd	r24, Z+6	; 0x06
     f76:	87 83       	std	Z+7, r24	; 0x07
        _State = s;
     f78:	66 83       	std	Z+6, r22	; 0x06
        if (_pDBGPort) _pDBGPort->SetState((uint8_t)_State);
     f7a:	e4 5b       	subi	r30, 0xB4	; 180
     f7c:	ff 4f       	sbci	r31, 0xFF	; 255
     f7e:	80 81       	ld	r24, Z
     f80:	91 81       	ldd	r25, Z+1	; 0x01
     f82:	00 97       	sbiw	r24, 0x00	; 0
     f84:	11 f0       	breq	.+4      	; 0xf8a <_ZN3IMU8SetStateENS_9StateTypeE+0x18>
     f86:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
     f8a:	08 95       	ret

00000f8c <_ZN3IMU18ProcessTransactionEv>:
    return retc;
}

//! Called when an Asynchronous I2C operation succeeds.
//! Switch on the state and perform the next appropriate action.
void IMU::ProcessTransaction()
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	ec 01       	movw	r28, r24
{
    switch(_State) {
     f92:	8e 81       	ldd	r24, Y+6	; 0x06
     f94:	89 30       	cpi	r24, 0x09	; 9
     f96:	99 f0       	breq	.+38     	; 0xfbe <_ZN3IMU18ProcessTransactionEv+0x32>
     f98:	8a 30       	cpi	r24, 0x0A	; 10
     f9a:	20 f4       	brcc	.+8      	; 0xfa4 <_ZN3IMU18ProcessTransactionEv+0x18>
     f9c:	88 30       	cpi	r24, 0x08	; 8
     f9e:	09 f0       	breq	.+2      	; 0xfa2 <_ZN3IMU18ProcessTransactionEv+0x16>
     fa0:	48 c0       	rjmp	.+144    	; 0x1032 <_ZN3IMU18ProcessTransactionEv+0xa6>
     fa2:	06 c0       	rjmp	.+12     	; 0xfb0 <_ZN3IMU18ProcessTransactionEv+0x24>
     fa4:	8a 30       	cpi	r24, 0x0A	; 10
     fa6:	f1 f0       	breq	.+60     	; 0xfe4 <_ZN3IMU18ProcessTransactionEv+0x58>
     fa8:	8b 30       	cpi	r24, 0x0B	; 11
     faa:	09 f0       	breq	.+2      	; 0xfae <_ZN3IMU18ProcessTransactionEv+0x22>
     fac:	42 c0       	rjmp	.+132    	; 0x1032 <_ZN3IMU18ProcessTransactionEv+0xa6>
     fae:	23 c0       	rjmp	.+70     	; 0xff6 <_ZN3IMU18ProcessTransactionEv+0x6a>
        case sReadGyro1:
            StoreGyroData(1);
     fb0:	ce 01       	movw	r24, r28
     fb2:	61 e0       	ldi	r22, 0x01	; 1
     fb4:	0e 94 c7 03 	call	0x78e	; 0x78e <_ZN3IMU13StoreGyroDataEh>
            SetState(sReadAcc1);
     fb8:	ce 01       	movw	r24, r28
     fba:	69 e0       	ldi	r22, 0x09	; 9
     fbc:	19 c0       	rjmp	.+50     	; 0xff0 <_ZN3IMU18ProcessTransactionEv+0x64>
            break;
        case sReadAcc1:
            StoreAccData(1);
     fbe:	ce 01       	movw	r24, r28
     fc0:	61 e0       	ldi	r22, 0x01	; 1
     fc2:	0e 94 af 03 	call	0x75e	; 0x75e <_ZN3IMU12StoreAccDataEh>
}

//! Push the data in the temporary buffer onto the appropriate fifo
void IMU::PushData(uint8_t idx)
{
    _bDataReady[idx-1] = true;
     fc6:	cf 5b       	subi	r28, 0xBF	; 191
     fc8:	df 4f       	sbci	r29, 0xFF	; 255
     fca:	81 e0       	ldi	r24, 0x01	; 1
     fcc:	88 83       	st	Y, r24
     fce:	c1 54       	subi	r28, 0x41	; 65
     fd0:	d0 40       	sbci	r29, 0x00	; 0
            SetState(sReadAcc1);
            break;
        case sReadAcc1:
            StoreAccData(1);
            PushData(1);
            if (_bDualChan) {
     fd2:	8b 85       	ldd	r24, Y+11	; 0x0b
     fd4:	88 23       	and	r24, r24
     fd6:	c9 f0       	breq	.+50     	; 0x100a <_ZN3IMU18ProcessTransactionEv+0x7e>
                if (_bUseGyro) {
     fd8:	88 8d       	ldd	r24, Y+24	; 0x18
     fda:	88 23       	and	r24, r24
     fdc:	39 f0       	breq	.+14     	; 0xfec <_ZN3IMU18ProcessTransactionEv+0x60>
                    SetState(sReadGyro2);
     fde:	ce 01       	movw	r24, r28
     fe0:	6a e0       	ldi	r22, 0x0A	; 10
     fe2:	06 c0       	rjmp	.+12     	; 0xff0 <_ZN3IMU18ProcessTransactionEv+0x64>
                    _pNextIMU->BeginRead();
                }
            }
            break;
        case sReadGyro2:
            StoreGyroData(2);
     fe4:	ce 01       	movw	r24, r28
     fe6:	62 e0       	ldi	r22, 0x02	; 2
     fe8:	0e 94 c7 03 	call	0x78e	; 0x78e <_ZN3IMU13StoreGyroDataEh>
            SetState(sReadAcc2);
     fec:	ce 01       	movw	r24, r28
     fee:	6b e0       	ldi	r22, 0x0B	; 11
     ff0:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
     ff4:	1e c0       	rjmp	.+60     	; 0x1032 <_ZN3IMU18ProcessTransactionEv+0xa6>
            break;
        case sReadAcc2:
            StoreAccData(2);
     ff6:	ce 01       	movw	r24, r28
     ff8:	62 e0       	ldi	r22, 0x02	; 2
     ffa:	0e 94 af 03 	call	0x75e	; 0x75e <_ZN3IMU12StoreAccDataEh>
}

//! Push the data in the temporary buffer onto the appropriate fifo
void IMU::PushData(uint8_t idx)
{
    _bDataReady[idx-1] = true;
     ffe:	ce 5b       	subi	r28, 0xBE	; 190
    1000:	df 4f       	sbci	r29, 0xFF	; 255
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	88 83       	st	Y, r24
    1006:	c2 54       	subi	r28, 0x42	; 66
    1008:	d0 40       	sbci	r29, 0x00	; 0
            SetState(sReadAcc2);
            break;
        case sReadAcc2:
            StoreAccData(2);
            PushData(2);
            SetState(sWait);
    100a:	ce 01       	movw	r24, r28
    100c:	65 e0       	ldi	r22, 0x05	; 5
    100e:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
            if (_pNextIMU) {
    1012:	c0 5b       	subi	r28, 0xB0	; 176
    1014:	df 4f       	sbci	r29, 0xFF	; 255
    1016:	a8 81       	ld	r26, Y
    1018:	b9 81       	ldd	r27, Y+1	; 0x01
    101a:	c0 55       	subi	r28, 0x50	; 80
    101c:	d0 40       	sbci	r29, 0x00	; 0
    101e:	10 97       	sbiw	r26, 0x00	; 0
    1020:	41 f0       	breq	.+16     	; 0x1032 <_ZN3IMU18ProcessTransactionEv+0xa6>
                _pNextIMU->BeginRead();
    1022:	ed 91       	ld	r30, X+
    1024:	fc 91       	ld	r31, X
    1026:	11 97       	sbiw	r26, 0x01	; 1
    1028:	04 88       	ldd	r0, Z+20	; 0x14
    102a:	f5 89       	ldd	r31, Z+21	; 0x15
    102c:	e0 2d       	mov	r30, r0
    102e:	cd 01       	movw	r24, r26
    1030:	19 95       	eicall
        default:
            break;
    }
    
    //! Start the next transaction.
    StartTransaction();
    1032:	ce 01       	movw	r24, r28
    1034:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <_ZN3IMU16StartTransactionEv>
}
    1038:	df 91       	pop	r29
    103a:	cf 91       	pop	r28
    103c:	08 95       	ret

0000103e <_ZN3IMU4StopEv>:

//! Force the state to Idle.
//! We need to consider how this works with iterrupts, but this
//! should only be called from main, below interrupt level, so I 
//! think it is okay.
int IMU::Stop()
    103e:	fc 01       	movw	r30, r24
{
    cli();
    1040:	f8 94       	cli
    _bRun = false;
    1042:	eb 5b       	subi	r30, 0xBB	; 187
    1044:	ff 4f       	sbci	r31, 0xFF	; 255
    1046:	10 82       	st	Z, r1
    1048:	e5 54       	subi	r30, 0x45	; 69
    104a:	f0 40       	sbci	r31, 0x00	; 0
    SetState(sIdle);
    104c:	cf 01       	movw	r24, r30
    104e:	60 e0       	ldi	r22, 0x00	; 0
    1050:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    sei();
    1054:	78 94       	sei
    return 0;
}
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	08 95       	ret

0000105c <_ZN4MarkD1Ev>:
    
    ~Mark() {
    105c:	fc 01       	movw	r30, r24
        _pDbgPort->SetState((uint8_t) 0);
    105e:	80 81       	ld	r24, Z
    1060:	91 81       	ldd	r25, Z+1	; 0x01
    1062:	60 e0       	ldi	r22, 0x00	; 0
    1064:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
    }
    1068:	08 95       	ret

0000106a <_ZThn2_N3IMU11I2CReadDoneEv>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
    106a:	02 97       	sbiw	r24, 0x02	; 2
    106c:	0e 94 39 08 	call	0x1072	; 0x1072 <_ZN3IMU11I2CReadDoneEv>
    1070:	08 95       	ret

00001072 <_ZN3IMU11I2CReadDoneEv>:
}
  
//! Called be the master when the read is complete.
//! Requires registration
//! Expected Context: Med Lvl I2C Int.
void IMU::I2CReadDone()
    1072:	ef 92       	push	r14
    1074:	ff 92       	push	r15
    1076:	0f 93       	push	r16
    1078:	1f 93       	push	r17
    107a:	df 93       	push	r29
    107c:	cf 93       	push	r28
    107e:	0f 92       	push	r0
    1080:	0f 92       	push	r0
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
    1086:	7c 01       	movw	r14, r24
{
    if (_bRun == false) return;
    1088:	25 e4       	ldi	r18, 0x45	; 69
    108a:	30 e0       	ldi	r19, 0x00	; 0
    108c:	e2 0e       	add	r14, r18
    108e:	f3 1e       	adc	r15, r19
    1090:	f7 01       	movw	r30, r14
    1092:	80 81       	ld	r24, Z
    1094:	2b eb       	ldi	r18, 0xBB	; 187
    1096:	3f ef       	ldi	r19, 0xFF	; 255
    1098:	e2 0e       	add	r14, r18
    109a:	f3 1e       	adc	r15, r19
    109c:	88 23       	and	r24, r24
    109e:	41 f1       	breq	.+80     	; 0x10f0 <_ZN3IMU11I2CReadDoneEv+0x7e>

    Mark marker(_pDBGPort2,pReadDn);
    10a0:	8e e4       	ldi	r24, 0x4E	; 78
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	e8 0e       	add	r14, r24
    10a6:	f9 1e       	adc	r15, r25
    10a8:	f7 01       	movw	r30, r14
    10aa:	60 81       	ld	r22, Z
    10ac:	71 81       	ldd	r23, Z+1	; 0x01
    10ae:	8e 01       	movw	r16, r28
    10b0:	0f 5f       	subi	r16, 0xFF	; 255
    10b2:	1f 4f       	sbci	r17, 0xFF	; 255
    10b4:	c8 01       	movw	r24, r16
    10b6:	43 e0       	ldi	r20, 0x03	; 3
    10b8:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
        if (_pDBGPort2) _pDBGPort2->SetState((uint8_t) p);
    }
    
    inline void ResetBusyTime()
    {
        _busyWaitTime = millis();
    10bc:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    10c0:	2c ef       	ldi	r18, 0xFC	; 252
    10c2:	3f ef       	ldi	r19, 0xFF	; 255
    10c4:	e2 0e       	add	r14, r18
    10c6:	f3 1e       	adc	r15, r19
    10c8:	f7 01       	movw	r30, r14
    10ca:	60 83       	st	Z, r22
    10cc:	71 83       	std	Z+1, r23	; 0x01
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    10ce:	12 92       	st	-Z, r1
        _nackCount          = 0;
    10d0:	12 92       	st	-Z, r1
        _failCount          = 0;
    10d2:	12 92       	st	-Z, r1
    10d4:	12 92       	st	-Z, r1
    10d6:	7f 01       	movw	r14, r30
    10d8:	2a eb       	ldi	r18, 0xBA	; 186
    10da:	3f ef       	ldi	r19, 0xFF	; 255
    10dc:	e2 0e       	add	r14, r18
    10de:	f3 1e       	adc	r15, r19
        _failType           = fNone;
    10e0:	f7 01       	movw	r30, r14
    10e2:	10 86       	std	Z+8, r1	; 0x08
    ResetBusyTime();
    
    ResetFailStats();
    ProcessTransaction();
    10e4:	c7 01       	movw	r24, r14
    10e6:	0e 94 c6 07 	call	0xf8c	; 0xf8c <_ZN3IMU18ProcessTransactionEv>
    10ea:	c8 01       	movw	r24, r16
    10ec:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    10f0:	0f 90       	pop	r0
    10f2:	0f 90       	pop	r0
    10f4:	cf 91       	pop	r28
    10f6:	df 91       	pop	r29
    10f8:	1f 91       	pop	r17
    10fa:	0f 91       	pop	r16
    10fc:	ff 90       	pop	r15
    10fe:	ef 90       	pop	r14
    1100:	08 95       	ret

00001102 <_ZThn2_N3IMU12I2CWriteDoneEv>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
    1102:	02 97       	sbiw	r24, 0x02	; 2
    1104:	0e 94 85 08 	call	0x110a	; 0x110a <_ZN3IMU12I2CWriteDoneEv>
    1108:	08 95       	ret

0000110a <_ZN3IMU12I2CWriteDoneEv>:
}

//! Called by the Master when the write is complete.
//! Requires registration
//! Expected Context: Med Lvl I2C Int.
void IMU::I2CWriteDone()
    110a:	ef 92       	push	r14
    110c:	ff 92       	push	r15
    110e:	0f 93       	push	r16
    1110:	1f 93       	push	r17
    1112:	df 93       	push	r29
    1114:	cf 93       	push	r28
    1116:	0f 92       	push	r0
    1118:	0f 92       	push	r0
    111a:	cd b7       	in	r28, 0x3d	; 61
    111c:	de b7       	in	r29, 0x3e	; 62
    111e:	7c 01       	movw	r14, r24
{
    if (_bRun == false) return;
    1120:	25 e4       	ldi	r18, 0x45	; 69
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	e2 0e       	add	r14, r18
    1126:	f3 1e       	adc	r15, r19
    1128:	f7 01       	movw	r30, r14
    112a:	80 81       	ld	r24, Z
    112c:	2b eb       	ldi	r18, 0xBB	; 187
    112e:	3f ef       	ldi	r19, 0xFF	; 255
    1130:	e2 0e       	add	r14, r18
    1132:	f3 1e       	adc	r15, r19
    1134:	88 23       	and	r24, r24
    1136:	41 f1       	breq	.+80     	; 0x1188 <_ZN3IMU12I2CWriteDoneEv+0x7e>

    Mark marker(_pDBGPort2,pWriteDn);
    1138:	8e e4       	ldi	r24, 0x4E	; 78
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	e8 0e       	add	r14, r24
    113e:	f9 1e       	adc	r15, r25
    1140:	f7 01       	movw	r30, r14
    1142:	60 81       	ld	r22, Z
    1144:	71 81       	ldd	r23, Z+1	; 0x01
    1146:	8e 01       	movw	r16, r28
    1148:	0f 5f       	subi	r16, 0xFF	; 255
    114a:	1f 4f       	sbci	r17, 0xFF	; 255
    114c:	c8 01       	movw	r24, r16
    114e:	42 e0       	ldi	r20, 0x02	; 2
    1150:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
        if (_pDBGPort2) _pDBGPort2->SetState((uint8_t) p);
    }
    
    inline void ResetBusyTime()
    {
        _busyWaitTime = millis();
    1154:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    1158:	2c ef       	ldi	r18, 0xFC	; 252
    115a:	3f ef       	ldi	r19, 0xFF	; 255
    115c:	e2 0e       	add	r14, r18
    115e:	f3 1e       	adc	r15, r19
    1160:	f7 01       	movw	r30, r14
    1162:	60 83       	st	Z, r22
    1164:	71 83       	std	Z+1, r23	; 0x01
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1166:	12 92       	st	-Z, r1
        _nackCount          = 0;
    1168:	12 92       	st	-Z, r1
        _failCount          = 0;
    116a:	12 92       	st	-Z, r1
    116c:	12 92       	st	-Z, r1
    116e:	7f 01       	movw	r14, r30
    1170:	2a eb       	ldi	r18, 0xBA	; 186
    1172:	3f ef       	ldi	r19, 0xFF	; 255
    1174:	e2 0e       	add	r14, r18
    1176:	f3 1e       	adc	r15, r19
        _failType           = fNone;
    1178:	f7 01       	movw	r30, r14
    117a:	10 86       	std	Z+8, r1	; 0x08
    ResetBusyTime();

    ResetFailStats();
    ProcessTransaction();
    117c:	c7 01       	movw	r24, r14
    117e:	0e 94 c6 07 	call	0xf8c	; 0xf8c <_ZN3IMU18ProcessTransactionEv>
    1182:	c8 01       	movw	r24, r16
    1184:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    1188:	0f 90       	pop	r0
    118a:	0f 90       	pop	r0
    118c:	cf 91       	pop	r28
    118e:	df 91       	pop	r29
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
    1198:	08 95       	ret

0000119a <_ZN3IMU5StartEv>:
//! Setup the run variables and then set our state to reset the
//! fifo lengths then get going.
//! Generally the master will call all of the Setup functions first
//! so the asynchronous Writes there won't be an issue.
//! Expected Context: Main
int IMU::Start()
    119a:	ef 92       	push	r14
    119c:	ff 92       	push	r15
    119e:	0f 93       	push	r16
    11a0:	1f 93       	push	r17
    11a2:	df 93       	push	r29
    11a4:	cf 93       	push	r28
    11a6:	0f 92       	push	r0
    11a8:	0f 92       	push	r0
    11aa:	cd b7       	in	r28, 0x3d	; 61
    11ac:	de b7       	in	r29, 0x3e	; 62
    11ae:	8c 01       	movw	r16, r24
{
    if (_numChans == 0) return 0;
    11b0:	dc 01       	movw	r26, r24
    11b2:	1c 96       	adiw	r26, 0x0c	; 12
    11b4:	8c 91       	ld	r24, X
    11b6:	88 23       	and	r24, r24
    11b8:	19 f4       	brne	.+6      	; 0x11c0 <_ZN3IMU5StartEv+0x26>
    11ba:	ee 24       	eor	r14, r14
    11bc:	ff 24       	eor	r15, r15
    11be:	4a c0       	rjmp	.+148    	; 0x1254 <_ZN3IMU5StartEv+0xba>
    
    Mark marker(_pDBGPort2,pWriteDn);
    11c0:	02 5b       	subi	r16, 0xB2	; 178
    11c2:	1f 4f       	sbci	r17, 0xFF	; 255
    11c4:	f8 01       	movw	r30, r16
    11c6:	60 81       	ld	r22, Z
    11c8:	71 81       	ldd	r23, Z+1	; 0x01
    11ca:	0e 54       	subi	r16, 0x4E	; 78
    11cc:	10 40       	sbci	r17, 0x00	; 0
    11ce:	ce 01       	movw	r24, r28
    11d0:	01 96       	adiw	r24, 0x01	; 1
    11d2:	42 e0       	ldi	r20, 0x02	; 2
    11d4:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    
    int retc;
    if (_State != sConfigured) {
    11d8:	d8 01       	movw	r26, r16
    11da:	16 96       	adiw	r26, 0x06	; 6
    11dc:	8c 91       	ld	r24, X
    11de:	16 97       	sbiw	r26, 0x06	; 6
    11e0:	82 30       	cpi	r24, 0x02	; 2
    11e2:	51 f0       	breq	.+20     	; 0x11f8 <_ZN3IMU5StartEv+0x5e>
        retc = Setup();
    11e4:	ed 91       	ld	r30, X+
    11e6:	fc 91       	ld	r31, X
    11e8:	04 80       	ldd	r0, Z+4	; 0x04
    11ea:	f5 81       	ldd	r31, Z+5	; 0x05
    11ec:	e0 2d       	mov	r30, r0
    11ee:	c8 01       	movw	r24, r16
    11f0:	19 95       	eicall
    11f2:	7c 01       	movw	r14, r24
        if (retc < 0) {
    11f4:	97 fd       	sbrc	r25, 7
    11f6:	2a c0       	rjmp	.+84     	; 0x124c <_ZN3IMU5StartEv+0xb2>
            return retc;
        }
    }
    
    cli();
    11f8:	f8 94       	cli
    ResetTimer();
    11fa:	d8 01       	movw	r26, r16
    11fc:	ed 91       	ld	r30, X+
    11fe:	fc 91       	ld	r31, X
    1200:	06 84       	ldd	r0, Z+14	; 0x0e
    1202:	f7 85       	ldd	r31, Z+15	; 0x0f
    1204:	e0 2d       	mov	r30, r0
    1206:	c8 01       	movw	r24, r16
    1208:	19 95       	eicall
    SetState(sWait);
    120a:	c8 01       	movw	r24, r16
    120c:	65 e0       	ldi	r22, 0x05	; 5
    120e:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1212:	07 5b       	subi	r16, 0xB7	; 183
    1214:	1f 4f       	sbci	r17, 0xFF	; 255
    1216:	f8 01       	movw	r30, r16
    1218:	10 82       	st	Z, r1
        _nackCount          = 0;
    121a:	d8 01       	movw	r26, r16
    121c:	1e 92       	st	-X, r1
        _failCount          = 0;
    121e:	fd 01       	movw	r30, r26
    1220:	12 92       	st	-Z, r1
    1222:	12 92       	st	-Z, r1
    1224:	8f 01       	movw	r16, r30
    1226:	06 54       	subi	r16, 0x46	; 70
    1228:	10 40       	sbci	r17, 0x00	; 0
        _failType           = fNone;
    122a:	d8 01       	movw	r26, r16
    122c:	18 96       	adiw	r26, 0x08	; 8
    122e:	1c 92       	st	X, r1
    ResetFailStats();
    _bDataReady[0] = false;
    1230:	0f 5b       	subi	r16, 0xBF	; 191
    1232:	1f 4f       	sbci	r17, 0xFF	; 255
    1234:	f8 01       	movw	r30, r16
    1236:	11 92       	st	Z+, r1
    1238:	8f 01       	movw	r16, r30
    _bDataReady[1] = false;
    123a:	10 82       	st	Z, r1
    _bRun = true;
    123c:	0d 5f       	subi	r16, 0xFD	; 253
    123e:	1f 4f       	sbci	r17, 0xFF	; 255
    1240:	81 e0       	ldi	r24, 0x01	; 1
    1242:	d8 01       	movw	r26, r16
    1244:	8c 93       	st	X, r24
    sei();
    1246:	78 94       	sei
    1248:	ee 24       	eor	r14, r14
    124a:	ff 24       	eor	r15, r15
    return 0;
    124c:	ce 01       	movw	r24, r28
    124e:	01 96       	adiw	r24, 0x01	; 1
    1250:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    1254:	c7 01       	movw	r24, r14
    1256:	0f 90       	pop	r0
    1258:	0f 90       	pop	r0
    125a:	cf 91       	pop	r28
    125c:	df 91       	pop	r29
    125e:	1f 91       	pop	r17
    1260:	0f 91       	pop	r16
    1262:	ff 90       	pop	r15
    1264:	ef 90       	pop	r14
    1266:	08 95       	ret

00001268 <_ZN3IMU5SetupEv>:
//! Perform the configuration on the connected IMUs
//! This should be done separately from the loop since
//! this process takes time and we do not want the fifos
//! to be too far out of step. 
//! Expected Context: Main
int IMU::Setup()
    1268:	cf 92       	push	r12
    126a:	df 92       	push	r13
    126c:	ef 92       	push	r14
    126e:	ff 92       	push	r15
    1270:	0f 93       	push	r16
    1272:	1f 93       	push	r17
    1274:	df 93       	push	r29
    1276:	cf 93       	push	r28
    1278:	0f 92       	push	r0
    127a:	0f 92       	push	r0
    127c:	cd b7       	in	r28, 0x3d	; 61
    127e:	de b7       	in	r29, 0x3e	; 62
    1280:	8c 01       	movw	r16, r24
{
    if (_numChans == 0) return 0;
    1282:	fc 01       	movw	r30, r24
    1284:	84 85       	ldd	r24, Z+12	; 0x0c
    1286:	88 23       	and	r24, r24
    1288:	19 f4       	brne	.+6      	; 0x1290 <_ZN3IMU5SetupEv+0x28>
    128a:	ee 24       	eor	r14, r14
    128c:	ff 24       	eor	r15, r15
    128e:	6e c0       	rjmp	.+220    	; 0x136c <_ZN3IMU5SetupEv+0x104>
    
    _bRun = false;
    1290:	0b 5b       	subi	r16, 0xBB	; 187
    1292:	1f 4f       	sbci	r17, 0xFF	; 255
    1294:	f8 01       	movw	r30, r16
    1296:	10 82       	st	Z, r1
    Mark marker(_pDBGPort2,pSetup);
    1298:	07 5f       	subi	r16, 0xF7	; 247
    129a:	1f 4f       	sbci	r17, 0xFF	; 255
    129c:	f8 01       	movw	r30, r16
    129e:	60 81       	ld	r22, Z
    12a0:	71 81       	ldd	r23, Z+1	; 0x01
    12a2:	0e 54       	subi	r16, 0x4E	; 78
    12a4:	10 40       	sbci	r17, 0x00	; 0
    12a6:	ce 01       	movw	r24, r28
    12a8:	01 96       	adiw	r24, 0x01	; 1
    12aa:	47 e0       	ldi	r20, 0x07	; 7
    12ac:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    
    if (_State != sIdle) {
    12b0:	f8 01       	movw	r30, r16
    12b2:	86 81       	ldd	r24, Z+6	; 0x06
    12b4:	88 23       	and	r24, r24
    12b6:	51 f0       	breq	.+20     	; 0x12cc <_ZN3IMU5SetupEv+0x64>
        if (pdbgserial) 
    12b8:	80 91 2a 26 	lds	r24, 0x262A
    12bc:	90 91 2b 26 	lds	r25, 0x262B
    12c0:	00 97       	sbiw	r24, 0x00	; 0
    12c2:	09 f4       	brne	.+2      	; 0x12c6 <_ZN3IMU5SetupEv+0x5e>
    12c4:	4d c0       	rjmp	.+154    	; 0x1360 <_ZN3IMU5SetupEv+0xf8>
            pdbgserial->print("IMU Already Running.\n");
    12c6:	67 ef       	ldi	r22, 0xF7	; 247
    12c8:	70 e2       	ldi	r23, 0x20	; 32
    12ca:	48 c0       	rjmp	.+144    	; 0x135c <_ZN3IMU5SetupEv+0xf4>
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    12cc:	07 5b       	subi	r16, 0xB7	; 183
    12ce:	1f 4f       	sbci	r17, 0xFF	; 255
    12d0:	f8 01       	movw	r30, r16
    12d2:	10 82       	st	Z, r1
        _nackCount          = 0;
    12d4:	12 92       	st	-Z, r1
        _failCount          = 0;
    12d6:	12 92       	st	-Z, r1
    12d8:	12 92       	st	-Z, r1
    12da:	8f 01       	movw	r16, r30
    12dc:	06 54       	subi	r16, 0x46	; 70
    12de:	10 40       	sbci	r17, 0x00	; 0
        _failType           = fNone;
    12e0:	f8 01       	movw	r30, r16
    12e2:	10 86       	std	Z+8, r1	; 0x08
        return 0; // Already running
    }
    
    ResetFailStats(); // inline in header
    SetState(sConfigure); // Inline in header
    12e4:	c8 01       	movw	r24, r16
    12e6:	61 e0       	ldi	r22, 0x01	; 1
    12e8:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    12ec:	cc 24       	eor	r12, r12
    12ee:	dd 24       	eor	r13, r13
    12f0:	23 c0       	rjmp	.+70     	; 0x1338 <_ZN3IMU5SetupEv+0xd0>
    
    // Start the process with Configure
    for (int x=0; x<_numChans;x++) {
        if (pdbgserial) 
    12f2:	80 91 2a 26 	lds	r24, 0x262A
    12f6:	90 91 2b 26 	lds	r25, 0x262B
    12fa:	00 97       	sbiw	r24, 0x00	; 0
    12fc:	21 f0       	breq	.+8      	; 0x1306 <_ZN3IMU5SetupEv+0x9e>
            pdbgserial->print("Configuring IMU\n");
    12fe:	6d e0       	ldi	r22, 0x0D	; 13
    1300:	71 e2       	ldi	r23, 0x21	; 33
    1302:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
        int retc = Configure(x);
    1306:	c8 01       	movw	r24, r16
    1308:	6c 2d       	mov	r22, r12
    130a:	0e 94 b2 04 	call	0x964	; 0x964 <_ZN3IMU9ConfigureEh>
    130e:	7c 01       	movw	r14, r24
        if (retc < 0 ) {
    1310:	97 ff       	sbrs	r25, 7
    1312:	0f c0       	rjmp	.+30     	; 0x1332 <_ZN3IMU5SetupEv+0xca>
            // Try reset mechanisms - none of which have
            // been found that work properly yet.
            SetState(sIdle);
    1314:	c8 01       	movw	r24, r16
    1316:	60 e0       	ldi	r22, 0x00	; 0
    1318:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
            if (pdbgserial) 
    131c:	80 91 2a 26 	lds	r24, 0x262A
    1320:	90 91 2b 26 	lds	r25, 0x262B
    1324:	00 97       	sbiw	r24, 0x00	; 0
    1326:	f1 f0       	breq	.+60     	; 0x1364 <_ZN3IMU5SetupEv+0xfc>
                pdbgserial->print("IMU Configure Failed.");
    1328:	6e e1       	ldi	r22, 0x1E	; 30
    132a:	71 e2       	ldi	r23, 0x21	; 33
    132c:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    1330:	19 c0       	rjmp	.+50     	; 0x1364 <_ZN3IMU5SetupEv+0xfc>
    
    ResetFailStats(); // inline in header
    SetState(sConfigure); // Inline in header
    
    // Start the process with Configure
    for (int x=0; x<_numChans;x++) {
    1332:	08 94       	sec
    1334:	c1 1c       	adc	r12, r1
    1336:	d1 1c       	adc	r13, r1
    1338:	f8 01       	movw	r30, r16
    133a:	84 85       	ldd	r24, Z+12	; 0x0c
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	c8 16       	cp	r12, r24
    1340:	d9 06       	cpc	r13, r25
    1342:	bc f2       	brlt	.-82     	; 0x12f2 <_ZN3IMU5SetupEv+0x8a>
            if (pdbgserial) 
                pdbgserial->print("IMU Configure Failed.");
            return retc;
        }
    }
    SetState(sConfigured);
    1344:	c8 01       	movw	r24, r16
    1346:	62 e0       	ldi	r22, 0x02	; 2
    1348:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    if (pdbgserial) 
    134c:	80 91 2a 26 	lds	r24, 0x262A
    1350:	90 91 2b 26 	lds	r25, 0x262B
    1354:	00 97       	sbiw	r24, 0x00	; 0
    1356:	21 f0       	breq	.+8      	; 0x1360 <_ZN3IMU5SetupEv+0xf8>
        pdbgserial->print("IMU Configured.\n");
    1358:	64 e3       	ldi	r22, 0x34	; 52
    135a:	71 e2       	ldi	r23, 0x21	; 33
    135c:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    1360:	ee 24       	eor	r14, r14
    1362:	ff 24       	eor	r15, r15

    return 0;
    1364:	ce 01       	movw	r24, r28
    1366:	01 96       	adiw	r24, 0x01	; 1
    1368:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    136c:	c7 01       	movw	r24, r14
    136e:	0f 90       	pop	r0
    1370:	0f 90       	pop	r0
    1372:	cf 91       	pop	r28
    1374:	df 91       	pop	r29
    1376:	1f 91       	pop	r17
    1378:	0f 91       	pop	r16
    137a:	ff 90       	pop	r15
    137c:	ef 90       	pop	r14
    137e:	df 90       	pop	r13
    1380:	cf 90       	pop	r12
    1382:	08 95       	ret

00001384 <_ZN3IMU12FailRecoveryEv>:
//! and give it another go. We will basically keep doing this
//! forever until the Manager says stop. 
//! All error or fail recovery goes through here.. I have finally
//! gotten things cleaned up enough so that I have a central location
//! for error attempts.
void IMU::FailRecovery()
    1384:	cf 93       	push	r28
    1386:	df 93       	push	r29
    1388:	ec 01       	movw	r28, r24
{
    switch(_failType) {
    138a:	88 85       	ldd	r24, Y+8	; 0x08
    138c:	82 30       	cpi	r24, 0x02	; 2
    138e:	e1 f0       	breq	.+56     	; 0x13c8 <_ZN3IMU12FailRecoveryEv+0x44>
    1390:	83 30       	cpi	r24, 0x03	; 3
    1392:	d0 f4       	brcc	.+52     	; 0x13c8 <_ZN3IMU12FailRecoveryEv+0x44>
    1394:	81 30       	cpi	r24, 0x01	; 1
    1396:	59 f5       	brne	.+86     	; 0x13ee <_ZN3IMU12FailRecoveryEv+0x6a>
    case fNone:
        break;
    case fNack:
        if (_nackCount <7) {
    1398:	c8 5b       	subi	r28, 0xB8	; 184
    139a:	df 4f       	sbci	r29, 0xFF	; 255
    139c:	88 81       	ld	r24, Y
    139e:	c8 54       	subi	r28, 0x48	; 72
    13a0:	d0 40       	sbci	r29, 0x00	; 0
    13a2:	87 30       	cpi	r24, 0x07	; 7
    13a4:	48 f0       	brcs	.+18     	; 0x13b8 <_ZN3IMU12FailRecoveryEv+0x34>
            _pMas->WigglePin(10, 0,1);
        } else if (_nackCount < 10) {
    13a6:	8a 30       	cpi	r24, 0x0A	; 10
    13a8:	f0 f4       	brcc	.+60     	; 0x13e6 <_ZN3IMU12FailRecoveryEv+0x62>
            Reset();
    13aa:	e8 81       	ld	r30, Y
    13ac:	f9 81       	ldd	r31, Y+1	; 0x01
    13ae:	01 90       	ld	r0, Z+
    13b0:	f0 81       	ld	r31, Z
    13b2:	e0 2d       	mov	r30, r0
    13b4:	ce 01       	movw	r24, r28
    13b6:	19 95       	eicall
            _pMas->WigglePin(10,0,1);
    13b8:	89 85       	ldd	r24, Y+9	; 0x09
    13ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    13bc:	6a e0       	ldi	r22, 0x0A	; 10
    13be:	40 e0       	ldi	r20, 0x00	; 0
    13c0:	21 e0       	ldi	r18, 0x01	; 1
    13c2:	0e 94 07 22 	call	0x440e	; 0x440e <_ZN10I2C_Master9WigglePinEhhh>
    13c6:	0f c0       	rjmp	.+30     	; 0x13e6 <_ZN3IMU12FailRecoveryEv+0x62>
            Reset();
        }
        SetState(_previousState);
        break;
    case fArbLost:
        if (_failCount < 5) {
    13c8:	ca 5b       	subi	r28, 0xBA	; 186
    13ca:	df 4f       	sbci	r29, 0xFF	; 255
    13cc:	88 81       	ld	r24, Y
    13ce:	99 81       	ldd	r25, Y+1	; 0x01
    13d0:	c6 54       	subi	r28, 0x46	; 70
    13d2:	d0 40       	sbci	r29, 0x00	; 0
    13d4:	05 97       	sbiw	r24, 0x05	; 5
    13d6:	38 f4       	brcc	.+14     	; 0x13e6 <_ZN3IMU12FailRecoveryEv+0x62>
            Reset();
    13d8:	e8 81       	ld	r30, Y
    13da:	f9 81       	ldd	r31, Y+1	; 0x01
    13dc:	01 90       	ld	r0, Z+
    13de:	f0 81       	ld	r31, Z
    13e0:	e0 2d       	mov	r30, r0
    13e2:	ce 01       	movw	r24, r28
    13e4:	19 95       	eicall
        }
        SetState(_previousState);
    13e6:	ce 01       	movw	r24, r28
    13e8:	6f 81       	ldd	r22, Y+7	; 0x07
    13ea:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
        break;
    }
    
    StartTransaction();
    13ee:	ce 01       	movw	r24, r28
    13f0:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <_ZN3IMU16StartTransactionEv>
}
    13f4:	df 91       	pop	r29
    13f6:	cf 91       	pop	r28
    13f8:	08 95       	ret

000013fa <_ZThn2_N3IMU10I2CArbLostEv>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
    13fa:	02 97       	sbiw	r24, 0x02	; 2
    13fc:	0e 94 01 0a 	call	0x1402	; 0x1402 <_ZN3IMU10I2CArbLostEv>
    1400:	08 95       	ret

00001402 <_ZN3IMU10I2CArbLostEv>:

//! This occurs if the Arbitration is lost.
//! If the I2C is in master mode, and it detects that it cannot control
//! the state of the data line, i.e. it wants to set a HIGH but the line
//! stays low, then this error occurs.
void IMU::I2CArbLost()
    1402:	cf 92       	push	r12
    1404:	df 92       	push	r13
    1406:	ef 92       	push	r14
    1408:	ff 92       	push	r15
    140a:	0f 93       	push	r16
    140c:	1f 93       	push	r17
    140e:	df 93       	push	r29
    1410:	cf 93       	push	r28
    1412:	00 d0       	rcall	.+0      	; 0x1414 <_ZN3IMU10I2CArbLostEv+0x12>
    1414:	0f 92       	push	r0
    1416:	cd b7       	in	r28, 0x3d	; 61
    1418:	de b7       	in	r29, 0x3e	; 62
    141a:	6c 01       	movw	r12, r24
{
    if (_bRun == false) return;
    141c:	25 e4       	ldi	r18, 0x45	; 69
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	c2 0e       	add	r12, r18
    1422:	d3 1e       	adc	r13, r19
    1424:	f6 01       	movw	r30, r12
    1426:	80 81       	ld	r24, Z
    1428:	2b eb       	ldi	r18, 0xBB	; 187
    142a:	3f ef       	ldi	r19, 0xFF	; 255
    142c:	c2 0e       	add	r12, r18
    142e:	d3 1e       	adc	r13, r19
    1430:	88 23       	and	r24, r24
    1432:	09 f4       	brne	.+2      	; 0x1436 <_ZN3IMU10I2CArbLostEv+0x34>
    1434:	5d c0       	rjmp	.+186    	; 0x14f0 <_ZN3IMU10I2CArbLostEv+0xee>
        if (_pDBGPort2) _pDBGPort2->SetState((uint8_t) p);
    }
    
    inline void ResetBusyTime()
    {
        _busyWaitTime = millis();
    1436:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    143a:	ea e4       	ldi	r30, 0x4A	; 74
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	ce 0e       	add	r12, r30
    1440:	df 1e       	adc	r13, r31
    1442:	f6 01       	movw	r30, r12
    1444:	60 83       	st	Z, r22
    1446:	71 83       	std	Z+1, r23	; 0x01
    1448:	26 eb       	ldi	r18, 0xB6	; 182
    144a:	3f ef       	ldi	r19, 0xFF	; 255
    144c:	c2 0e       	add	r12, r18
    144e:	d3 1e       	adc	r13, r19

    ResetBusyTime();
    {
        Mark marker(_pDBGPort2,pBusErr);
    1450:	6e e4       	ldi	r22, 0x4E	; 78
    1452:	e6 2e       	mov	r14, r22
    1454:	f1 2c       	mov	r15, r1
    1456:	ec 0c       	add	r14, r12
    1458:	fd 1c       	adc	r15, r13
    145a:	f7 01       	movw	r30, r14
    145c:	60 81       	ld	r22, Z
    145e:	71 81       	ldd	r23, Z+1	; 0x01
    1460:	8e 01       	movw	r16, r28
    1462:	0f 5f       	subi	r16, 0xFF	; 255
    1464:	1f 4f       	sbci	r17, 0xFF	; 255
    1466:	c8 01       	movw	r24, r16
    1468:	45 e0       	ldi	r20, 0x05	; 5
    146a:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    146e:	80 e2       	ldi	r24, 0x20	; 32
    1470:	8a 95       	dec	r24
    1472:	f1 f7       	brne	.-4      	; 0x1470 <_ZN3IMU10I2CArbLostEv+0x6e>
        _delay_us(3);
    1474:	c8 01       	movw	r24, r16
    1476:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
    }
    Mark marker(_pDBGPort2,pArbLost);
    147a:	f7 01       	movw	r30, r14
    147c:	60 81       	ld	r22, Z
    147e:	71 81       	ldd	r23, Z+1	; 0x01
    1480:	ce 01       	movw	r24, r28
    1482:	03 96       	adiw	r24, 0x03	; 3
    1484:	46 e0       	ldi	r20, 0x06	; 6
    1486:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    //! For a first pass, I am going to just try and return to Wait
    //! state - this way the timer will take back over and re-try
    //! some operation.
    _bFailDetected = true;
    148a:	29 e4       	ldi	r18, 0x49	; 73
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	c2 0e       	add	r12, r18
    1490:	d3 1e       	adc	r13, r19
    1492:	81 e0       	ldi	r24, 0x01	; 1
    1494:	f6 01       	movw	r30, r12
    1496:	80 83       	st	Z, r24
    1498:	27 eb       	ldi	r18, 0xB7	; 183
    149a:	3f ef       	ldi	r19, 0xFF	; 255
    149c:	c2 0e       	add	r12, r18
    149e:	d3 1e       	adc	r13, r19
    ++_failCount;
    14a0:	86 01       	movw	r16, r12
    14a2:	0a 5b       	subi	r16, 0xBA	; 186
    14a4:	1f 4f       	sbci	r17, 0xFF	; 255
    14a6:	f8 01       	movw	r30, r16
    14a8:	80 81       	ld	r24, Z
    14aa:	91 81       	ldd	r25, Z+1	; 0x01
    14ac:	01 96       	adiw	r24, 0x01	; 1
    14ae:	80 83       	st	Z, r24
    14b0:	91 83       	std	Z+1, r25	; 0x01
    _failType = fArbLost;
    14b2:	83 e0       	ldi	r24, 0x03	; 3
    14b4:	f6 01       	movw	r30, r12
    14b6:	80 87       	std	Z+8, r24	; 0x08

    //! I temporarily set this to ErrRecover and then delay.
    //! If I am re-starting, then I will go right back, but I
    //! will at least trigger the Logic Analyzer
    SetState(sErrRecover);
    14b8:	c6 01       	movw	r24, r12
    14ba:	6c e0       	ldi	r22, 0x0C	; 12
    14bc:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    14c0:	85 e3       	ldi	r24, 0x35	; 53
    14c2:	8a 95       	dec	r24
    14c4:	f1 f7       	brne	.-4      	; 0x14c2 <_ZN3IMU10I2CArbLostEv+0xc0>
    _delay_us(5);
    if (_failCount > 10) {
    14c6:	f8 01       	movw	r30, r16
    14c8:	80 81       	ld	r24, Z
    14ca:	91 81       	ldd	r25, Z+1	; 0x01
    14cc:	0b 97       	sbiw	r24, 0x0b	; 11
    14ce:	20 f0       	brcs	.+8      	; 0x14d8 <_ZN3IMU10I2CArbLostEv+0xd6>
        FailRecovery();
    14d0:	c6 01       	movw	r24, r12
    14d2:	0e 94 c2 09 	call	0x1384	; 0x1384 <_ZN3IMU12FailRecoveryEv>
    14d6:	08 c0       	rjmp	.+16     	; 0x14e8 <_ZN3IMU10I2CArbLostEv+0xe6>
    } else {
        SetState(_previousState);
    14d8:	c6 01       	movw	r24, r12
    14da:	f6 01       	movw	r30, r12
    14dc:	67 81       	ldd	r22, Z+7	; 0x07
    14de:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
        StartTransaction();
    14e2:	c6 01       	movw	r24, r12
    14e4:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <_ZN3IMU16StartTransactionEv>
    }
    14e8:	ce 01       	movw	r24, r28
    14ea:	03 96       	adiw	r24, 0x03	; 3
    14ec:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    14f0:	24 96       	adiw	r28, 0x04	; 4
    14f2:	cd bf       	out	0x3d, r28	; 61
    14f4:	de bf       	out	0x3e, r29	; 62
    14f6:	cf 91       	pop	r28
    14f8:	df 91       	pop	r29
    14fa:	1f 91       	pop	r17
    14fc:	0f 91       	pop	r16
    14fe:	ff 90       	pop	r15
    1500:	ef 90       	pop	r14
    1502:	df 90       	pop	r13
    1504:	cf 90       	pop	r12
    1506:	08 95       	ret

00001508 <_ZThn2_N3IMU11I2CBusErrorEv>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
    1508:	02 97       	sbiw	r24, 0x02	; 2
    150a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN3IMU11I2CBusErrorEv>
    150e:	08 95       	ret

00001510 <_ZN3IMU11I2CBusErrorEv>:
}

//! Called by I2C Master when a Bus error occurs. This means some
//! non-I2C compliant event occured. Normally, this is going to mean
//! that some glitch occured on the I2C Bus.
void IMU::I2CBusError()
    1510:	cf 92       	push	r12
    1512:	df 92       	push	r13
    1514:	ef 92       	push	r14
    1516:	ff 92       	push	r15
    1518:	0f 93       	push	r16
    151a:	1f 93       	push	r17
    151c:	df 93       	push	r29
    151e:	cf 93       	push	r28
    1520:	00 d0       	rcall	.+0      	; 0x1522 <_ZN3IMU11I2CBusErrorEv+0x12>
    1522:	0f 92       	push	r0
    1524:	cd b7       	in	r28, 0x3d	; 61
    1526:	de b7       	in	r29, 0x3e	; 62
    1528:	6c 01       	movw	r12, r24
{
    if (_bRun == false) return;
    152a:	25 e4       	ldi	r18, 0x45	; 69
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	c2 0e       	add	r12, r18
    1530:	d3 1e       	adc	r13, r19
    1532:	f6 01       	movw	r30, r12
    1534:	80 81       	ld	r24, Z
    1536:	2b eb       	ldi	r18, 0xBB	; 187
    1538:	3f ef       	ldi	r19, 0xFF	; 255
    153a:	c2 0e       	add	r12, r18
    153c:	d3 1e       	adc	r13, r19
    153e:	88 23       	and	r24, r24
    1540:	09 f4       	brne	.+2      	; 0x1544 <_ZN3IMU11I2CBusErrorEv+0x34>
    1542:	5d c0       	rjmp	.+186    	; 0x15fe <_ZN3IMU11I2CBusErrorEv+0xee>
    1544:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    1548:	ea e4       	ldi	r30, 0x4A	; 74
    154a:	f0 e0       	ldi	r31, 0x00	; 0
    154c:	ce 0e       	add	r12, r30
    154e:	df 1e       	adc	r13, r31
    1550:	f6 01       	movw	r30, r12
    1552:	60 83       	st	Z, r22
    1554:	71 83       	std	Z+1, r23	; 0x01
    1556:	26 eb       	ldi	r18, 0xB6	; 182
    1558:	3f ef       	ldi	r19, 0xFF	; 255
    155a:	c2 0e       	add	r12, r18
    155c:	d3 1e       	adc	r13, r19

    ResetBusyTime();
    {
        Mark marker(_pDBGPort2,pBusErr);
    155e:	7e e4       	ldi	r23, 0x4E	; 78
    1560:	e7 2e       	mov	r14, r23
    1562:	f1 2c       	mov	r15, r1
    1564:	ec 0c       	add	r14, r12
    1566:	fd 1c       	adc	r15, r13
    1568:	f7 01       	movw	r30, r14
    156a:	60 81       	ld	r22, Z
    156c:	71 81       	ldd	r23, Z+1	; 0x01
    156e:	8e 01       	movw	r16, r28
    1570:	0f 5f       	subi	r16, 0xFF	; 255
    1572:	1f 4f       	sbci	r17, 0xFF	; 255
    1574:	c8 01       	movw	r24, r16
    1576:	45 e0       	ldi	r20, 0x05	; 5
    1578:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    157c:	80 e2       	ldi	r24, 0x20	; 32
    157e:	8a 95       	dec	r24
    1580:	f1 f7       	brne	.-4      	; 0x157e <_ZN3IMU11I2CBusErrorEv+0x6e>
        _delay_us(3);
    1582:	c8 01       	movw	r24, r16
    1584:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
    }
    Mark marker(_pDBGPort2,pBusErr);
    1588:	f7 01       	movw	r30, r14
    158a:	60 81       	ld	r22, Z
    158c:	71 81       	ldd	r23, Z+1	; 0x01
    158e:	ce 01       	movw	r24, r28
    1590:	03 96       	adiw	r24, 0x03	; 3
    1592:	45 e0       	ldi	r20, 0x05	; 5
    1594:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    //! For a first pass, I am going to just try and return to Wait
    //! state - this way the timer will take back over and re-try
    //! some operation.

    _bFailDetected = true;
    1598:	29 e4       	ldi	r18, 0x49	; 73
    159a:	30 e0       	ldi	r19, 0x00	; 0
    159c:	c2 0e       	add	r12, r18
    159e:	d3 1e       	adc	r13, r19
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	f6 01       	movw	r30, r12
    15a4:	80 83       	st	Z, r24
    15a6:	27 eb       	ldi	r18, 0xB7	; 183
    15a8:	3f ef       	ldi	r19, 0xFF	; 255
    15aa:	c2 0e       	add	r12, r18
    15ac:	d3 1e       	adc	r13, r19
    ++_failCount;
    15ae:	86 01       	movw	r16, r12
    15b0:	0a 5b       	subi	r16, 0xBA	; 186
    15b2:	1f 4f       	sbci	r17, 0xFF	; 255
    15b4:	f8 01       	movw	r30, r16
    15b6:	80 81       	ld	r24, Z
    15b8:	91 81       	ldd	r25, Z+1	; 0x01
    15ba:	01 96       	adiw	r24, 0x01	; 1
    15bc:	80 83       	st	Z, r24
    15be:	91 83       	std	Z+1, r25	; 0x01
    _failType = fBusErr;
    15c0:	82 e0       	ldi	r24, 0x02	; 2
    15c2:	f6 01       	movw	r30, r12
    15c4:	80 87       	std	Z+8, r24	; 0x08

    //! I temporarily set this to ErrRecover and then delay.
    //! If I am re-starting, then I will go right back, but I
    //! will at least trigger the Logic Analyzer
    SetState(sErrRecover);
    15c6:	c6 01       	movw	r24, r12
    15c8:	6c e0       	ldi	r22, 0x0C	; 12
    15ca:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    15ce:	85 e3       	ldi	r24, 0x35	; 53
    15d0:	8a 95       	dec	r24
    15d2:	f1 f7       	brne	.-4      	; 0x15d0 <_ZN3IMU11I2CBusErrorEv+0xc0>
    _delay_us(5);
    if (_failCount > 10) {
    15d4:	f8 01       	movw	r30, r16
    15d6:	80 81       	ld	r24, Z
    15d8:	91 81       	ldd	r25, Z+1	; 0x01
    15da:	0b 97       	sbiw	r24, 0x0b	; 11
    15dc:	20 f0       	brcs	.+8      	; 0x15e6 <_ZN3IMU11I2CBusErrorEv+0xd6>
        FailRecovery();
    15de:	c6 01       	movw	r24, r12
    15e0:	0e 94 c2 09 	call	0x1384	; 0x1384 <_ZN3IMU12FailRecoveryEv>
    15e4:	08 c0       	rjmp	.+16     	; 0x15f6 <_ZN3IMU11I2CBusErrorEv+0xe6>
    } else {
        SetState(_previousState);
    15e6:	c6 01       	movw	r24, r12
    15e8:	f6 01       	movw	r30, r12
    15ea:	67 81       	ldd	r22, Z+7	; 0x07
    15ec:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
        StartTransaction();
    15f0:	c6 01       	movw	r24, r12
    15f2:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <_ZN3IMU16StartTransactionEv>
    }
    15f6:	ce 01       	movw	r24, r28
    15f8:	03 96       	adiw	r24, 0x03	; 3
    15fa:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    15fe:	24 96       	adiw	r28, 0x04	; 4
    1600:	cd bf       	out	0x3d, r28	; 61
    1602:	de bf       	out	0x3e, r29	; 62
    1604:	cf 91       	pop	r28
    1606:	df 91       	pop	r29
    1608:	1f 91       	pop	r17
    160a:	0f 91       	pop	r16
    160c:	ff 90       	pop	r15
    160e:	ef 90       	pop	r14
    1610:	df 90       	pop	r13
    1612:	cf 90       	pop	r12
    1614:	08 95       	ret

00001616 <_ZThn2_N3IMU7I2CNackEv>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
    1616:	02 97       	sbiw	r24, 0x02	; 2
    1618:	0e 94 0f 0b 	call	0x161e	; 0x161e <_ZN3IMU7I2CNackEv>
    161c:	08 95       	ret

0000161e <_ZN3IMU7I2CNackEv>:
//! Current idea is the repeat the current command until
//! it works since I am seeing that sometimes "Nacks" are temporary
//! So a retry is best. Other types of failures may indicate a need
//! for more desperate action - but those will probably be BusError
//! or Arb Lost commands.
void IMU::I2CNack()
    161e:	cf 92       	push	r12
    1620:	df 92       	push	r13
    1622:	ef 92       	push	r14
    1624:	ff 92       	push	r15
    1626:	0f 93       	push	r16
    1628:	1f 93       	push	r17
    162a:	df 93       	push	r29
    162c:	cf 93       	push	r28
    162e:	00 d0       	rcall	.+0      	; 0x1630 <_ZN3IMU7I2CNackEv+0x12>
    1630:	0f 92       	push	r0
    1632:	cd b7       	in	r28, 0x3d	; 61
    1634:	de b7       	in	r29, 0x3e	; 62
    1636:	6c 01       	movw	r12, r24
{
    if (_bRun == false) return;
    1638:	25 e4       	ldi	r18, 0x45	; 69
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	c2 0e       	add	r12, r18
    163e:	d3 1e       	adc	r13, r19
    1640:	d6 01       	movw	r26, r12
    1642:	8c 91       	ld	r24, X
    1644:	eb eb       	ldi	r30, 0xBB	; 187
    1646:	ff ef       	ldi	r31, 0xFF	; 255
    1648:	ce 0e       	add	r12, r30
    164a:	df 1e       	adc	r13, r31
    164c:	88 23       	and	r24, r24
    164e:	09 f4       	brne	.+2      	; 0x1652 <_ZN3IMU7I2CNackEv+0x34>
    1650:	5b c0       	rjmp	.+182    	; 0x1708 <_ZN3IMU7I2CNackEv+0xea>
    1652:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    1656:	2a e4       	ldi	r18, 0x4A	; 74
    1658:	30 e0       	ldi	r19, 0x00	; 0
    165a:	c2 0e       	add	r12, r18
    165c:	d3 1e       	adc	r13, r19
    165e:	d6 01       	movw	r26, r12
    1660:	6d 93       	st	X+, r22
    1662:	7c 93       	st	X, r23
    1664:	e6 eb       	ldi	r30, 0xB6	; 182
    1666:	ff ef       	ldi	r31, 0xFF	; 255
    1668:	ce 0e       	add	r12, r30
    166a:	df 1e       	adc	r13, r31
    
    ResetBusyTime();
    {
        Mark marker(_pDBGPort2,pBusErr);
    166c:	ee e4       	ldi	r30, 0x4E	; 78
    166e:	ee 2e       	mov	r14, r30
    1670:	f1 2c       	mov	r15, r1
    1672:	ec 0c       	add	r14, r12
    1674:	fd 1c       	adc	r15, r13
    1676:	d7 01       	movw	r26, r14
    1678:	6d 91       	ld	r22, X+
    167a:	7c 91       	ld	r23, X
    167c:	8e 01       	movw	r16, r28
    167e:	0f 5f       	subi	r16, 0xFF	; 255
    1680:	1f 4f       	sbci	r17, 0xFF	; 255
    1682:	c8 01       	movw	r24, r16
    1684:	45 e0       	ldi	r20, 0x05	; 5
    1686:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>
    168a:	80 e2       	ldi	r24, 0x20	; 32
    168c:	8a 95       	dec	r24
    168e:	f1 f7       	brne	.-4      	; 0x168c <_ZN3IMU7I2CNackEv+0x6e>
        _delay_us(3);
    1690:	c8 01       	movw	r24, r16
    1692:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
    }
    Mark marker(_pDBGPort2,pNack);
    1696:	f7 01       	movw	r30, r14
    1698:	60 81       	ld	r22, Z
    169a:	71 81       	ldd	r23, Z+1	; 0x01
    169c:	ce 01       	movw	r24, r28
    169e:	03 96       	adiw	r24, 0x03	; 3
    16a0:	44 e0       	ldi	r20, 0x04	; 4
    16a2:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>

    ++_nackCount;
    16a6:	86 01       	movw	r16, r12
    16a8:	08 5b       	subi	r16, 0xB8	; 184
    16aa:	1f 4f       	sbci	r17, 0xFF	; 255
    16ac:	d8 01       	movw	r26, r16
    16ae:	8c 91       	ld	r24, X
    16b0:	8f 5f       	subi	r24, 0xFF	; 255
    16b2:	8c 93       	st	X, r24
    
    //! I temporarily set this to ErrRecover and then delay.
    //! If I am re-starting, then I will go right back, but I
    //! will at least trigger the Logic Analyzer
    SetState(sErrRecover);
    16b4:	c6 01       	movw	r24, r12
    16b6:	6c e0       	ldi	r22, 0x0C	; 12
    16b8:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    16bc:	85 e3       	ldi	r24, 0x35	; 53
    16be:	8a 95       	dec	r24
    16c0:	f1 f7       	brne	.-4      	; 0x16be <_ZN3IMU7I2CNackEv+0xa0>
    _delay_us(5);

    //! Re-start the same transaction.
    if (_nackCount < 5) {
    16c2:	f8 01       	movw	r30, r16
    16c4:	00 81       	ld	r16, Z
    16c6:	05 30       	cpi	r16, 0x05	; 5
    16c8:	50 f4       	brcc	.+20     	; 0x16de <_ZN3IMU7I2CNackEv+0xc0>
        //! Retry the current transaction until we are sure it won't work.
        SetState(_previousState);
    16ca:	c6 01       	movw	r24, r12
    16cc:	d6 01       	movw	r26, r12
    16ce:	17 96       	adiw	r26, 0x07	; 7
    16d0:	6c 91       	ld	r22, X
    16d2:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
        StartTransaction();
    16d6:	c6 01       	movw	r24, r12
    16d8:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <_ZN3IMU16StartTransactionEv>
    16dc:	11 c0       	rjmp	.+34     	; 0x1700 <_ZN3IMU7I2CNackEv+0xe2>
    } else if (_nackCount < 10) {
    16de:	0a 30       	cpi	r16, 0x0A	; 10
    16e0:	38 f4       	brcc	.+14     	; 0x16f0 <_ZN3IMU7I2CNackEv+0xd2>
        _failType = fNack;
    16e2:	81 e0       	ldi	r24, 0x01	; 1
    16e4:	f6 01       	movw	r30, r12
    16e6:	80 87       	std	Z+8, r24	; 0x08
        FailRecovery();
    16e8:	c6 01       	movw	r24, r12
    16ea:	0e 94 c2 09 	call	0x1384	; 0x1384 <_ZN3IMU12FailRecoveryEv>
    16ee:	08 c0       	rjmp	.+16     	; 0x1700 <_ZN3IMU7I2CNackEv+0xe2>
    } else {
        //! Keep failing.. just stop.
        Stop();
    16f0:	d6 01       	movw	r26, r12
    16f2:	ed 91       	ld	r30, X+
    16f4:	fc 91       	ld	r31, X
    16f6:	00 84       	ldd	r0, Z+8	; 0x08
    16f8:	f1 85       	ldd	r31, Z+9	; 0x09
    16fa:	e0 2d       	mov	r30, r0
    16fc:	c6 01       	movw	r24, r12
    16fe:	19 95       	eicall
    }
    1700:	ce 01       	movw	r24, r28
    1702:	03 96       	adiw	r24, 0x03	; 3
    1704:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    1708:	24 96       	adiw	r28, 0x04	; 4
    170a:	cd bf       	out	0x3d, r28	; 61
    170c:	de bf       	out	0x3e, r29	; 62
    170e:	cf 91       	pop	r28
    1710:	df 91       	pop	r29
    1712:	1f 91       	pop	r17
    1714:	0f 91       	pop	r16
    1716:	ff 90       	pop	r15
    1718:	ef 90       	pop	r14
    171a:	df 90       	pop	r13
    171c:	cf 90       	pop	r12
    171e:	08 95       	ret

00001720 <_ZN3IMU3RunEv>:
//! starts the next operation in the chain. The chain checks the fifo
//! lengths of both fifos, then reads the data if there is any. If there
//! is no data yet, then the state machine enters the sWait state and the
//! next timer will initiate the chain again.
//! Expected Context: Low Lvl Timer
void IMU::Run() 
    1720:	0f 93       	push	r16
    1722:	1f 93       	push	r17
    1724:	df 93       	push	r29
    1726:	cf 93       	push	r28
    1728:	0f 92       	push	r0
    172a:	0f 92       	push	r0
    172c:	cd b7       	in	r28, 0x3d	; 61
    172e:	de b7       	in	r29, 0x3e	; 62
    1730:	8c 01       	movw	r16, r24
{
    if (_bRun == false) return;
    1732:	0b 5b       	subi	r16, 0xBB	; 187
    1734:	1f 4f       	sbci	r17, 0xFF	; 255
    1736:	d8 01       	movw	r26, r16
    1738:	8c 91       	ld	r24, X
    173a:	05 54       	subi	r16, 0x45	; 69
    173c:	10 40       	sbci	r17, 0x00	; 0
    173e:	88 23       	and	r24, r24
    1740:	09 f4       	brne	.+2      	; 0x1744 <_ZN3IMU3RunEv+0x24>
    1742:	4c c0       	rjmp	.+152    	; 0x17dc <_ZN3IMU3RunEv+0xbc>

    Mark marker(_pDBGPort2,pRun);
    1744:	02 5b       	subi	r16, 0xB2	; 178
    1746:	1f 4f       	sbci	r17, 0xFF	; 255
    1748:	f8 01       	movw	r30, r16
    174a:	60 81       	ld	r22, Z
    174c:	71 81       	ldd	r23, Z+1	; 0x01
    174e:	0e 54       	subi	r16, 0x4E	; 78
    1750:	10 40       	sbci	r17, 0x00	; 0
    1752:	ce 01       	movw	r24, r28
    1754:	01 96       	adiw	r24, 0x01	; 1
    1756:	41 e0       	ldi	r20, 0x01	; 1
    1758:	0e 94 9f 07 	call	0xf3e	; 0xf3e <_ZN4MarkC1EP9DebugPorth>

    //! Do nothing while the I2C Master is busy, the master
    //! is in the process of some operation. If the master gets
    //! hung for some reason, then we will reset and set the state
    //! to the sWait state to just start over.
    if (_pMas->busy() && BusyTimeout()) {
    175c:	d8 01       	movw	r26, r16
    175e:	19 96       	adiw	r26, 0x09	; 9
    1760:	8d 91       	ld	r24, X+
    1762:	9c 91       	ld	r25, X
    1764:	1a 97       	sbiw	r26, 0x0a	; 10
    1766:	0e 94 52 21 	call	0x42a4	; 0x42a4 <_ZN10I2C_Master4busyEv>
    176a:	88 23       	and	r24, r24
    176c:	01 f1       	breq	.+64     	; 0x17ae <_ZN3IMU3RunEv+0x8e>
    }
    
    inline bool BusyTimeout()
    {
        return ((millis() - _busyWaitTime) > 2);
    176e:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    1772:	06 5b       	subi	r16, 0xB6	; 182
    1774:	1f 4f       	sbci	r17, 0xFF	; 255
    1776:	f8 01       	movw	r30, r16
    1778:	20 81       	ld	r18, Z
    177a:	31 81       	ldd	r19, Z+1	; 0x01
    177c:	0a 54       	subi	r16, 0x4A	; 74
    177e:	10 40       	sbci	r17, 0x00	; 0
    1780:	40 e0       	ldi	r20, 0x00	; 0
    1782:	50 e0       	ldi	r21, 0x00	; 0
    1784:	62 1b       	sub	r22, r18
    1786:	73 0b       	sbc	r23, r19
    1788:	84 0b       	sbc	r24, r20
    178a:	95 0b       	sbc	r25, r21
    178c:	63 30       	cpi	r22, 0x03	; 3
    178e:	71 05       	cpc	r23, r1
    1790:	81 05       	cpc	r24, r1
    1792:	91 05       	cpc	r25, r1
    1794:	60 f0       	brcs	.+24     	; 0x17ae <_ZN3IMU3RunEv+0x8e>
        Reset();
    1796:	d8 01       	movw	r26, r16
    1798:	ed 91       	ld	r30, X+
    179a:	fc 91       	ld	r31, X
    179c:	01 90       	ld	r0, Z+
    179e:	f0 81       	ld	r31, Z
    17a0:	e0 2d       	mov	r30, r0
    17a2:	c8 01       	movw	r24, r16
    17a4:	19 95       	eicall
        SetState(sWait);
    17a6:	c8 01       	movw	r24, r16
    17a8:	65 e0       	ldi	r22, 0x05	; 5
    17aa:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
    
    //! This block only does something in the wait state. Hopefully
    //! the rest of the logic, all driven by I2C timeouts, will keep
    //! things moving through the other states. Perhaps I should have some
    //! sort of state change timeout, as long as we are in the run mode.
    switch(_State) {
    17ae:	f8 01       	movw	r30, r16
    17b0:	86 81       	ldd	r24, Z+6	; 0x06
    17b2:	85 30       	cpi	r24, 0x05	; 5
    17b4:	79 f4       	brne	.+30     	; 0x17d4 <_ZN3IMU3RunEv+0xb4>
    case sWait:
        if (_bUseGyro) {
    17b6:	d8 01       	movw	r26, r16
    17b8:	58 96       	adiw	r26, 0x18	; 24
    17ba:	8c 91       	ld	r24, X
    17bc:	88 23       	and	r24, r24
    17be:	19 f0       	breq	.+6      	; 0x17c6 <_ZN3IMU3RunEv+0xa6>
            SetState(sReadGyro1);
    17c0:	c8 01       	movw	r24, r16
    17c2:	68 e0       	ldi	r22, 0x08	; 8
    17c4:	02 c0       	rjmp	.+4      	; 0x17ca <_ZN3IMU3RunEv+0xaa>
        } else {
            SetState(sReadAcc1);
    17c6:	c8 01       	movw	r24, r16
    17c8:	69 e0       	ldi	r22, 0x09	; 9
    17ca:	0e 94 b9 07 	call	0xf72	; 0xf72 <_ZN3IMU8SetStateENS_9StateTypeE>
        }
        StartTransaction();
    17ce:	c8 01       	movw	r24, r16
    17d0:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <_ZN3IMU16StartTransactionEv>
        break;
    default:
        break;
    }
    17d4:	ce 01       	movw	r24, r28
    17d6:	01 96       	adiw	r24, 0x01	; 1
    17d8:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN4MarkD1Ev>
}
    17dc:	0f 90       	pop	r0
    17de:	0f 90       	pop	r0
    17e0:	cf 91       	pop	r28
    17e2:	df 91       	pop	r29
    17e4:	1f 91       	pop	r17
    17e6:	0f 91       	pop	r16
    17e8:	08 95       	ret

000017ea <_ZThn4_N3IMU3ovfEh>:
            return retc; // _configOkay will be false;
        }
    }
    
    return 0;
}
    17ea:	04 97       	sbiw	r24, 0x04	; 4
    17ec:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <_ZN3IMU3ovfEh>
    17f0:	08 95       	ret

000017f2 <_ZN3IMU3ovfEh>:
//! Overflow fires when the timer reaches the top period value.
//! This is setup to fire when we get a timer tick, with a default rate of 500us
//! IMUManager has only one Timer so the ID is not needed.
void IMU::ovf(uint8_t id)
{
    Run();
    17f2:	0e 94 90 0b 	call	0x1720	; 0x1720 <_ZN3IMU3RunEv>
}
    17f6:	08 95       	ret

000017f8 <_ZN3IMU9BeginReadEv>:
void IMU::NextIMU(IMUBase* pNext)
{
    _pNextIMU = pNext;
}

int IMU::BeginRead()
    17f8:	fc 01       	movw	r30, r24
{
    if (_State == sWait) {
    17fa:	86 81       	ldd	r24, Z+6	; 0x06
    17fc:	85 30       	cpi	r24, 0x05	; 5
    17fe:	21 f4       	brne	.+8      	; 0x1808 <_ZN3IMU9BeginReadEv+0x10>
        Run(); 
    1800:	cf 01       	movw	r24, r30
    1802:	0e 94 90 0b 	call	0x1720	; 0x1720 <_ZN3IMU3RunEv>
    1806:	06 c0       	rjmp	.+12     	; 0x1814 <_ZN3IMU9BeginReadEv+0x1c>
    } else {
        if (_pNextIMU) {
    1808:	e0 5b       	subi	r30, 0xB0	; 176
    180a:	ff 4f       	sbci	r31, 0xFF	; 255
    180c:	a0 81       	ld	r26, Z
    180e:	b1 81       	ldd	r27, Z+1	; 0x01
    1810:	10 97       	sbiw	r26, 0x00	; 0
    1812:	19 f4       	brne	.+6      	; 0x181a <_ZN3IMU9BeginReadEv+0x22>
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	30 e0       	ldi	r19, 0x00	; 0
    1818:	09 c0       	rjmp	.+18     	; 0x182c <_ZN3IMU9BeginReadEv+0x34>
            return _pNextIMU->BeginRead();
    181a:	ed 91       	ld	r30, X+
    181c:	fc 91       	ld	r31, X
    181e:	11 97       	sbiw	r26, 0x01	; 1
    1820:	04 88       	ldd	r0, Z+20	; 0x14
    1822:	f5 89       	ldd	r31, Z+21	; 0x15
    1824:	e0 2d       	mov	r30, r0
    1826:	cd 01       	movw	r24, r26
    1828:	19 95       	eicall
    182a:	9c 01       	movw	r18, r24
        }
    }
    return 0;
}
    182c:	c9 01       	movw	r24, r18
    182e:	08 95       	ret

00001830 <_ZN3IMU14ForceStartStopEv>:
    _pMas->Stop();
}

int IMU::ForceStartStop()
{
    return _pMas->ForceStartStop();
    1830:	fc 01       	movw	r30, r24
    1832:	81 85       	ldd	r24, Z+9	; 0x09
    1834:	92 85       	ldd	r25, Z+10	; 0x0a
    1836:	0e 94 78 21 	call	0x42f0	; 0x42f0 <_ZN10I2C_Master14ForceStartStopEv>
    183a:	28 2f       	mov	r18, r24
    183c:	33 27       	eor	r19, r19
    183e:	27 fd       	sbrc	r18, 7
    1840:	30 95       	com	r19
}
    1842:	c9 01       	movw	r24, r18
    1844:	08 95       	ret

00001846 <_ZN3IMU12ResetDevicesEv>:
    _pMas->NotifyMe(this);
}

void IMU::ResetDevices()
{
    _pMas->Stop();
    1846:	fc 01       	movw	r30, r24
    1848:	81 85       	ldd	r24, Z+9	; 0x09
    184a:	92 85       	ldd	r25, Z+10	; 0x0a
    184c:	0e 94 71 21 	call	0x42e2	; 0x42e2 <_ZN10I2C_Master4StopEv>
}
    1850:	08 95       	ret

00001852 <_ZN3IMU5ResetEv>:
void IMU::SetDebugPort2(DebugPort* pPort)
{
    _pDBGPort2 = pPort;
}

void IMU::Reset()
    1852:	0f 93       	push	r16
    1854:	1f 93       	push	r17
    1856:	8c 01       	movw	r16, r24
{
    _pMas->end();
    1858:	fc 01       	movw	r30, r24
    185a:	81 85       	ldd	r24, Z+9	; 0x09
    185c:	92 85       	ldd	r25, Z+10	; 0x0a
    185e:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <_ZN10I2C_Master3endEv>
    _pMas->begin(400e3);
    1862:	f8 01       	movw	r30, r16
    1864:	81 85       	ldd	r24, Z+9	; 0x09
    1866:	92 85       	ldd	r25, Z+10	; 0x0a
    1868:	40 e8       	ldi	r20, 0x80	; 128
    186a:	5a e1       	ldi	r21, 0x1A	; 26
    186c:	66 e0       	ldi	r22, 0x06	; 6
    186e:	70 e0       	ldi	r23, 0x00	; 0
    1870:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <_ZN10I2C_Master5beginEm>
    _pMas->NotifyMe(this);
    1874:	f8 01       	movw	r30, r16
    1876:	81 85       	ldd	r24, Z+9	; 0x09
    1878:	92 85       	ldd	r25, Z+10	; 0x0a
    187a:	0e 5f       	subi	r16, 0xFE	; 254
    187c:	1f 4f       	sbci	r17, 0xFF	; 255
    187e:	b8 01       	movw	r22, r16
    1880:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
}
    1884:	1f 91       	pop	r17
    1886:	0f 91       	pop	r16
    1888:	08 95       	ret

0000188a <_ZN3IMUC1EP10I2C_Masterhhhh>:

//! Constructor for a double IMU I2C Channel
IMU::IMU(I2C_Master* pMas, 
        uint8_t gID, uint8_t aID,
        uint8_t gID2, uint8_t aID2
    )
    188a:	cf 92       	push	r12
    188c:	df 92       	push	r13
    188e:	ef 92       	push	r14
    1890:	0f 93       	push	r16
    1892:	6c 01       	movw	r12, r24
    1894:	cb 01       	movw	r24, r22
    1896:	69 e4       	ldi	r22, 0x49	; 73
    1898:	71 e2       	ldi	r23, 0x21	; 33
    189a:	f6 01       	movw	r30, r12
    189c:	60 83       	st	Z, r22
    189e:	71 83       	std	Z+1, r23	; 0x01
    18a0:	6e 5c       	subi	r22, 0xCE	; 206
    18a2:	7f 4f       	sbci	r23, 0xFF	; 255
    18a4:	62 83       	std	Z+2, r22	; 0x02
    18a6:	73 83       	std	Z+3, r23	; 0x03
    18a8:	69 e8       	ldi	r22, 0x89	; 137
    18aa:	71 e2       	ldi	r23, 0x21	; 33
    18ac:	64 83       	std	Z+4, r22	; 0x04
    18ae:	75 83       	std	Z+5, r23	; 0x05
{
    _pNextIMU   = 0;
    18b0:	60 e5       	ldi	r22, 0x50	; 80
    18b2:	70 e0       	ldi	r23, 0x00	; 0
    18b4:	c6 0e       	add	r12, r22
    18b6:	d7 1e       	adc	r13, r23
    18b8:	f6 01       	movw	r30, r12
    18ba:	10 82       	st	Z, r1
    18bc:	11 82       	std	Z+1, r1	; 0x01
    18be:	60 eb       	ldi	r22, 0xB0	; 176
    18c0:	7f ef       	ldi	r23, 0xFF	; 255
    18c2:	c6 0e       	add	r12, r22
    18c4:	d7 1e       	adc	r13, r23
    _gID[0]     = gID;
    18c6:	f6 01       	movw	r30, r12
    18c8:	47 87       	std	Z+15, r20	; 0x0f
    _aID[0]     = aID;
    18ca:	21 8b       	std	Z+17, r18	; 0x11
    _gID[1]     = gID2;
    18cc:	00 8b       	std	Z+16, r16	; 0x10
    _aID[1]     = aID2;
    18ce:	e2 8a       	std	Z+18, r14	; 0x12
    _bDualChan  = true;
    18d0:	31 e0       	ldi	r19, 0x01	; 1
    18d2:	33 87       	std	Z+11, r19	; 0x0b
    _numChans   = 2;
    18d4:	22 e0       	ldi	r18, 0x02	; 2
    18d6:	24 87       	std	Z+12, r18	; 0x0c
    _pMas       = pMas;
    18d8:	81 87       	std	Z+9, r24	; 0x09
    18da:	92 87       	std	Z+10, r25	; 0x0a
    _DLPF       = 0x1;
    18dc:	33 8b       	std	Z+19, r19	; 0x13
    _FullScale  = 0x1;
    18de:	34 8b       	std	Z+20, r19	; 0x14
    _ClkSel     = 0x1;
    18e0:	35 8b       	std	Z+21, r19	; 0x15
    _Rate       = 10;
    18e2:	2a e0       	ldi	r18, 0x0A	; 10
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	26 8b       	std	Z+22, r18	; 0x16
    18e8:	37 8b       	std	Z+23, r19	; 0x17
    _State      = sIdle;
    18ea:	16 82       	std	Z+6, r1	; 0x06
    _bRun       = false;
    18ec:	25 e4       	ldi	r18, 0x45	; 69
    18ee:	30 e0       	ldi	r19, 0x00	; 0
    18f0:	c2 0e       	add	r12, r18
    18f2:	d3 1e       	adc	r13, r19
    18f4:	f6 01       	movw	r30, r12
    18f6:	10 82       	st	Z, r1
    _pMas->NotifyMe(this);
    18f8:	2d eb       	ldi	r18, 0xBD	; 189
    18fa:	3f ef       	ldi	r19, 0xFF	; 255
    18fc:	c2 0e       	add	r12, r18
    18fe:	d3 1e       	adc	r13, r19
    1900:	b6 01       	movw	r22, r12
    1902:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
    _pDBGPort   = 0;
    1906:	6a e4       	ldi	r22, 0x4A	; 74
    1908:	70 e0       	ldi	r23, 0x00	; 0
    190a:	c6 0e       	add	r12, r22
    190c:	d7 1e       	adc	r13, r23
    190e:	f6 01       	movw	r30, r12
    1910:	11 92       	st	Z+, r1
    1912:	11 92       	st	Z+, r1
    1914:	6f 01       	movw	r12, r30
    _pDBGPort2  = 0;
    1916:	10 82       	st	Z, r1
    1918:	11 82       	std	Z+1, r1	; 0x01
    _pTimer     = 0;
    191a:	25 ef       	ldi	r18, 0xF5	; 245
    191c:	3f ef       	ldi	r19, 0xFF	; 255
    191e:	c2 0e       	add	r12, r18
    1920:	d3 1e       	adc	r13, r19
    1922:	f6 01       	movw	r30, r12
    1924:	10 82       	st	Z, r1
    1926:	11 82       	std	Z+1, r1	; 0x01
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1928:	26 e0       	ldi	r18, 0x06	; 6
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	c2 0e       	add	r12, r18
    192e:	d3 1e       	adc	r13, r19
    1930:	f6 01       	movw	r30, r12
    1932:	10 82       	st	Z, r1
        _nackCount          = 0;
    1934:	12 92       	st	-Z, r1
        _failCount          = 0;
    1936:	12 92       	st	-Z, r1
    1938:	12 92       	st	-Z, r1
    193a:	6f 01       	movw	r12, r30
    193c:	2a eb       	ldi	r18, 0xBA	; 186
    193e:	3f ef       	ldi	r19, 0xFF	; 255
    1940:	c2 0e       	add	r12, r18
    1942:	d3 1e       	adc	r13, r19
        _failType           = fNone;
    1944:	f6 01       	movw	r30, r12
    1946:	10 86       	std	Z+8, r1	; 0x08
    ResetFailStats();
    _bUseGyro   = false;
    1948:	10 8e       	std	Z+24, r1	; 0x18
}
    194a:	0f 91       	pop	r16
    194c:	ef 90       	pop	r14
    194e:	df 90       	pop	r13
    1950:	cf 90       	pop	r12
    1952:	08 95       	ret

00001954 <_ZN3IMUC2EP10I2C_Masterhhhh>:

//! Constructor for a double IMU I2C Channel
IMU::IMU(I2C_Master* pMas, 
        uint8_t gID, uint8_t aID,
        uint8_t gID2, uint8_t aID2
    )
    1954:	cf 92       	push	r12
    1956:	df 92       	push	r13
    1958:	ef 92       	push	r14
    195a:	0f 93       	push	r16
    195c:	6c 01       	movw	r12, r24
    195e:	cb 01       	movw	r24, r22
    1960:	69 e4       	ldi	r22, 0x49	; 73
    1962:	71 e2       	ldi	r23, 0x21	; 33
    1964:	f6 01       	movw	r30, r12
    1966:	60 83       	st	Z, r22
    1968:	71 83       	std	Z+1, r23	; 0x01
    196a:	6e 5c       	subi	r22, 0xCE	; 206
    196c:	7f 4f       	sbci	r23, 0xFF	; 255
    196e:	62 83       	std	Z+2, r22	; 0x02
    1970:	73 83       	std	Z+3, r23	; 0x03
    1972:	69 e8       	ldi	r22, 0x89	; 137
    1974:	71 e2       	ldi	r23, 0x21	; 33
    1976:	64 83       	std	Z+4, r22	; 0x04
    1978:	75 83       	std	Z+5, r23	; 0x05
{
    _pNextIMU   = 0;
    197a:	60 e5       	ldi	r22, 0x50	; 80
    197c:	70 e0       	ldi	r23, 0x00	; 0
    197e:	c6 0e       	add	r12, r22
    1980:	d7 1e       	adc	r13, r23
    1982:	f6 01       	movw	r30, r12
    1984:	10 82       	st	Z, r1
    1986:	11 82       	std	Z+1, r1	; 0x01
    1988:	60 eb       	ldi	r22, 0xB0	; 176
    198a:	7f ef       	ldi	r23, 0xFF	; 255
    198c:	c6 0e       	add	r12, r22
    198e:	d7 1e       	adc	r13, r23
    _gID[0]     = gID;
    1990:	f6 01       	movw	r30, r12
    1992:	47 87       	std	Z+15, r20	; 0x0f
    _aID[0]     = aID;
    1994:	21 8b       	std	Z+17, r18	; 0x11
    _gID[1]     = gID2;
    1996:	00 8b       	std	Z+16, r16	; 0x10
    _aID[1]     = aID2;
    1998:	e2 8a       	std	Z+18, r14	; 0x12
    _bDualChan  = true;
    199a:	31 e0       	ldi	r19, 0x01	; 1
    199c:	33 87       	std	Z+11, r19	; 0x0b
    _numChans   = 2;
    199e:	22 e0       	ldi	r18, 0x02	; 2
    19a0:	24 87       	std	Z+12, r18	; 0x0c
    _pMas       = pMas;
    19a2:	81 87       	std	Z+9, r24	; 0x09
    19a4:	92 87       	std	Z+10, r25	; 0x0a
    _DLPF       = 0x1;
    19a6:	33 8b       	std	Z+19, r19	; 0x13
    _FullScale  = 0x1;
    19a8:	34 8b       	std	Z+20, r19	; 0x14
    _ClkSel     = 0x1;
    19aa:	35 8b       	std	Z+21, r19	; 0x15
    _Rate       = 10;
    19ac:	2a e0       	ldi	r18, 0x0A	; 10
    19ae:	30 e0       	ldi	r19, 0x00	; 0
    19b0:	26 8b       	std	Z+22, r18	; 0x16
    19b2:	37 8b       	std	Z+23, r19	; 0x17
    _State      = sIdle;
    19b4:	16 82       	std	Z+6, r1	; 0x06
    _bRun       = false;
    19b6:	25 e4       	ldi	r18, 0x45	; 69
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	c2 0e       	add	r12, r18
    19bc:	d3 1e       	adc	r13, r19
    19be:	f6 01       	movw	r30, r12
    19c0:	10 82       	st	Z, r1
    _pMas->NotifyMe(this);
    19c2:	2d eb       	ldi	r18, 0xBD	; 189
    19c4:	3f ef       	ldi	r19, 0xFF	; 255
    19c6:	c2 0e       	add	r12, r18
    19c8:	d3 1e       	adc	r13, r19
    19ca:	b6 01       	movw	r22, r12
    19cc:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
    _pDBGPort   = 0;
    19d0:	6a e4       	ldi	r22, 0x4A	; 74
    19d2:	70 e0       	ldi	r23, 0x00	; 0
    19d4:	c6 0e       	add	r12, r22
    19d6:	d7 1e       	adc	r13, r23
    19d8:	f6 01       	movw	r30, r12
    19da:	11 92       	st	Z+, r1
    19dc:	11 92       	st	Z+, r1
    19de:	6f 01       	movw	r12, r30
    _pDBGPort2  = 0;
    19e0:	10 82       	st	Z, r1
    19e2:	11 82       	std	Z+1, r1	; 0x01
    _pTimer     = 0;
    19e4:	25 ef       	ldi	r18, 0xF5	; 245
    19e6:	3f ef       	ldi	r19, 0xFF	; 255
    19e8:	c2 0e       	add	r12, r18
    19ea:	d3 1e       	adc	r13, r19
    19ec:	f6 01       	movw	r30, r12
    19ee:	10 82       	st	Z, r1
    19f0:	11 82       	std	Z+1, r1	; 0x01
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    19f2:	26 e0       	ldi	r18, 0x06	; 6
    19f4:	30 e0       	ldi	r19, 0x00	; 0
    19f6:	c2 0e       	add	r12, r18
    19f8:	d3 1e       	adc	r13, r19
    19fa:	f6 01       	movw	r30, r12
    19fc:	10 82       	st	Z, r1
        _nackCount          = 0;
    19fe:	12 92       	st	-Z, r1
        _failCount          = 0;
    1a00:	12 92       	st	-Z, r1
    1a02:	12 92       	st	-Z, r1
    1a04:	6f 01       	movw	r12, r30
    1a06:	2a eb       	ldi	r18, 0xBA	; 186
    1a08:	3f ef       	ldi	r19, 0xFF	; 255
    1a0a:	c2 0e       	add	r12, r18
    1a0c:	d3 1e       	adc	r13, r19
        _failType           = fNone;
    1a0e:	f6 01       	movw	r30, r12
    1a10:	10 86       	std	Z+8, r1	; 0x08
    ResetFailStats();
    _bUseGyro   = false;
    1a12:	10 8e       	std	Z+24, r1	; 0x18
}
    1a14:	0f 91       	pop	r16
    1a16:	ef 90       	pop	r14
    1a18:	df 90       	pop	r13
    1a1a:	cf 90       	pop	r12
    1a1c:	08 95       	ret

00001a1e <_ZN3IMUC1EP10I2C_Masterhh>:
    _pMas->NotifyMe(this);
    QueryChannels();
}

//! Constructor for a single IMU I2C Channel
IMU::IMU(I2C_Master* pMas, uint8_t gID, uint8_t aID)
    1a1e:	0f 93       	push	r16
    1a20:	1f 93       	push	r17
    1a22:	8c 01       	movw	r16, r24
    1a24:	cb 01       	movw	r24, r22
    1a26:	69 e4       	ldi	r22, 0x49	; 73
    1a28:	71 e2       	ldi	r23, 0x21	; 33
    1a2a:	f8 01       	movw	r30, r16
    1a2c:	60 83       	st	Z, r22
    1a2e:	71 83       	std	Z+1, r23	; 0x01
    1a30:	6e 5c       	subi	r22, 0xCE	; 206
    1a32:	7f 4f       	sbci	r23, 0xFF	; 255
    1a34:	62 83       	std	Z+2, r22	; 0x02
    1a36:	73 83       	std	Z+3, r23	; 0x03
    1a38:	69 e8       	ldi	r22, 0x89	; 137
    1a3a:	71 e2       	ldi	r23, 0x21	; 33
    1a3c:	64 83       	std	Z+4, r22	; 0x04
    1a3e:	75 83       	std	Z+5, r23	; 0x05
{
    _pNextIMU   = 0;
    1a40:	00 5b       	subi	r16, 0xB0	; 176
    1a42:	1f 4f       	sbci	r17, 0xFF	; 255
    1a44:	f8 01       	movw	r30, r16
    1a46:	10 82       	st	Z, r1
    1a48:	11 82       	std	Z+1, r1	; 0x01
    1a4a:	00 55       	subi	r16, 0x50	; 80
    1a4c:	10 40       	sbci	r17, 0x00	; 0
    _gID[0]     = gID;
    1a4e:	f8 01       	movw	r30, r16
    1a50:	47 87       	std	Z+15, r20	; 0x0f
    _aID[0]     = aID;
    1a52:	21 8b       	std	Z+17, r18	; 0x11
    _bDualChan  = false;
    1a54:	13 86       	std	Z+11, r1	; 0x0b
    _numChans   = 1;
    1a56:	21 e0       	ldi	r18, 0x01	; 1
    1a58:	24 87       	std	Z+12, r18	; 0x0c
    _pMas       = pMas;
    1a5a:	81 87       	std	Z+9, r24	; 0x09
    1a5c:	92 87       	std	Z+10, r25	; 0x0a
    _DLPF       = 0x1;
    1a5e:	23 8b       	std	Z+19, r18	; 0x13
    _FullScale  = 0x1;
    1a60:	24 8b       	std	Z+20, r18	; 0x14
    _ClkSel     = 0x1;
    1a62:	25 8b       	std	Z+21, r18	; 0x15
    _Rate       = 10;
    1a64:	2a e0       	ldi	r18, 0x0A	; 10
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	26 8b       	std	Z+22, r18	; 0x16
    1a6a:	37 8b       	std	Z+23, r19	; 0x17
    _State      = sIdle;
    1a6c:	16 82       	std	Z+6, r1	; 0x06
    _bRun       = false;
    1a6e:	0b 5b       	subi	r16, 0xBB	; 187
    1a70:	1f 4f       	sbci	r17, 0xFF	; 255
    1a72:	f8 01       	movw	r30, r16
    1a74:	10 82       	st	Z, r1
    _pMas->NotifyMe(this);
    1a76:	03 54       	subi	r16, 0x43	; 67
    1a78:	10 40       	sbci	r17, 0x00	; 0
    1a7a:	b8 01       	movw	r22, r16
    1a7c:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
    _pDBGPort   = 0;
    1a80:	06 5b       	subi	r16, 0xB6	; 182
    1a82:	1f 4f       	sbci	r17, 0xFF	; 255
    1a84:	f8 01       	movw	r30, r16
    1a86:	11 92       	st	Z+, r1
    1a88:	11 92       	st	Z+, r1
    1a8a:	8f 01       	movw	r16, r30
    _pDBGPort2  = 0;
    1a8c:	10 82       	st	Z, r1
    1a8e:	11 82       	std	Z+1, r1	; 0x01
    _pTimer     = 0;
    1a90:	0b 50       	subi	r16, 0x0B	; 11
    1a92:	10 40       	sbci	r17, 0x00	; 0
    1a94:	f8 01       	movw	r30, r16
    1a96:	10 82       	st	Z, r1
    1a98:	11 82       	std	Z+1, r1	; 0x01
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1a9a:	0a 5f       	subi	r16, 0xFA	; 250
    1a9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a9e:	f8 01       	movw	r30, r16
    1aa0:	10 82       	st	Z, r1
        _nackCount          = 0;
    1aa2:	12 92       	st	-Z, r1
        _failCount          = 0;
    1aa4:	12 92       	st	-Z, r1
    1aa6:	12 92       	st	-Z, r1
    1aa8:	8f 01       	movw	r16, r30
    1aaa:	06 54       	subi	r16, 0x46	; 70
    1aac:	10 40       	sbci	r17, 0x00	; 0
        _failType           = fNone;
    1aae:	f8 01       	movw	r30, r16
    1ab0:	10 86       	std	Z+8, r1	; 0x08
    ResetFailStats();    
    _bUseGyro   = false;
    1ab2:	10 8e       	std	Z+24, r1	; 0x18
}
    1ab4:	1f 91       	pop	r17
    1ab6:	0f 91       	pop	r16
    1ab8:	08 95       	ret

00001aba <_ZN3IMUC2EP10I2C_Masterhh>:
    _pMas->NotifyMe(this);
    QueryChannels();
}

//! Constructor for a single IMU I2C Channel
IMU::IMU(I2C_Master* pMas, uint8_t gID, uint8_t aID)
    1aba:	0f 93       	push	r16
    1abc:	1f 93       	push	r17
    1abe:	8c 01       	movw	r16, r24
    1ac0:	cb 01       	movw	r24, r22
    1ac2:	69 e4       	ldi	r22, 0x49	; 73
    1ac4:	71 e2       	ldi	r23, 0x21	; 33
    1ac6:	f8 01       	movw	r30, r16
    1ac8:	60 83       	st	Z, r22
    1aca:	71 83       	std	Z+1, r23	; 0x01
    1acc:	6e 5c       	subi	r22, 0xCE	; 206
    1ace:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad0:	62 83       	std	Z+2, r22	; 0x02
    1ad2:	73 83       	std	Z+3, r23	; 0x03
    1ad4:	69 e8       	ldi	r22, 0x89	; 137
    1ad6:	71 e2       	ldi	r23, 0x21	; 33
    1ad8:	64 83       	std	Z+4, r22	; 0x04
    1ada:	75 83       	std	Z+5, r23	; 0x05
{
    _pNextIMU   = 0;
    1adc:	00 5b       	subi	r16, 0xB0	; 176
    1ade:	1f 4f       	sbci	r17, 0xFF	; 255
    1ae0:	f8 01       	movw	r30, r16
    1ae2:	10 82       	st	Z, r1
    1ae4:	11 82       	std	Z+1, r1	; 0x01
    1ae6:	00 55       	subi	r16, 0x50	; 80
    1ae8:	10 40       	sbci	r17, 0x00	; 0
    _gID[0]     = gID;
    1aea:	f8 01       	movw	r30, r16
    1aec:	47 87       	std	Z+15, r20	; 0x0f
    _aID[0]     = aID;
    1aee:	21 8b       	std	Z+17, r18	; 0x11
    _bDualChan  = false;
    1af0:	13 86       	std	Z+11, r1	; 0x0b
    _numChans   = 1;
    1af2:	21 e0       	ldi	r18, 0x01	; 1
    1af4:	24 87       	std	Z+12, r18	; 0x0c
    _pMas       = pMas;
    1af6:	81 87       	std	Z+9, r24	; 0x09
    1af8:	92 87       	std	Z+10, r25	; 0x0a
    _DLPF       = 0x1;
    1afa:	23 8b       	std	Z+19, r18	; 0x13
    _FullScale  = 0x1;
    1afc:	24 8b       	std	Z+20, r18	; 0x14
    _ClkSel     = 0x1;
    1afe:	25 8b       	std	Z+21, r18	; 0x15
    _Rate       = 10;
    1b00:	2a e0       	ldi	r18, 0x0A	; 10
    1b02:	30 e0       	ldi	r19, 0x00	; 0
    1b04:	26 8b       	std	Z+22, r18	; 0x16
    1b06:	37 8b       	std	Z+23, r19	; 0x17
    _State      = sIdle;
    1b08:	16 82       	std	Z+6, r1	; 0x06
    _bRun       = false;
    1b0a:	0b 5b       	subi	r16, 0xBB	; 187
    1b0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b0e:	f8 01       	movw	r30, r16
    1b10:	10 82       	st	Z, r1
    _pMas->NotifyMe(this);
    1b12:	03 54       	subi	r16, 0x43	; 67
    1b14:	10 40       	sbci	r17, 0x00	; 0
    1b16:	b8 01       	movw	r22, r16
    1b18:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
    _pDBGPort   = 0;
    1b1c:	06 5b       	subi	r16, 0xB6	; 182
    1b1e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b20:	f8 01       	movw	r30, r16
    1b22:	11 92       	st	Z+, r1
    1b24:	11 92       	st	Z+, r1
    1b26:	8f 01       	movw	r16, r30
    _pDBGPort2  = 0;
    1b28:	10 82       	st	Z, r1
    1b2a:	11 82       	std	Z+1, r1	; 0x01
    _pTimer     = 0;
    1b2c:	0b 50       	subi	r16, 0x0B	; 11
    1b2e:	10 40       	sbci	r17, 0x00	; 0
    1b30:	f8 01       	movw	r30, r16
    1b32:	10 82       	st	Z, r1
    1b34:	11 82       	std	Z+1, r1	; 0x01
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1b36:	0a 5f       	subi	r16, 0xFA	; 250
    1b38:	1f 4f       	sbci	r17, 0xFF	; 255
    1b3a:	f8 01       	movw	r30, r16
    1b3c:	10 82       	st	Z, r1
        _nackCount          = 0;
    1b3e:	12 92       	st	-Z, r1
        _failCount          = 0;
    1b40:	12 92       	st	-Z, r1
    1b42:	12 92       	st	-Z, r1
    1b44:	8f 01       	movw	r16, r30
    1b46:	06 54       	subi	r16, 0x46	; 70
    1b48:	10 40       	sbci	r17, 0x00	; 0
        _failType           = fNone;
    1b4a:	f8 01       	movw	r30, r16
    1b4c:	10 86       	std	Z+8, r1	; 0x08
    ResetFailStats();    
    _bUseGyro   = false;
    1b4e:	10 8e       	std	Z+24, r1	; 0x18
}
    1b50:	1f 91       	pop	r17
    1b52:	0f 91       	pop	r16
    1b54:	08 95       	ret

00001b56 <_ZN3IMUC1EP10I2C_Master>:
extern HardwareSerial* pdbgserial;
static char buffer[128];

//! Constructor for an auto-query channel
//! Init fifos for dual channel
IMU::IMU(I2C_Master* pMas)
    1b56:	0f 93       	push	r16
    1b58:	1f 93       	push	r17
    1b5a:	8c 01       	movw	r16, r24
    1b5c:	cb 01       	movw	r24, r22
    1b5e:	29 e4       	ldi	r18, 0x49	; 73
    1b60:	31 e2       	ldi	r19, 0x21	; 33
    1b62:	d8 01       	movw	r26, r16
    1b64:	2d 93       	st	X+, r18
    1b66:	3c 93       	st	X, r19
    1b68:	11 97       	sbiw	r26, 0x01	; 1
    1b6a:	2e 5c       	subi	r18, 0xCE	; 206
    1b6c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b6e:	12 96       	adiw	r26, 0x02	; 2
    1b70:	2d 93       	st	X+, r18
    1b72:	3c 93       	st	X, r19
    1b74:	13 97       	sbiw	r26, 0x03	; 3
    1b76:	29 e8       	ldi	r18, 0x89	; 137
    1b78:	31 e2       	ldi	r19, 0x21	; 33
    1b7a:	14 96       	adiw	r26, 0x04	; 4
    1b7c:	2d 93       	st	X+, r18
    1b7e:	3c 93       	st	X, r19
    1b80:	15 97       	sbiw	r26, 0x05	; 5
{
    _pNextIMU       = 0;
    1b82:	f8 01       	movw	r30, r16
    1b84:	e0 5b       	subi	r30, 0xB0	; 176
    1b86:	ff 4f       	sbci	r31, 0xFF	; 255
    _gID[0]         = 0;
    1b88:	1f 96       	adiw	r26, 0x0f	; 15
    1b8a:	1c 92       	st	X, r1
    1b8c:	1f 97       	sbiw	r26, 0x0f	; 15
    _aID[0]         = 0;
    1b8e:	51 96       	adiw	r26, 0x11	; 17
    1b90:	1c 92       	st	X, r1
    1b92:	51 97       	sbiw	r26, 0x11	; 17
    _gID[1]         = 0;
    1b94:	50 96       	adiw	r26, 0x10	; 16
    1b96:	1c 92       	st	X, r1
    1b98:	50 97       	sbiw	r26, 0x10	; 16
    _aID[1]         = 0;
    1b9a:	52 96       	adiw	r26, 0x12	; 18
    1b9c:	1c 92       	st	X, r1
    1b9e:	52 97       	sbiw	r26, 0x12	; 18
    _bDualChan      = false;
    1ba0:	1b 96       	adiw	r26, 0x0b	; 11
    1ba2:	1c 92       	st	X, r1
    1ba4:	1b 97       	sbiw	r26, 0x0b	; 11
    _numChans       = 0;
    1ba6:	1c 96       	adiw	r26, 0x0c	; 12
    1ba8:	1c 92       	st	X, r1
    1baa:	1c 97       	sbiw	r26, 0x0c	; 12
    _pMas           = pMas;
    1bac:	19 96       	adiw	r26, 0x09	; 9
    1bae:	6d 93       	st	X+, r22
    1bb0:	7c 93       	st	X, r23
    1bb2:	1a 97       	sbiw	r26, 0x0a	; 10
    _DLPF           = 0x1;
    1bb4:	21 e0       	ldi	r18, 0x01	; 1
    1bb6:	53 96       	adiw	r26, 0x13	; 19
    1bb8:	2c 93       	st	X, r18
    1bba:	53 97       	sbiw	r26, 0x13	; 19
    _FullScale      = 0x1;
    1bbc:	54 96       	adiw	r26, 0x14	; 20
    1bbe:	2c 93       	st	X, r18
    1bc0:	54 97       	sbiw	r26, 0x14	; 20
    _ClkSel         = 0x1;
    1bc2:	55 96       	adiw	r26, 0x15	; 21
    1bc4:	2c 93       	st	X, r18
    1bc6:	55 97       	sbiw	r26, 0x15	; 21
    _Rate           = 10;
    1bc8:	2a e0       	ldi	r18, 0x0A	; 10
    1bca:	30 e0       	ldi	r19, 0x00	; 0
    1bcc:	56 96       	adiw	r26, 0x16	; 22
    1bce:	2d 93       	st	X+, r18
    1bd0:	3c 93       	st	X, r19
    1bd2:	57 97       	sbiw	r26, 0x17	; 23
    _State          = sIdle;
    1bd4:	16 96       	adiw	r26, 0x06	; 6
    1bd6:	1c 92       	st	X, r1
    1bd8:	16 97       	sbiw	r26, 0x06	; 6
    _previousState  = sIdle;
    1bda:	17 96       	adiw	r26, 0x07	; 7
    1bdc:	1c 92       	st	X, r1
    _failType       = fNone;
    _bRun           = false;
    1bde:	0b 5b       	subi	r16, 0xBB	; 187
    1be0:	1f 4f       	sbci	r17, 0xFF	; 255
    1be2:	d8 01       	movw	r26, r16
    1be4:	1c 92       	st	X, r1
    _busyWaitTime   = 0;
    1be6:	0b 5f       	subi	r16, 0xFB	; 251
    1be8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bea:	d8 01       	movw	r26, r16
    1bec:	1d 92       	st	X+, r1
    1bee:	1c 92       	st	X, r1
    _bDataReady[0]  = false;
    1bf0:	09 50       	subi	r16, 0x09	; 9
    1bf2:	10 40       	sbci	r17, 0x00	; 0
    1bf4:	d8 01       	movw	r26, r16
    1bf6:	1d 92       	st	X+, r1
    1bf8:	8d 01       	movw	r16, r26
    _bDataReady[1]  = false;
    1bfa:	1c 92       	st	X, r1
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1bfc:	09 5f       	subi	r16, 0xF9	; 249
    1bfe:	1f 4f       	sbci	r17, 0xFF	; 255
    1c00:	d8 01       	movw	r26, r16
    1c02:	1c 92       	st	X, r1
        _nackCount          = 0;
    1c04:	1e 92       	st	-X, r1
        _failCount          = 0;
    1c06:	1e 92       	st	-X, r1
    1c08:	1e 92       	st	-X, r1
    1c0a:	8d 01       	movw	r16, r26
    1c0c:	06 54       	subi	r16, 0x46	; 70
    1c0e:	10 40       	sbci	r17, 0x00	; 0
        _failType           = fNone;
    1c10:	d8 01       	movw	r26, r16
    1c12:	18 96       	adiw	r26, 0x08	; 8
    1c14:	1c 92       	st	X, r1
    
    ResetFailStats();
    _pDBGPort       = 0;
    1c16:	04 5b       	subi	r16, 0xB4	; 180
    1c18:	1f 4f       	sbci	r17, 0xFF	; 255
    1c1a:	d8 01       	movw	r26, r16
    1c1c:	1d 92       	st	X+, r1
    1c1e:	1d 92       	st	X+, r1
    1c20:	8d 01       	movw	r16, r26
    _pDBGPort2      = 0;
    1c22:	1d 92       	st	X+, r1
    1c24:	1c 92       	st	X, r1
    _pNextIMU       = 0;
    1c26:	10 82       	st	Z, r1
    1c28:	11 82       	std	Z+1, r1	; 0x01
    _pTimer         = 0;
    1c2a:	0b 50       	subi	r16, 0x0B	; 11
    1c2c:	10 40       	sbci	r17, 0x00	; 0
    1c2e:	f8 01       	movw	r30, r16
    1c30:	10 82       	st	Z, r1
    1c32:	11 82       	std	Z+1, r1	; 0x01
    1c34:	03 54       	subi	r16, 0x43	; 67
    1c36:	10 40       	sbci	r17, 0x00	; 0
    _bUseGyro       = false;
    1c38:	d8 01       	movw	r26, r16
    1c3a:	58 96       	adiw	r26, 0x18	; 24
    1c3c:	1c 92       	st	X, r1
    _pMas->NotifyMe(this);
    1c3e:	b8 01       	movw	r22, r16
    1c40:	6e 5f       	subi	r22, 0xFE	; 254
    1c42:	7f 4f       	sbci	r23, 0xFF	; 255
    1c44:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
    QueryChannels();
    1c48:	c8 01       	movw	r24, r16
    1c4a:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <_ZN3IMU13QueryChannelsEv>
}
    1c4e:	1f 91       	pop	r17
    1c50:	0f 91       	pop	r16
    1c52:	08 95       	ret

00001c54 <_ZN3IMUC2EP10I2C_Master>:
extern HardwareSerial* pdbgserial;
static char buffer[128];

//! Constructor for an auto-query channel
//! Init fifos for dual channel
IMU::IMU(I2C_Master* pMas)
    1c54:	0f 93       	push	r16
    1c56:	1f 93       	push	r17
    1c58:	8c 01       	movw	r16, r24
    1c5a:	cb 01       	movw	r24, r22
    1c5c:	29 e4       	ldi	r18, 0x49	; 73
    1c5e:	31 e2       	ldi	r19, 0x21	; 33
    1c60:	d8 01       	movw	r26, r16
    1c62:	2d 93       	st	X+, r18
    1c64:	3c 93       	st	X, r19
    1c66:	11 97       	sbiw	r26, 0x01	; 1
    1c68:	2e 5c       	subi	r18, 0xCE	; 206
    1c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6c:	12 96       	adiw	r26, 0x02	; 2
    1c6e:	2d 93       	st	X+, r18
    1c70:	3c 93       	st	X, r19
    1c72:	13 97       	sbiw	r26, 0x03	; 3
    1c74:	29 e8       	ldi	r18, 0x89	; 137
    1c76:	31 e2       	ldi	r19, 0x21	; 33
    1c78:	14 96       	adiw	r26, 0x04	; 4
    1c7a:	2d 93       	st	X+, r18
    1c7c:	3c 93       	st	X, r19
    1c7e:	15 97       	sbiw	r26, 0x05	; 5
{
    _pNextIMU       = 0;
    1c80:	f8 01       	movw	r30, r16
    1c82:	e0 5b       	subi	r30, 0xB0	; 176
    1c84:	ff 4f       	sbci	r31, 0xFF	; 255
    _gID[0]         = 0;
    1c86:	1f 96       	adiw	r26, 0x0f	; 15
    1c88:	1c 92       	st	X, r1
    1c8a:	1f 97       	sbiw	r26, 0x0f	; 15
    _aID[0]         = 0;
    1c8c:	51 96       	adiw	r26, 0x11	; 17
    1c8e:	1c 92       	st	X, r1
    1c90:	51 97       	sbiw	r26, 0x11	; 17
    _gID[1]         = 0;
    1c92:	50 96       	adiw	r26, 0x10	; 16
    1c94:	1c 92       	st	X, r1
    1c96:	50 97       	sbiw	r26, 0x10	; 16
    _aID[1]         = 0;
    1c98:	52 96       	adiw	r26, 0x12	; 18
    1c9a:	1c 92       	st	X, r1
    1c9c:	52 97       	sbiw	r26, 0x12	; 18
    _bDualChan      = false;
    1c9e:	1b 96       	adiw	r26, 0x0b	; 11
    1ca0:	1c 92       	st	X, r1
    1ca2:	1b 97       	sbiw	r26, 0x0b	; 11
    _numChans       = 0;
    1ca4:	1c 96       	adiw	r26, 0x0c	; 12
    1ca6:	1c 92       	st	X, r1
    1ca8:	1c 97       	sbiw	r26, 0x0c	; 12
    _pMas           = pMas;
    1caa:	19 96       	adiw	r26, 0x09	; 9
    1cac:	6d 93       	st	X+, r22
    1cae:	7c 93       	st	X, r23
    1cb0:	1a 97       	sbiw	r26, 0x0a	; 10
    _DLPF           = 0x1;
    1cb2:	21 e0       	ldi	r18, 0x01	; 1
    1cb4:	53 96       	adiw	r26, 0x13	; 19
    1cb6:	2c 93       	st	X, r18
    1cb8:	53 97       	sbiw	r26, 0x13	; 19
    _FullScale      = 0x1;
    1cba:	54 96       	adiw	r26, 0x14	; 20
    1cbc:	2c 93       	st	X, r18
    1cbe:	54 97       	sbiw	r26, 0x14	; 20
    _ClkSel         = 0x1;
    1cc0:	55 96       	adiw	r26, 0x15	; 21
    1cc2:	2c 93       	st	X, r18
    1cc4:	55 97       	sbiw	r26, 0x15	; 21
    _Rate           = 10;
    1cc6:	2a e0       	ldi	r18, 0x0A	; 10
    1cc8:	30 e0       	ldi	r19, 0x00	; 0
    1cca:	56 96       	adiw	r26, 0x16	; 22
    1ccc:	2d 93       	st	X+, r18
    1cce:	3c 93       	st	X, r19
    1cd0:	57 97       	sbiw	r26, 0x17	; 23
    _State          = sIdle;
    1cd2:	16 96       	adiw	r26, 0x06	; 6
    1cd4:	1c 92       	st	X, r1
    1cd6:	16 97       	sbiw	r26, 0x06	; 6
    _previousState  = sIdle;
    1cd8:	17 96       	adiw	r26, 0x07	; 7
    1cda:	1c 92       	st	X, r1
    _failType       = fNone;
    _bRun           = false;
    1cdc:	0b 5b       	subi	r16, 0xBB	; 187
    1cde:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce0:	d8 01       	movw	r26, r16
    1ce2:	1c 92       	st	X, r1
    _busyWaitTime   = 0;
    1ce4:	0b 5f       	subi	r16, 0xFB	; 251
    1ce6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce8:	d8 01       	movw	r26, r16
    1cea:	1d 92       	st	X+, r1
    1cec:	1c 92       	st	X, r1
    _bDataReady[0]  = false;
    1cee:	09 50       	subi	r16, 0x09	; 9
    1cf0:	10 40       	sbci	r17, 0x00	; 0
    1cf2:	d8 01       	movw	r26, r16
    1cf4:	1d 92       	st	X+, r1
    1cf6:	8d 01       	movw	r16, r26
    _bDataReady[1]  = false;
    1cf8:	1c 92       	st	X, r1
        return ((millis() - _busyWaitTime) > 2);
    }
    
    inline void ResetFailStats()
    {
        _bFailDetected      = false;
    1cfa:	09 5f       	subi	r16, 0xF9	; 249
    1cfc:	1f 4f       	sbci	r17, 0xFF	; 255
    1cfe:	d8 01       	movw	r26, r16
    1d00:	1c 92       	st	X, r1
        _nackCount          = 0;
    1d02:	1e 92       	st	-X, r1
        _failCount          = 0;
    1d04:	1e 92       	st	-X, r1
    1d06:	1e 92       	st	-X, r1
    1d08:	8d 01       	movw	r16, r26
    1d0a:	06 54       	subi	r16, 0x46	; 70
    1d0c:	10 40       	sbci	r17, 0x00	; 0
        _failType           = fNone;
    1d0e:	d8 01       	movw	r26, r16
    1d10:	18 96       	adiw	r26, 0x08	; 8
    1d12:	1c 92       	st	X, r1
    
    ResetFailStats();
    _pDBGPort       = 0;
    1d14:	04 5b       	subi	r16, 0xB4	; 180
    1d16:	1f 4f       	sbci	r17, 0xFF	; 255
    1d18:	d8 01       	movw	r26, r16
    1d1a:	1d 92       	st	X+, r1
    1d1c:	1d 92       	st	X+, r1
    1d1e:	8d 01       	movw	r16, r26
    _pDBGPort2      = 0;
    1d20:	1d 92       	st	X+, r1
    1d22:	1c 92       	st	X, r1
    _pNextIMU       = 0;
    1d24:	10 82       	st	Z, r1
    1d26:	11 82       	std	Z+1, r1	; 0x01
    _pTimer         = 0;
    1d28:	0b 50       	subi	r16, 0x0B	; 11
    1d2a:	10 40       	sbci	r17, 0x00	; 0
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	10 82       	st	Z, r1
    1d30:	11 82       	std	Z+1, r1	; 0x01
    1d32:	03 54       	subi	r16, 0x43	; 67
    1d34:	10 40       	sbci	r17, 0x00	; 0
    _bUseGyro       = false;
    1d36:	d8 01       	movw	r26, r16
    1d38:	58 96       	adiw	r26, 0x18	; 24
    1d3a:	1c 92       	st	X, r1
    _pMas->NotifyMe(this);
    1d3c:	b8 01       	movw	r22, r16
    1d3e:	6e 5f       	subi	r22, 0xFE	; 254
    1d40:	7f 4f       	sbci	r23, 0xFF	; 255
    1d42:	0e 94 2a 21 	call	0x4254	; 0x4254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>
    QueryChannels();
    1d46:	c8 01       	movw	r24, r16
    1d48:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <_ZN3IMU13QueryChannelsEv>
}
    1d4c:	1f 91       	pop	r17
    1d4e:	0f 91       	pop	r16
    1d50:	08 95       	ret

00001d52 <_ZN10IMUManagerC2EP14HardwareSerial>:
            }   \
        }   \
    }   \
    return bReady;

IMUManager::IMUManager(HardwareSerial* pSerial)
    1d52:	fc 01       	movw	r30, r24
    1d54:	8a ef       	ldi	r24, 0xFA	; 250
    1d56:	91 e2       	ldi	r25, 0x21	; 33
    1d58:	80 83       	st	Z, r24
    1d5a:	91 83       	std	Z+1, r25	; 0x01
{
    int x;
    for (x =0;x<4;x++) {
        _pIMU[x] = 0;
    1d5c:	12 82       	std	Z+2, r1	; 0x02
    1d5e:	13 82       	std	Z+3, r1	; 0x03
    1d60:	14 82       	std	Z+4, r1	; 0x04
    1d62:	15 82       	std	Z+5, r1	; 0x05
    1d64:	16 82       	std	Z+6, r1	; 0x06
    1d66:	17 82       	std	Z+7, r1	; 0x07
    1d68:	10 86       	std	Z+8, r1	; 0x08
    1d6a:	11 86       	std	Z+9, r1	; 0x09
    }
    
    _nIMUs          = 0;
    1d6c:	17 86       	std	Z+15, r1	; 0x0f
    _State          = sIdle;
    1d6e:	10 8a       	std	Z+16, r1	; 0x10
    _nStreamWDCounter = 0;
    1d70:	11 8a       	std	Z+17, r1	; 0x11
    1d72:	12 8a       	std	Z+18, r1	; 0x12
    _packetId       = 0;
    1d74:	13 8a       	std	Z+19, r1	; 0x13
    _pBlueLed       = 0;
    1d76:	12 86       	std	Z+10, r1	; 0x0a
    1d78:	13 86       	std	Z+11, r1	; 0x0b
    _bLedState      = false;
    1d7a:	15 86       	std	Z+13, r1	; 0x0d

    _pTimer         = 0;
    1d7c:	ee 57       	subi	r30, 0x7E	; 126
    1d7e:	ff 4f       	sbci	r31, 0xFF	; 255
    1d80:	11 92       	st	Z+, r1
    1d82:	11 92       	st	Z+, r1
    _pSerial        = pSerial;
    1d84:	61 93       	st	Z+, r22
    1d86:	71 93       	st	Z+, r23
    _pDBGPort       = 0;
    1d88:	11 92       	st	Z+, r1
    1d8a:	11 92       	st	Z+, r1
    _sampleRate     = 10;
    1d8c:	8a e0       	ldi	r24, 0x0A	; 10
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	81 93       	st	Z+, r24
    1d92:	91 93       	st	Z+, r25
    _maxMillisPerPacket = 1000;
    1d94:	88 ee       	ldi	r24, 0xE8	; 232
    1d96:	93 e0       	ldi	r25, 0x03	; 3
    1d98:	a0 e0       	ldi	r26, 0x00	; 0
    1d9a:	b0 e0       	ldi	r27, 0x00	; 0
    1d9c:	81 93       	st	Z+, r24
    1d9e:	91 93       	st	Z+, r25
    1da0:	a1 93       	st	Z+, r26
    1da2:	b1 93       	st	Z+, r27
    _lastSendMillis = 0;
    1da4:	10 82       	st	Z, r1
    1da6:	11 82       	std	Z+1, r1	; 0x01
    1da8:	12 82       	std	Z+2, r1	; 0x02
    1daa:	13 82       	std	Z+3, r1	; 0x03
} 
    1dac:	08 95       	ret

00001dae <_ZN10IMUManagerC1EP14HardwareSerial>:
            }   \
        }   \
    }   \
    return bReady;

IMUManager::IMUManager(HardwareSerial* pSerial)
    1dae:	fc 01       	movw	r30, r24
    1db0:	8a ef       	ldi	r24, 0xFA	; 250
    1db2:	91 e2       	ldi	r25, 0x21	; 33
    1db4:	80 83       	st	Z, r24
    1db6:	91 83       	std	Z+1, r25	; 0x01
{
    int x;
    for (x =0;x<4;x++) {
        _pIMU[x] = 0;
    1db8:	12 82       	std	Z+2, r1	; 0x02
    1dba:	13 82       	std	Z+3, r1	; 0x03
    1dbc:	14 82       	std	Z+4, r1	; 0x04
    1dbe:	15 82       	std	Z+5, r1	; 0x05
    1dc0:	16 82       	std	Z+6, r1	; 0x06
    1dc2:	17 82       	std	Z+7, r1	; 0x07
    1dc4:	10 86       	std	Z+8, r1	; 0x08
    1dc6:	11 86       	std	Z+9, r1	; 0x09
    }
    
    _nIMUs          = 0;
    1dc8:	17 86       	std	Z+15, r1	; 0x0f
    _State          = sIdle;
    1dca:	10 8a       	std	Z+16, r1	; 0x10
    _nStreamWDCounter = 0;
    1dcc:	11 8a       	std	Z+17, r1	; 0x11
    1dce:	12 8a       	std	Z+18, r1	; 0x12
    _packetId       = 0;
    1dd0:	13 8a       	std	Z+19, r1	; 0x13
    _pBlueLed       = 0;
    1dd2:	12 86       	std	Z+10, r1	; 0x0a
    1dd4:	13 86       	std	Z+11, r1	; 0x0b
    _bLedState      = false;
    1dd6:	15 86       	std	Z+13, r1	; 0x0d

    _pTimer         = 0;
    1dd8:	ee 57       	subi	r30, 0x7E	; 126
    1dda:	ff 4f       	sbci	r31, 0xFF	; 255
    1ddc:	11 92       	st	Z+, r1
    1dde:	11 92       	st	Z+, r1
    _pSerial        = pSerial;
    1de0:	61 93       	st	Z+, r22
    1de2:	71 93       	st	Z+, r23
    _pDBGPort       = 0;
    1de4:	11 92       	st	Z+, r1
    1de6:	11 92       	st	Z+, r1
    _sampleRate     = 10;
    1de8:	8a e0       	ldi	r24, 0x0A	; 10
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	81 93       	st	Z+, r24
    1dee:	91 93       	st	Z+, r25
    _maxMillisPerPacket = 1000;
    1df0:	88 ee       	ldi	r24, 0xE8	; 232
    1df2:	93 e0       	ldi	r25, 0x03	; 3
    1df4:	a0 e0       	ldi	r26, 0x00	; 0
    1df6:	b0 e0       	ldi	r27, 0x00	; 0
    1df8:	81 93       	st	Z+, r24
    1dfa:	91 93       	st	Z+, r25
    1dfc:	a1 93       	st	Z+, r26
    1dfe:	b1 93       	st	Z+, r27
    _lastSendMillis = 0;
    1e00:	10 82       	st	Z, r1
    1e02:	11 82       	std	Z+1, r1	; 0x01
    1e04:	12 82       	std	Z+2, r1	; 0x02
    1e06:	13 82       	std	Z+3, r1	; 0x03
} 
    1e08:	08 95       	ret

00001e0a <_ZN10IMUManager10SetBlueLedEP11PORT_structh>:

void IMUManager::SetBlueLed(PORT_t* port, uint8_t Pin)
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	db 01       	movw	r26, r22
{
    _pBlueLed   = port;
    1e0e:	62 87       	std	Z+10, r22	; 0x0a
    1e10:	73 87       	std	Z+11, r23	; 0x0b
    _LedPin     = Pin;
    1e12:	44 87       	std	Z+12, r20	; 0x0c
    
    _pBlueLed->DIRSET = _LedPin;
    1e14:	11 96       	adiw	r26, 0x01	; 1
    1e16:	4c 93       	st	X, r20
    _pBlueLed->OUTSET = _LedPin;
    1e18:	a2 85       	ldd	r26, Z+10	; 0x0a
    1e1a:	b3 85       	ldd	r27, Z+11	; 0x0b
    1e1c:	84 85       	ldd	r24, Z+12	; 0x0c
    1e1e:	15 96       	adiw	r26, 0x05	; 5
    1e20:	8c 93       	st	X, r24
    _bLedState        = false;
    1e22:	15 86       	std	Z+13, r1	; 0x0d
}
    1e24:	08 95       	ret

00001e26 <_ZN10IMUManager5LedOnEv>:

void IMUManager::LedOn()
    1e26:	fc 01       	movw	r30, r24
{
    _pBlueLed->OUTCLR   = _LedPin;
    1e28:	a2 85       	ldd	r26, Z+10	; 0x0a
    1e2a:	b3 85       	ldd	r27, Z+11	; 0x0b
    1e2c:	84 85       	ldd	r24, Z+12	; 0x0c
    1e2e:	16 96       	adiw	r26, 0x06	; 6
    1e30:	8c 93       	st	X, r24
    _bLedState          = true;
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	85 87       	std	Z+13, r24	; 0x0d
}
    1e36:	08 95       	ret

00001e38 <_ZN10IMUManager6LedOffEv>:

void IMUManager::LedOff()
    1e38:	fc 01       	movw	r30, r24
{
    _pBlueLed->OUTSET   = _LedPin;
    1e3a:	a2 85       	ldd	r26, Z+10	; 0x0a
    1e3c:	b3 85       	ldd	r27, Z+11	; 0x0b
    1e3e:	84 85       	ldd	r24, Z+12	; 0x0c
    1e40:	15 96       	adiw	r26, 0x05	; 5
    1e42:	8c 93       	st	X, r24
    _bLedState          = false;
    1e44:	15 86       	std	Z+13, r1	; 0x0d
}
    1e46:	08 95       	ret

00001e48 <_ZN10IMUManager18PacketLedIndicatorEv>:
//! This function is called once per stream data.
//! We are going to toggle this once for every 3
//! streams, this way it will be high/low each alternate
//! frame. This works if our packet rate is 3X the rate
//! of the camera. The camera is actually 59.94FPS 
void IMUManager::PacketLedIndicator()
    1e48:	fc 01       	movw	r30, r24
{
    if ((_packetId % 6) == 0) {
    1e4a:	83 89       	ldd	r24, Z+19	; 0x13
    1e4c:	66 e0       	ldi	r22, 0x06	; 6
    1e4e:	0e 94 41 49 	call	0x9282	; 0x9282 <__udivmodqi4>
    1e52:	99 23       	and	r25, r25
    1e54:	71 f4       	brne	.+28     	; 0x1e72 <_ZN10IMUManager18PacketLedIndicatorEv+0x2a>
}

//! Toggle the current Led State.
void IMUManager::ToggleLed()
{
    if ( _bLedState) {
    1e56:	85 85       	ldd	r24, Z+13	; 0x0d
    1e58:	a2 85       	ldd	r26, Z+10	; 0x0a
    1e5a:	b3 85       	ldd	r27, Z+11	; 0x0b
    1e5c:	94 85       	ldd	r25, Z+12	; 0x0c
    1e5e:	88 23       	and	r24, r24
    1e60:	21 f0       	breq	.+8      	; 0x1e6a <_ZN10IMUManager18PacketLedIndicatorEv+0x22>
        _bLedState = false;
    1e62:	15 86       	std	Z+13, r1	; 0x0d
        _pBlueLed->OUTCLR = _LedPin;
    1e64:	16 96       	adiw	r26, 0x06	; 6
    1e66:	9c 93       	st	X, r25
    1e68:	08 95       	ret
    } else {
        _bLedState = true;
    1e6a:	81 e0       	ldi	r24, 0x01	; 1
    1e6c:	85 87       	std	Z+13, r24	; 0x0d
        _pBlueLed->OUTSET = _LedPin;
    1e6e:	15 96       	adiw	r26, 0x05	; 5
    1e70:	9c 93       	st	X, r25
    1e72:	08 95       	ret

00001e74 <_ZN10IMUManager9ToggleLedEv>:
        ToggleLed();
    }
}

//! Toggle the current Led State.
void IMUManager::ToggleLed()
    1e74:	fc 01       	movw	r30, r24
{
    if ( _bLedState) {
    1e76:	85 85       	ldd	r24, Z+13	; 0x0d
    1e78:	a2 85       	ldd	r26, Z+10	; 0x0a
    1e7a:	b3 85       	ldd	r27, Z+11	; 0x0b
    1e7c:	94 85       	ldd	r25, Z+12	; 0x0c
    1e7e:	88 23       	and	r24, r24
    1e80:	21 f0       	breq	.+8      	; 0x1e8a <_ZN10IMUManager9ToggleLedEv+0x16>
        _bLedState = false;
    1e82:	15 86       	std	Z+13, r1	; 0x0d
        _pBlueLed->OUTCLR = _LedPin;
    1e84:	16 96       	adiw	r26, 0x06	; 6
    1e86:	9c 93       	st	X, r25
    1e88:	08 95       	ret
    } else {
        _bLedState = true;
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	85 87       	std	Z+13, r24	; 0x0d
        _pBlueLed->OUTSET = _LedPin;
    1e8e:	15 96       	adiw	r26, 0x05	; 5
    1e90:	9c 93       	st	X, r25
    1e92:	08 95       	ret

00001e94 <_ZN10IMUManager12ShowLedStartEv>:
    }
}

//! Flash the LED in a pattern to indicate stream starting
void IMUManager::ShowLedStart()
    1e94:	dc 01       	movw	r26, r24
{
    _pBlueLed->OUTCLR = _LedPin;
    1e96:	1a 96       	adiw	r26, 0x0a	; 10
    1e98:	ed 91       	ld	r30, X+
    1e9a:	fc 91       	ld	r31, X
    1e9c:	1b 97       	sbiw	r26, 0x0b	; 11
    1e9e:	1c 96       	adiw	r26, 0x0c	; 12
    1ea0:	8c 91       	ld	r24, X
    1ea2:	1c 97       	sbiw	r26, 0x0c	; 12
    1ea4:	86 83       	std	Z+6, r24	; 0x06
    1ea6:	84 ea       	ldi	r24, 0xA4	; 164
    1ea8:	96 e0       	ldi	r25, 0x06	; 6
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    1eaa:	20 e2       	ldi	r18, 0x20	; 32
    1eac:	33 e0       	ldi	r19, 0x03	; 3
    1eae:	f9 01       	movw	r30, r18
    1eb0:	31 97       	sbiw	r30, 0x01	; 1
    1eb2:	f1 f7       	brne	.-4      	; 0x1eb0 <_ZN10IMUManager12ShowLedStartEv+0x1c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1eb4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1eb6:	d9 f7       	brne	.-10     	; 0x1eae <_ZN10IMUManager12ShowLedStartEv+0x1a>
    _delay_ms(10*17); // One Frame
    _pBlueLed->OUTSET = _LedPin;
    1eb8:	1a 96       	adiw	r26, 0x0a	; 10
    1eba:	ed 91       	ld	r30, X+
    1ebc:	fc 91       	ld	r31, X
    1ebe:	1b 97       	sbiw	r26, 0x0b	; 11
    1ec0:	1c 96       	adiw	r26, 0x0c	; 12
    1ec2:	8c 91       	ld	r24, X
    1ec4:	1c 97       	sbiw	r26, 0x0c	; 12
    1ec6:	85 83       	std	Z+5, r24	; 0x05
    1ec8:	82 e5       	ldi	r24, 0x52	; 82
    1eca:	93 e0       	ldi	r25, 0x03	; 3
    1ecc:	20 e2       	ldi	r18, 0x20	; 32
    1ece:	33 e0       	ldi	r19, 0x03	; 3
    1ed0:	f9 01       	movw	r30, r18
    1ed2:	31 97       	sbiw	r30, 0x01	; 1
    1ed4:	f1 f7       	brne	.-4      	; 0x1ed2 <_ZN10IMUManager12ShowLedStartEv+0x3e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ed6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ed8:	d9 f7       	brne	.-10     	; 0x1ed0 <_ZN10IMUManager12ShowLedStartEv+0x3c>
    _delay_ms(5*17); // One Frame
    _pBlueLed->OUTCLR = _LedPin;
    1eda:	1a 96       	adiw	r26, 0x0a	; 10
    1edc:	ed 91       	ld	r30, X+
    1ede:	fc 91       	ld	r31, X
    1ee0:	1b 97       	sbiw	r26, 0x0b	; 11
    1ee2:	1c 96       	adiw	r26, 0x0c	; 12
    1ee4:	8c 91       	ld	r24, X
    1ee6:	1c 97       	sbiw	r26, 0x0c	; 12
    1ee8:	86 83       	std	Z+6, r24	; 0x06
    1eea:	84 ea       	ldi	r24, 0xA4	; 164
    1eec:	96 e0       	ldi	r25, 0x06	; 6
    1eee:	20 e2       	ldi	r18, 0x20	; 32
    1ef0:	33 e0       	ldi	r19, 0x03	; 3
    1ef2:	f9 01       	movw	r30, r18
    1ef4:	31 97       	sbiw	r30, 0x01	; 1
    1ef6:	f1 f7       	brne	.-4      	; 0x1ef4 <_ZN10IMUManager12ShowLedStartEv+0x60>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ef8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1efa:	d9 f7       	brne	.-10     	; 0x1ef2 <_ZN10IMUManager12ShowLedStartEv+0x5e>
    _delay_ms(10*17); // One Frame
    _pBlueLed->OUTSET = _LedPin;
    1efc:	1a 96       	adiw	r26, 0x0a	; 10
    1efe:	ed 91       	ld	r30, X+
    1f00:	fc 91       	ld	r31, X
    1f02:	1b 97       	sbiw	r26, 0x0b	; 11
    1f04:	1c 96       	adiw	r26, 0x0c	; 12
    1f06:	8c 91       	ld	r24, X
    1f08:	1c 97       	sbiw	r26, 0x0c	; 12
    1f0a:	85 83       	std	Z+5, r24	; 0x05
    1f0c:	8a ea       	ldi	r24, 0xAA	; 170
    1f0e:	90 e0       	ldi	r25, 0x00	; 0
    1f10:	20 e2       	ldi	r18, 0x20	; 32
    1f12:	33 e0       	ldi	r19, 0x03	; 3
    1f14:	f9 01       	movw	r30, r18
    1f16:	31 97       	sbiw	r30, 0x01	; 1
    1f18:	f1 f7       	brne	.-4      	; 0x1f16 <_ZN10IMUManager12ShowLedStartEv+0x82>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f1a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f1c:	d9 f7       	brne	.-10     	; 0x1f14 <_ZN10IMUManager12ShowLedStartEv+0x80>
    _delay_ms(17); // One Frame
    _bLedState        = false;
    1f1e:	1d 96       	adiw	r26, 0x0d	; 13
    1f20:	1c 92       	st	X, r1
}
    1f22:	08 95       	ret

00001f24 <_ZN10IMUManager11ShowLedStopEv>:

//! Flash the LED in a pattern to indicate stream stopped
void IMUManager::ShowLedStop()
    1f24:	dc 01       	movw	r26, r24
{
    _pBlueLed->OUTCLR = _LedPin;
    1f26:	1a 96       	adiw	r26, 0x0a	; 10
    1f28:	ed 91       	ld	r30, X+
    1f2a:	fc 91       	ld	r31, X
    1f2c:	1b 97       	sbiw	r26, 0x0b	; 11
    1f2e:	1c 96       	adiw	r26, 0x0c	; 12
    1f30:	8c 91       	ld	r24, X
    1f32:	1c 97       	sbiw	r26, 0x0c	; 12
    1f34:	86 83       	std	Z+6, r24	; 0x06
    1f36:	82 e5       	ldi	r24, 0x52	; 82
    1f38:	93 e0       	ldi	r25, 0x03	; 3
    1f3a:	20 e2       	ldi	r18, 0x20	; 32
    1f3c:	33 e0       	ldi	r19, 0x03	; 3
    1f3e:	f9 01       	movw	r30, r18
    1f40:	31 97       	sbiw	r30, 0x01	; 1
    1f42:	f1 f7       	brne	.-4      	; 0x1f40 <_ZN10IMUManager11ShowLedStopEv+0x1c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f44:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f46:	d9 f7       	brne	.-10     	; 0x1f3e <_ZN10IMUManager11ShowLedStopEv+0x1a>
    _delay_ms(5*17); // One Frame
    _pBlueLed->OUTSET = _LedPin;
    1f48:	1a 96       	adiw	r26, 0x0a	; 10
    1f4a:	ed 91       	ld	r30, X+
    1f4c:	fc 91       	ld	r31, X
    1f4e:	1b 97       	sbiw	r26, 0x0b	; 11
    1f50:	1c 96       	adiw	r26, 0x0c	; 12
    1f52:	8c 91       	ld	r24, X
    1f54:	1c 97       	sbiw	r26, 0x0c	; 12
    1f56:	85 83       	std	Z+5, r24	; 0x05
    1f58:	82 e5       	ldi	r24, 0x52	; 82
    1f5a:	93 e0       	ldi	r25, 0x03	; 3
    1f5c:	20 e2       	ldi	r18, 0x20	; 32
    1f5e:	33 e0       	ldi	r19, 0x03	; 3
    1f60:	f9 01       	movw	r30, r18
    1f62:	31 97       	sbiw	r30, 0x01	; 1
    1f64:	f1 f7       	brne	.-4      	; 0x1f62 <_ZN10IMUManager11ShowLedStopEv+0x3e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f66:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f68:	d9 f7       	brne	.-10     	; 0x1f60 <_ZN10IMUManager11ShowLedStopEv+0x3c>
    _delay_ms(5*17); // One Frame
    _pBlueLed->OUTCLR = _LedPin;
    1f6a:	1a 96       	adiw	r26, 0x0a	; 10
    1f6c:	ed 91       	ld	r30, X+
    1f6e:	fc 91       	ld	r31, X
    1f70:	1b 97       	sbiw	r26, 0x0b	; 11
    1f72:	1c 96       	adiw	r26, 0x0c	; 12
    1f74:	8c 91       	ld	r24, X
    1f76:	1c 97       	sbiw	r26, 0x0c	; 12
    1f78:	86 83       	std	Z+6, r24	; 0x06
    1f7a:	82 e5       	ldi	r24, 0x52	; 82
    1f7c:	93 e0       	ldi	r25, 0x03	; 3
    1f7e:	20 e2       	ldi	r18, 0x20	; 32
    1f80:	33 e0       	ldi	r19, 0x03	; 3
    1f82:	f9 01       	movw	r30, r18
    1f84:	31 97       	sbiw	r30, 0x01	; 1
    1f86:	f1 f7       	brne	.-4      	; 0x1f84 <_ZN10IMUManager11ShowLedStopEv+0x60>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f88:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f8a:	d9 f7       	brne	.-10     	; 0x1f82 <_ZN10IMUManager11ShowLedStopEv+0x5e>
    _delay_ms(5*17); // One Frame
    _pBlueLed->OUTSET = _LedPin;
    1f8c:	1a 96       	adiw	r26, 0x0a	; 10
    1f8e:	ed 91       	ld	r30, X+
    1f90:	fc 91       	ld	r31, X
    1f92:	1b 97       	sbiw	r26, 0x0b	; 11
    1f94:	1c 96       	adiw	r26, 0x0c	; 12
    1f96:	8c 91       	ld	r24, X
    1f98:	1c 97       	sbiw	r26, 0x0c	; 12
    1f9a:	85 83       	std	Z+5, r24	; 0x05
    1f9c:	82 e5       	ldi	r24, 0x52	; 82
    1f9e:	93 e0       	ldi	r25, 0x03	; 3
    1fa0:	20 e2       	ldi	r18, 0x20	; 32
    1fa2:	33 e0       	ldi	r19, 0x03	; 3
    1fa4:	f9 01       	movw	r30, r18
    1fa6:	31 97       	sbiw	r30, 0x01	; 1
    1fa8:	f1 f7       	brne	.-4      	; 0x1fa6 <_ZN10IMUManager11ShowLedStopEv+0x82>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1faa:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fac:	d9 f7       	brne	.-10     	; 0x1fa4 <_ZN10IMUManager11ShowLedStopEv+0x80>
    _delay_ms(5*17); // One Frame
    _pBlueLed->OUTCLR = _LedPin;
    1fae:	1a 96       	adiw	r26, 0x0a	; 10
    1fb0:	ed 91       	ld	r30, X+
    1fb2:	fc 91       	ld	r31, X
    1fb4:	1b 97       	sbiw	r26, 0x0b	; 11
    1fb6:	1c 96       	adiw	r26, 0x0c	; 12
    1fb8:	8c 91       	ld	r24, X
    1fba:	1c 97       	sbiw	r26, 0x0c	; 12
    1fbc:	86 83       	std	Z+6, r24	; 0x06
    _bLedState        = false;
    1fbe:	1d 96       	adiw	r26, 0x0d	; 13
    1fc0:	1c 92       	st	X, r1
}
    1fc2:	08 95       	ret

00001fc4 <_ZN10IMUManager6AddIMUEP7IMUBase>:
    _maxMillisPerPacket = 3 * 1000/_sampleRate;
    
    SetTimerPeriod();
}

int IMUManager::AddIMU(IMUBase* pIMU)
    1fc4:	0f 93       	push	r16
    1fc6:	1f 93       	push	r17
    1fc8:	cf 93       	push	r28
    1fca:	df 93       	push	r29
    1fcc:	8c 01       	movw	r16, r24
    1fce:	dc 01       	movw	r26, r24
    1fd0:	c0 e0       	ldi	r28, 0x00	; 0
    1fd2:	d0 e0       	ldi	r29, 0x00	; 0
{
    for (int x=0;x<4;x++) {
        if (_pIMU[x] == 0) {
    1fd4:	12 96       	adiw	r26, 0x02	; 2
    1fd6:	8d 91       	ld	r24, X+
    1fd8:	9c 91       	ld	r25, X
    1fda:	13 97       	sbiw	r26, 0x03	; 3
    1fdc:	fe 01       	movw	r30, r28
    1fde:	31 96       	adiw	r30, 0x01	; 1
    1fe0:	89 2b       	or	r24, r25
    1fe2:	e1 f4       	brne	.+56     	; 0x201c <_ZN10IMUManager6AddIMUEP7IMUBase+0x58>
            // Add into first empty spot
            _pIMU[x] = pIMU;
    1fe4:	ee 0f       	add	r30, r30
    1fe6:	ff 1f       	adc	r31, r31
    1fe8:	e0 0f       	add	r30, r16
    1fea:	f1 1f       	adc	r31, r17
    1fec:	60 83       	st	Z, r22
    1fee:	71 83       	std	Z+1, r23	; 0x01
            if (x > 0) {
    1ff0:	20 97       	sbiw	r28, 0x00	; 0
    1ff2:	79 f0       	breq	.+30     	; 0x2012 <_ZN10IMUManager6AddIMUEP7IMUBase+0x4e>
                _pIMU[x-1]->NextIMU(pIMU);
    1ff4:	fe 01       	movw	r30, r28
    1ff6:	ee 0f       	add	r30, r30
    1ff8:	ff 1f       	adc	r31, r31
    1ffa:	e0 0f       	add	r30, r16
    1ffc:	f1 1f       	adc	r31, r17
    1ffe:	a0 81       	ld	r26, Z
    2000:	b1 81       	ldd	r27, Z+1	; 0x01
    2002:	ed 91       	ld	r30, X+
    2004:	fc 91       	ld	r31, X
    2006:	11 97       	sbiw	r26, 0x01	; 1
    2008:	02 88       	ldd	r0, Z+18	; 0x12
    200a:	f3 89       	ldd	r31, Z+19	; 0x13
    200c:	e0 2d       	mov	r30, r0
    200e:	cd 01       	movw	r24, r26
    2010:	19 95       	eicall
            }
            _nIMUs++;
    2012:	f8 01       	movw	r30, r16
    2014:	87 85       	ldd	r24, Z+15	; 0x0f
    2016:	8f 5f       	subi	r24, 0xFF	; 255
    2018:	87 87       	std	Z+15, r24	; 0x0f
    201a:	07 c0       	rjmp	.+14     	; 0x202a <_ZN10IMUManager6AddIMUEP7IMUBase+0x66>
    SetTimerPeriod();
}

int IMUManager::AddIMU(IMUBase* pIMU)
{
    for (int x=0;x<4;x++) {
    201c:	ef 01       	movw	r28, r30
    201e:	12 96       	adiw	r26, 0x02	; 2
    2020:	e4 30       	cpi	r30, 0x04	; 4
    2022:	f1 05       	cpc	r31, r1
    2024:	b9 f6       	brne	.-82     	; 0x1fd4 <_ZN10IMUManager6AddIMUEP7IMUBase+0x10>
    2026:	cf ef       	ldi	r28, 0xFF	; 255
    2028:	df ef       	ldi	r29, 0xFF	; 255
        }
    }
    
    // Seems we are full!!
    return -1;
}
    202a:	ce 01       	movw	r24, r28
    202c:	df 91       	pop	r29
    202e:	cf 91       	pop	r28
    2030:	1f 91       	pop	r17
    2032:	0f 91       	pop	r16
    2034:	08 95       	ret

00002036 <_ZN10IMUManager5SetupEv>:

int IMUManager::Setup()
    2036:	0f 93       	push	r16
    2038:	1f 93       	push	r17
    203a:	cf 93       	push	r28
    203c:	df 93       	push	r29
    203e:	8c 01       	movw	r16, r24
    2040:	20 e0       	ldi	r18, 0x00	; 0
    2042:	30 e0       	ldi	r19, 0x00	; 0
    2044:	c0 e0       	ldi	r28, 0x00	; 0
    2046:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMURET(Setup);
    2048:	f8 01       	movw	r30, r16
    204a:	a2 81       	ldd	r26, Z+2	; 0x02
    204c:	b3 81       	ldd	r27, Z+3	; 0x03
    204e:	10 97       	sbiw	r26, 0x00	; 0
    2050:	59 f0       	breq	.+22     	; 0x2068 <_ZN10IMUManager5SetupEv+0x32>
    2052:	ed 91       	ld	r30, X+
    2054:	fc 91       	ld	r31, X
    2056:	11 97       	sbiw	r26, 0x01	; 1
    2058:	04 80       	ldd	r0, Z+4	; 0x04
    205a:	f5 81       	ldd	r31, Z+5	; 0x05
    205c:	e0 2d       	mov	r30, r0
    205e:	cd 01       	movw	r24, r26
    2060:	19 95       	eicall
    2062:	9c 01       	movw	r18, r24
    2064:	97 fd       	sbrc	r25, 7
    2066:	06 c0       	rjmp	.+12     	; 0x2074 <_ZN10IMUManager5SetupEv+0x3e>
    2068:	21 96       	adiw	r28, 0x01	; 1
    206a:	0e 5f       	subi	r16, 0xFE	; 254
    206c:	1f 4f       	sbci	r17, 0xFF	; 255
    206e:	c4 30       	cpi	r28, 0x04	; 4
    2070:	d1 05       	cpc	r29, r1
    2072:	51 f7       	brne	.-44     	; 0x2048 <_ZN10IMUManager5SetupEv+0x12>
}
    2074:	c9 01       	movw	r24, r18
    2076:	df 91       	pop	r29
    2078:	cf 91       	pop	r28
    207a:	1f 91       	pop	r17
    207c:	0f 91       	pop	r16
    207e:	08 95       	ret

00002080 <_ZN10IMUManager5StartEv>:

int IMUManager::Start()
    2080:	0f 93       	push	r16
    2082:	1f 93       	push	r17
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	8c 01       	movw	r16, r24
    208a:	20 e0       	ldi	r18, 0x00	; 0
    208c:	30 e0       	ldi	r19, 0x00	; 0
    208e:	c0 e0       	ldi	r28, 0x00	; 0
    2090:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMURET(Start);
    2092:	f8 01       	movw	r30, r16
    2094:	a2 81       	ldd	r26, Z+2	; 0x02
    2096:	b3 81       	ldd	r27, Z+3	; 0x03
    2098:	10 97       	sbiw	r26, 0x00	; 0
    209a:	59 f0       	breq	.+22     	; 0x20b2 <_ZN10IMUManager5StartEv+0x32>
    209c:	ed 91       	ld	r30, X+
    209e:	fc 91       	ld	r31, X
    20a0:	11 97       	sbiw	r26, 0x01	; 1
    20a2:	06 80       	ldd	r0, Z+6	; 0x06
    20a4:	f7 81       	ldd	r31, Z+7	; 0x07
    20a6:	e0 2d       	mov	r30, r0
    20a8:	cd 01       	movw	r24, r26
    20aa:	19 95       	eicall
    20ac:	9c 01       	movw	r18, r24
    20ae:	97 fd       	sbrc	r25, 7
    20b0:	06 c0       	rjmp	.+12     	; 0x20be <_ZN10IMUManager5StartEv+0x3e>
    20b2:	21 96       	adiw	r28, 0x01	; 1
    20b4:	0e 5f       	subi	r16, 0xFE	; 254
    20b6:	1f 4f       	sbci	r17, 0xFF	; 255
    20b8:	c4 30       	cpi	r28, 0x04	; 4
    20ba:	d1 05       	cpc	r29, r1
    20bc:	51 f7       	brne	.-44     	; 0x2092 <_ZN10IMUManager5StartEv+0x12>
}
    20be:	c9 01       	movw	r24, r18
    20c0:	df 91       	pop	r29
    20c2:	cf 91       	pop	r28
    20c4:	1f 91       	pop	r17
    20c6:	0f 91       	pop	r16
    20c8:	08 95       	ret

000020ca <_ZN10IMUManager4StopEv>:

void IMUManager::Stop()
    20ca:	ef 92       	push	r14
    20cc:	ff 92       	push	r15
    20ce:	0f 93       	push	r16
    20d0:	1f 93       	push	r17
    20d2:	cf 93       	push	r28
    20d4:	df 93       	push	r29
    20d6:	ec 01       	movw	r28, r24
    20d8:	7c 01       	movw	r14, r24
    20da:	00 e0       	ldi	r16, 0x00	; 0
    20dc:	10 e0       	ldi	r17, 0x00	; 0
{
    ALL_IMU(Stop);
    20de:	f7 01       	movw	r30, r14
    20e0:	a2 81       	ldd	r26, Z+2	; 0x02
    20e2:	b3 81       	ldd	r27, Z+3	; 0x03
    20e4:	10 97       	sbiw	r26, 0x00	; 0
    20e6:	41 f0       	breq	.+16     	; 0x20f8 <_ZN10IMUManager4StopEv+0x2e>
    20e8:	ed 91       	ld	r30, X+
    20ea:	fc 91       	ld	r31, X
    20ec:	11 97       	sbiw	r26, 0x01	; 1
    20ee:	00 84       	ldd	r0, Z+8	; 0x08
    20f0:	f1 85       	ldd	r31, Z+9	; 0x09
    20f2:	e0 2d       	mov	r30, r0
    20f4:	cd 01       	movw	r24, r26
    20f6:	19 95       	eicall
    20f8:	0f 5f       	subi	r16, 0xFF	; 255
    20fa:	1f 4f       	sbci	r17, 0xFF	; 255
    20fc:	82 e0       	ldi	r24, 0x02	; 2
    20fe:	90 e0       	ldi	r25, 0x00	; 0
    2100:	e8 0e       	add	r14, r24
    2102:	f9 1e       	adc	r15, r25
    2104:	04 30       	cpi	r16, 0x04	; 4
    2106:	11 05       	cpc	r17, r1
    2108:	51 f7       	brne	.-44     	; 0x20de <_ZN10IMUManager4StopEv+0x14>
    _State = sIdle;
    210a:	18 8a       	std	Y+16, r1	; 0x10
    ShowLedStop();  
    210c:	ce 01       	movw	r24, r28
    210e:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <_ZN10IMUManager11ShowLedStopEv>
    _bLedState          = true;
}

void IMUManager::LedOff()
{
    _pBlueLed->OUTSET   = _LedPin;
    2112:	ea 85       	ldd	r30, Y+10	; 0x0a
    2114:	fb 85       	ldd	r31, Y+11	; 0x0b
    2116:	8c 85       	ldd	r24, Y+12	; 0x0c
    2118:	85 83       	std	Z+5, r24	; 0x05
    _bLedState          = false;
    211a:	1d 86       	std	Y+13, r1	; 0x0d
{
    ALL_IMU(Stop);
    _State = sIdle;
    ShowLedStop();  
    LedOff();
}
    211c:	df 91       	pop	r29
    211e:	cf 91       	pop	r28
    2120:	1f 91       	pop	r17
    2122:	0f 91       	pop	r16
    2124:	ff 90       	pop	r15
    2126:	ef 90       	pop	r14
    2128:	08 95       	ret

0000212a <_ZN10IMUManager5ResetEv>:

void IMUManager::Reset()
    212a:	ef 92       	push	r14
    212c:	ff 92       	push	r15
    212e:	0f 93       	push	r16
    2130:	1f 93       	push	r17
    2132:	cf 93       	push	r28
    2134:	df 93       	push	r29
    2136:	7c 01       	movw	r14, r24
    2138:	8c 01       	movw	r16, r24
    213a:	c0 e0       	ldi	r28, 0x00	; 0
    213c:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMU(Reset);
    213e:	f8 01       	movw	r30, r16
    2140:	a2 81       	ldd	r26, Z+2	; 0x02
    2142:	b3 81       	ldd	r27, Z+3	; 0x03
    2144:	10 97       	sbiw	r26, 0x00	; 0
    2146:	41 f0       	breq	.+16     	; 0x2158 <_ZN10IMUManager5ResetEv+0x2e>
    2148:	ed 91       	ld	r30, X+
    214a:	fc 91       	ld	r31, X
    214c:	11 97       	sbiw	r26, 0x01	; 1
    214e:	01 90       	ld	r0, Z+
    2150:	f0 81       	ld	r31, Z
    2152:	e0 2d       	mov	r30, r0
    2154:	cd 01       	movw	r24, r26
    2156:	19 95       	eicall
    2158:	21 96       	adiw	r28, 0x01	; 1
    215a:	0e 5f       	subi	r16, 0xFE	; 254
    215c:	1f 4f       	sbci	r17, 0xFF	; 255
    215e:	c4 30       	cpi	r28, 0x04	; 4
    2160:	d1 05       	cpc	r29, r1
    2162:	69 f7       	brne	.-38     	; 0x213e <_ZN10IMUManager5ResetEv+0x14>
    
    _State = sIdle; 
    2164:	f7 01       	movw	r30, r14
    2166:	10 8a       	std	Z+16, r1	; 0x10
    _packetId       = 0;
    2168:	13 8a       	std	Z+19, r1	; 0x13
}
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	1f 91       	pop	r17
    2170:	0f 91       	pop	r16
    2172:	ff 90       	pop	r15
    2174:	ef 90       	pop	r14
    2176:	08 95       	ret

00002178 <_ZN10IMUManager12ResetDevicesEv>:

void IMUManager::ResetDevices()
    2178:	0f 93       	push	r16
    217a:	1f 93       	push	r17
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	8c 01       	movw	r16, r24
    2182:	c0 e0       	ldi	r28, 0x00	; 0
    2184:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMU(ResetDevices);
    2186:	f8 01       	movw	r30, r16
    2188:	a2 81       	ldd	r26, Z+2	; 0x02
    218a:	b3 81       	ldd	r27, Z+3	; 0x03
    218c:	10 97       	sbiw	r26, 0x00	; 0
    218e:	41 f0       	breq	.+16     	; 0x21a0 <_ZN10IMUManager12ResetDevicesEv+0x28>
    2190:	ed 91       	ld	r30, X+
    2192:	fc 91       	ld	r31, X
    2194:	11 97       	sbiw	r26, 0x01	; 1
    2196:	04 8c       	ldd	r0, Z+28	; 0x1c
    2198:	f5 8d       	ldd	r31, Z+29	; 0x1d
    219a:	e0 2d       	mov	r30, r0
    219c:	cd 01       	movw	r24, r26
    219e:	19 95       	eicall
    21a0:	21 96       	adiw	r28, 0x01	; 1
    21a2:	0e 5f       	subi	r16, 0xFE	; 254
    21a4:	1f 4f       	sbci	r17, 0xFF	; 255
    21a6:	c4 30       	cpi	r28, 0x04	; 4
    21a8:	d1 05       	cpc	r29, r1
    21aa:	69 f7       	brne	.-38     	; 0x2186 <_ZN10IMUManager12ResetDevicesEv+0xe>
}
    21ac:	df 91       	pop	r29
    21ae:	cf 91       	pop	r28
    21b0:	1f 91       	pop	r17
    21b2:	0f 91       	pop	r16
    21b4:	08 95       	ret

000021b6 <_ZN10IMUManager14ForceStartStopEv>:

void IMUManager::ForceStartStop()
    21b6:	0f 93       	push	r16
    21b8:	1f 93       	push	r17
    21ba:	cf 93       	push	r28
    21bc:	df 93       	push	r29
    21be:	8c 01       	movw	r16, r24
    21c0:	c0 e0       	ldi	r28, 0x00	; 0
    21c2:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMU(ForceStartStop);
    21c4:	f8 01       	movw	r30, r16
    21c6:	a2 81       	ldd	r26, Z+2	; 0x02
    21c8:	b3 81       	ldd	r27, Z+3	; 0x03
    21ca:	10 97       	sbiw	r26, 0x00	; 0
    21cc:	41 f0       	breq	.+16     	; 0x21de <_ZN10IMUManager14ForceStartStopEv+0x28>
    21ce:	ed 91       	ld	r30, X+
    21d0:	fc 91       	ld	r31, X
    21d2:	11 97       	sbiw	r26, 0x01	; 1
    21d4:	02 84       	ldd	r0, Z+10	; 0x0a
    21d6:	f3 85       	ldd	r31, Z+11	; 0x0b
    21d8:	e0 2d       	mov	r30, r0
    21da:	cd 01       	movw	r24, r26
    21dc:	19 95       	eicall
    21de:	21 96       	adiw	r28, 0x01	; 1
    21e0:	0e 5f       	subi	r16, 0xFE	; 254
    21e2:	1f 4f       	sbci	r17, 0xFF	; 255
    21e4:	c4 30       	cpi	r28, 0x04	; 4
    21e6:	d1 05       	cpc	r29, r1
    21e8:	69 f7       	brne	.-38     	; 0x21c4 <_ZN10IMUManager14ForceStartStopEv+0xe>
}
    21ea:	df 91       	pop	r29
    21ec:	cf 91       	pop	r28
    21ee:	1f 91       	pop	r17
    21f0:	0f 91       	pop	r16
    21f2:	08 95       	ret

000021f4 <_ZN10IMUManager8CheckIDsEP14HardwareSeriali>:

// Diagnostic Routines
void IMUManager::CheckIDs(HardwareSerial* pSerial,int idx)
    21f4:	ef 92       	push	r14
    21f6:	ff 92       	push	r15
    21f8:	0f 93       	push	r16
    21fa:	1f 93       	push	r17
    21fc:	cf 93       	push	r28
    21fe:	df 93       	push	r29
    2200:	fc 01       	movw	r30, r24
    2202:	7b 01       	movw	r14, r22
{
    if (idx < 0) {
    2204:	57 ff       	sbrs	r21, 7
    2206:	18 c0       	rjmp	.+48     	; 0x2238 <_ZN10IMUManager8CheckIDsEP14HardwareSeriali+0x44>
    2208:	8c 01       	movw	r16, r24
    220a:	c0 e0       	ldi	r28, 0x00	; 0
    220c:	d0 e0       	ldi	r29, 0x00	; 0
        ALL_IMUP(CheckIDs,pSerial);
    220e:	f8 01       	movw	r30, r16
    2210:	a2 81       	ldd	r26, Z+2	; 0x02
    2212:	b3 81       	ldd	r27, Z+3	; 0x03
    2214:	10 97       	sbiw	r26, 0x00	; 0
    2216:	49 f0       	breq	.+18     	; 0x222a <_ZN10IMUManager8CheckIDsEP14HardwareSeriali+0x36>
    2218:	ed 91       	ld	r30, X+
    221a:	fc 91       	ld	r31, X
    221c:	11 97       	sbiw	r26, 0x01	; 1
    221e:	02 8c       	ldd	r0, Z+26	; 0x1a
    2220:	f3 8d       	ldd	r31, Z+27	; 0x1b
    2222:	e0 2d       	mov	r30, r0
    2224:	cd 01       	movw	r24, r26
    2226:	b7 01       	movw	r22, r14
    2228:	19 95       	eicall
    222a:	21 96       	adiw	r28, 0x01	; 1
    222c:	0e 5f       	subi	r16, 0xFE	; 254
    222e:	1f 4f       	sbci	r17, 0xFF	; 255
    2230:	c4 30       	cpi	r28, 0x04	; 4
    2232:	d1 05       	cpc	r29, r1
    2234:	61 f7       	brne	.-40     	; 0x220e <_ZN10IMUManager8CheckIDsEP14HardwareSeriali+0x1a>
    2236:	12 c0       	rjmp	.+36     	; 0x225c <_ZN10IMUManager8CheckIDsEP14HardwareSeriali+0x68>
    } else {
        if (_pIMU[idx]) {
    2238:	4f 5f       	subi	r20, 0xFF	; 255
    223a:	5f 4f       	sbci	r21, 0xFF	; 255
    223c:	44 0f       	add	r20, r20
    223e:	55 1f       	adc	r21, r21
    2240:	e4 0f       	add	r30, r20
    2242:	f5 1f       	adc	r31, r21
    2244:	a0 81       	ld	r26, Z
    2246:	b1 81       	ldd	r27, Z+1	; 0x01
    2248:	10 97       	sbiw	r26, 0x00	; 0
    224a:	41 f0       	breq	.+16     	; 0x225c <_ZN10IMUManager8CheckIDsEP14HardwareSeriali+0x68>
            _pIMU[idx]->CheckIDs(pSerial);
    224c:	ed 91       	ld	r30, X+
    224e:	fc 91       	ld	r31, X
    2250:	11 97       	sbiw	r26, 0x01	; 1
    2252:	02 8c       	ldd	r0, Z+26	; 0x1a
    2254:	f3 8d       	ldd	r31, Z+27	; 0x1b
    2256:	e0 2d       	mov	r30, r0
    2258:	cd 01       	movw	r24, r26
    225a:	19 95       	eicall
        }
    }
}
    225c:	df 91       	pop	r29
    225e:	cf 91       	pop	r28
    2260:	1f 91       	pop	r17
    2262:	0f 91       	pop	r16
    2264:	ff 90       	pop	r15
    2266:	ef 90       	pop	r14
    2268:	08 95       	ret

0000226a <_ZN10IMUManager9DataReadyEv>:

//! Check if all IMU's have data.
bool IMUManager::DataReady()
    226a:	ff 92       	push	r15
    226c:	0f 93       	push	r16
    226e:	1f 93       	push	r17
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
    2274:	8c 01       	movw	r16, r24
    2276:	ff 24       	eor	r15, r15
    2278:	f3 94       	inc	r15
    227a:	c0 e0       	ldi	r28, 0x00	; 0
    227c:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMUBOOL(DataReady)
    227e:	f8 01       	movw	r30, r16
    2280:	a2 81       	ldd	r26, Z+2	; 0x02
    2282:	b3 81       	ldd	r27, Z+3	; 0x03
    2284:	10 97       	sbiw	r26, 0x00	; 0
    2286:	59 f0       	breq	.+22     	; 0x229e <_ZN10IMUManager9DataReadyEv+0x34>
    2288:	ed 91       	ld	r30, X+
    228a:	fc 91       	ld	r31, X
    228c:	11 97       	sbiw	r26, 0x01	; 1
    228e:	06 88       	ldd	r0, Z+22	; 0x16
    2290:	f7 89       	ldd	r31, Z+23	; 0x17
    2292:	e0 2d       	mov	r30, r0
    2294:	cd 01       	movw	r24, r26
    2296:	19 95       	eicall
    2298:	88 23       	and	r24, r24
    229a:	09 f4       	brne	.+2      	; 0x229e <_ZN10IMUManager9DataReadyEv+0x34>
    229c:	ff 24       	eor	r15, r15
    229e:	21 96       	adiw	r28, 0x01	; 1
    22a0:	0e 5f       	subi	r16, 0xFE	; 254
    22a2:	1f 4f       	sbci	r17, 0xFF	; 255
    22a4:	c4 30       	cpi	r28, 0x04	; 4
    22a6:	d1 05       	cpc	r29, r1
    22a8:	51 f7       	brne	.-44     	; 0x227e <_ZN10IMUManager9DataReadyEv+0x14>
}
    22aa:	8f 2d       	mov	r24, r15
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	ff 90       	pop	r15
    22b6:	08 95       	ret

000022b8 <_ZN10IMUManager10IMUUseGyroEb>:

void IMUManager::IMUUseGyro(bool bEn)
    22b8:	ff 92       	push	r15
    22ba:	0f 93       	push	r16
    22bc:	1f 93       	push	r17
    22be:	cf 93       	push	r28
    22c0:	df 93       	push	r29
    22c2:	f6 2e       	mov	r15, r22
    22c4:	8c 01       	movw	r16, r24
    22c6:	c0 e0       	ldi	r28, 0x00	; 0
    22c8:	d0 e0       	ldi	r29, 0x00	; 0
{
    ALL_IMUP(UseGyro,bEn);
    22ca:	f8 01       	movw	r30, r16
    22cc:	a2 81       	ldd	r26, Z+2	; 0x02
    22ce:	b3 81       	ldd	r27, Z+3	; 0x03
    22d0:	10 97       	sbiw	r26, 0x00	; 0
    22d2:	49 f0       	breq	.+18     	; 0x22e6 <_ZN10IMUManager10IMUUseGyroEb+0x2e>
    22d4:	ed 91       	ld	r30, X+
    22d6:	fc 91       	ld	r31, X
    22d8:	11 97       	sbiw	r26, 0x01	; 1
    22da:	00 88       	ldd	r0, Z+16	; 0x10
    22dc:	f1 89       	ldd	r31, Z+17	; 0x11
    22de:	e0 2d       	mov	r30, r0
    22e0:	cd 01       	movw	r24, r26
    22e2:	6f 2d       	mov	r22, r15
    22e4:	19 95       	eicall
    22e6:	21 96       	adiw	r28, 0x01	; 1
    22e8:	0e 5f       	subi	r16, 0xFE	; 254
    22ea:	1f 4f       	sbci	r17, 0xFF	; 255
    22ec:	c4 30       	cpi	r28, 0x04	; 4
    22ee:	d1 05       	cpc	r29, r1
    22f0:	61 f7       	brne	.-40     	; 0x22ca <_ZN10IMUManager10IMUUseGyroEb+0x12>
}
    22f2:	df 91       	pop	r29
    22f4:	cf 91       	pop	r28
    22f6:	1f 91       	pop	r17
    22f8:	0f 91       	pop	r16
    22fa:	ff 90       	pop	r15
    22fc:	08 95       	ret

000022fe <_ZN10IMUManager14StreamWatchdogEv>:
    return 0;
}

void IMUManager::StreamWatchdog()
{
    _nStreamWDCounter = 20;
    22fe:	24 e1       	ldi	r18, 0x14	; 20
    2300:	30 e0       	ldi	r19, 0x00	; 0
    2302:	fc 01       	movw	r30, r24
    2304:	21 8b       	std	Z+17, r18	; 0x11
    2306:	32 8b       	std	Z+18, r19	; 0x12
}
    2308:	08 95       	ret

0000230a <_ZN10IMUManager3RunEv>:
    }
    
    return 0;
}

void IMUManager::Run()
    230a:	fc 01       	movw	r30, r24
{
    if (_State != sIdle) {
    230c:	80 89       	ldd	r24, Z+16	; 0x10
    230e:	88 23       	and	r24, r24
    2310:	61 f0       	breq	.+24     	; 0x232a <_ZN10IMUManager3RunEv+0x20>
        // Start the IMU's going one at a time...
        if (_pIMU[0]) {
    2312:	a2 81       	ldd	r26, Z+2	; 0x02
    2314:	b3 81       	ldd	r27, Z+3	; 0x03
    2316:	10 97       	sbiw	r26, 0x00	; 0
    2318:	41 f0       	breq	.+16     	; 0x232a <_ZN10IMUManager3RunEv+0x20>
            _pIMU[0]->BeginRead();
    231a:	ed 91       	ld	r30, X+
    231c:	fc 91       	ld	r31, X
    231e:	11 97       	sbiw	r26, 0x01	; 1
    2320:	04 88       	ldd	r0, Z+20	; 0x14
    2322:	f5 89       	ldd	r31, Z+21	; 0x15
    2324:	e0 2d       	mov	r30, r0
    2326:	cd 01       	movw	r24, r26
    2328:	19 95       	eicall
    232a:	08 95       	ret

0000232c <_ZN10IMUManager11DiscardDataEv>:
    buffer[6+size+2] = crclo;
    sprintf((char*)&buffer[6+size+3],"END\n");
    _pSerial->write(&buffer[0],6+size+3+4);
}

void IMUManager::DiscardData()
    232c:	0f 93       	push	r16
    232e:	1f 93       	push	r17
    2330:	cf 93       	push	r28
    2332:	df 93       	push	r29
{
    uint8_t*    pPacket = &_dataPacket[0];
    2334:	bc 01       	movw	r22, r24
    2336:	6c 5e       	subi	r22, 0xEC	; 236
    2338:	7f 4f       	sbci	r23, 0xFF	; 255
    233a:	8c 01       	movw	r16, r24
    233c:	c0 e0       	ldi	r28, 0x00	; 0
    233e:	d0 e0       	ldi	r29, 0x00	; 0
    for (int x = 0;x<4;x++) {
        if (_pIMU[x]) {
    2340:	f8 01       	movw	r30, r16
    2342:	a2 81       	ldd	r26, Z+2	; 0x02
    2344:	b3 81       	ldd	r27, Z+3	; 0x03
    2346:	10 97       	sbiw	r26, 0x00	; 0
    2348:	49 f0       	breq	.+18     	; 0x235c <_ZN10IMUManager11DiscardDataEv+0x30>
            // This puts the data at the pointer,
            // then returns the end of the data.
            // This might be 2*14 or 1*14
            pPacket = _pIMU[x]->GetPacketData(pPacket);
    234a:	ed 91       	ld	r30, X+
    234c:	fc 91       	ld	r31, X
    234e:	11 97       	sbiw	r26, 0x01	; 1
    2350:	00 8c       	ldd	r0, Z+24	; 0x18
    2352:	f1 8d       	ldd	r31, Z+25	; 0x19
    2354:	e0 2d       	mov	r30, r0
    2356:	cd 01       	movw	r24, r26
    2358:	19 95       	eicall
    235a:	bc 01       	movw	r22, r24
}

void IMUManager::DiscardData()
{
    uint8_t*    pPacket = &_dataPacket[0];
    for (int x = 0;x<4;x++) {
    235c:	21 96       	adiw	r28, 0x01	; 1
    235e:	0e 5f       	subi	r16, 0xFE	; 254
    2360:	1f 4f       	sbci	r17, 0xFF	; 255
    2362:	c4 30       	cpi	r28, 0x04	; 4
    2364:	d1 05       	cpc	r29, r1
    2366:	61 f7       	brne	.-40     	; 0x2340 <_ZN10IMUManager11DiscardDataEv+0x14>
            // then returns the end of the data.
            // This might be 2*14 or 1*14
            pPacket = _pIMU[x]->GetPacketData(pPacket);
        }
    }
}
    2368:	df 91       	pop	r29
    236a:	cf 91       	pop	r28
    236c:	1f 91       	pop	r17
    236e:	0f 91       	pop	r16
    2370:	08 95       	ret

00002372 <_ZN10IMUManager3errEh>:
//@{

//! Timer Error - ignored.
void IMUManager::err(uint8_t id)
{
}
    2372:	08 95       	ret

00002374 <_ZN10IMUManager3ovfEh>:
//! Overflow fires when the timer reaches the top period value.
//! This is setup to fire when we get a timer tick, with a default rate of 500us
//! IMUManager has only one Timer so the ID is not needed.
void IMUManager::ovf(uint8_t id)
{
    Run();
    2374:	0e 94 85 11 	call	0x230a	; 0x230a <_ZN10IMUManager3RunEv>
}
    2378:	08 95       	ret

0000237a <_ZN10IMUManager3ccxEhh>:

//! Timer Capture Compare - not used.
void IMUManager::ccx(uint8_t id,uint8_t idx)
{
}
    237a:	08 95       	ret

0000237c <_ZN10IMUManager14SetTimerPeriodEv>:
    _pTimer->IntLvlA(0,1);
    _pTimer->IntLvlB(0);
    _pTimer->Notify(this,0);
}

void IMUManager::SetTimerPeriod()
    237c:	cf 92       	push	r12
    237e:	df 92       	push	r13
    2380:	ef 92       	push	r14
    2382:	ff 92       	push	r15
    2384:	0f 93       	push	r16
    2386:	1f 93       	push	r17
    2388:	df 93       	push	r29
    238a:	cf 93       	push	r28
    238c:	cd b7       	in	r28, 0x3d	; 61
    238e:	de b7       	in	r29, 0x3e	; 62
    2390:	e2 97       	sbiw	r28, 0x32	; 50
    2392:	cd bf       	out	0x3d, r28	; 61
    2394:	de bf       	out	0x3e, r29	; 62
    2396:	7c 01       	movw	r14, r24
    // We set the timer to go off 5 times per IMU period.
    // This should range from 20ms for 10Hz, and 1 ms for 200
    // **** NoFifo
    // Set timer to fire at the rate.
    //unsigned long timerTicks = 100000/_Rate;
    unsigned int timerTicks = 500000/_sampleRate;
    2398:	88 e8       	ldi	r24, 0x88	; 136
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	e8 0e       	add	r14, r24
    239e:	f9 1e       	adc	r15, r25
    23a0:	d7 01       	movw	r26, r14
    23a2:	2d 91       	ld	r18, X+
    23a4:	3c 91       	ld	r19, X
    23a6:	e8 e7       	ldi	r30, 0x78	; 120
    23a8:	ff ef       	ldi	r31, 0xFF	; 255
    23aa:	ee 0e       	add	r14, r30
    23ac:	ff 1e       	adc	r15, r31
    // then this will assume I am trying to sync with the camera
    // which has a frame rate of 59.94. 3X this is 179.82.
    // Setting this timer ticks value will put our IMU rate
    // close to 3x the frame rate of the camera, which is what
    // we want.
    if (_sampleRate == 180) {
    23ae:	24 3b       	cpi	r18, 0xB4	; 180
    23b0:	31 05       	cpc	r19, r1
    23b2:	29 f4       	brne	.+10     	; 0x23be <_ZN10IMUManager14SetTimerPeriodEv+0x42>
    23b4:	4c ed       	ldi	r20, 0xDC	; 220
    23b6:	c4 2e       	mov	r12, r20
    23b8:	4a e0       	ldi	r20, 0x0A	; 10
    23ba:	d4 2e       	mov	r13, r20
    23bc:	11 c0       	rjmp	.+34     	; 0x23e0 <_ZN10IMUManager14SetTimerPeriodEv+0x64>
    // We set the timer to go off 5 times per IMU period.
    // This should range from 20ms for 10Hz, and 1 ms for 200
    // **** NoFifo
    // Set timer to fire at the rate.
    //unsigned long timerTicks = 100000/_Rate;
    unsigned int timerTicks = 500000/_sampleRate;
    23be:	40 e0       	ldi	r20, 0x00	; 0
    23c0:	50 e0       	ldi	r21, 0x00	; 0
    23c2:	60 e2       	ldi	r22, 0x20	; 32
    23c4:	71 ea       	ldi	r23, 0xA1	; 161
    23c6:	87 e0       	ldi	r24, 0x07	; 7
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	0e 94 96 49 	call	0x932c	; 0x932c <__divmodsi4>
    23ce:	69 01       	movw	r12, r18
    23d0:	fd ef       	ldi	r31, 0xFD	; 253
    23d2:	29 3e       	cpi	r18, 0xE9	; 233
    23d4:	3f 07       	cpc	r19, r31
    23d6:	20 f0       	brcs	.+8      	; 0x23e0 <_ZN10IMUManager14SetTimerPeriodEv+0x64>
    23d8:	38 ee       	ldi	r19, 0xE8	; 232
    23da:	c3 2e       	mov	r12, r19
    23dc:	3d ef       	ldi	r19, 0xFD	; 253
    23de:	d3 2e       	mov	r13, r19
    // close to 3x the frame rate of the camera, which is what
    // we want.
    if (_sampleRate == 180) {
        timerTicks = 2780;
    }
    if (pdbgserial) {
    23e0:	80 91 2a 26 	lds	r24, 0x262A
    23e4:	90 91 2b 26 	lds	r25, 0x262B
    23e8:	89 2b       	or	r24, r25
    23ea:	11 f1       	breq	.+68     	; 0x2430 <_ZN10IMUManager14SetTimerPeriodEv+0xb4>
        char buffer[50];
        sprintf(buffer,"Timer Period:%u\n",timerTicks);
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <_ZN10IMUManager14SetTimerPeriodEv+0x72>
    23ee:	00 d0       	rcall	.+0      	; 0x23f0 <_ZN10IMUManager14SetTimerPeriodEv+0x74>
    23f0:	ed b7       	in	r30, 0x3d	; 61
    23f2:	fe b7       	in	r31, 0x3e	; 62
    23f4:	31 96       	adiw	r30, 0x01	; 1
    23f6:	8e 01       	movw	r16, r28
    23f8:	0f 5f       	subi	r16, 0xFF	; 255
    23fa:	1f 4f       	sbci	r17, 0xFF	; 255
    23fc:	ad b7       	in	r26, 0x3d	; 61
    23fe:	be b7       	in	r27, 0x3e	; 62
    2400:	11 96       	adiw	r26, 0x01	; 1
    2402:	0d 93       	st	X+, r16
    2404:	1c 93       	st	X, r17
    2406:	12 97       	sbiw	r26, 0x02	; 2
    2408:	89 ec       	ldi	r24, 0xC9	; 201
    240a:	91 e2       	ldi	r25, 0x21	; 33
    240c:	82 83       	std	Z+2, r24	; 0x02
    240e:	93 83       	std	Z+3, r25	; 0x03
    2410:	c4 82       	std	Z+4, r12	; 0x04
    2412:	d5 82       	std	Z+5, r13	; 0x05
    2414:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
        pdbgserial->print(buffer);
    2418:	ed b7       	in	r30, 0x3d	; 61
    241a:	fe b7       	in	r31, 0x3e	; 62
    241c:	36 96       	adiw	r30, 0x06	; 6
    241e:	ed bf       	out	0x3d, r30	; 61
    2420:	fe bf       	out	0x3e, r31	; 62
    2422:	80 91 2a 26 	lds	r24, 0x262A
    2426:	90 91 2b 26 	lds	r25, 0x262B
    242a:	b8 01       	movw	r22, r16
    242c:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    }
    if (_pTimer) _pTimer->Period(timerTicks);
    2430:	82 e8       	ldi	r24, 0x82	; 130
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	e8 0e       	add	r14, r24
    2436:	f9 1e       	adc	r15, r25
    2438:	d7 01       	movw	r26, r14
    243a:	8d 91       	ld	r24, X+
    243c:	9c 91       	ld	r25, X
    243e:	00 97       	sbiw	r24, 0x00	; 0
    2440:	19 f0       	breq	.+6      	; 0x2448 <_ZN10IMUManager14SetTimerPeriodEv+0xcc>
    2442:	b6 01       	movw	r22, r12
    2444:	0e 94 fb 32 	call	0x65f6	; 0x65f6 <_ZN9TimerCntr6PeriodEj>
}
    2448:	e2 96       	adiw	r28, 0x32	; 50
    244a:	cd bf       	out	0x3d, r28	; 61
    244c:	de bf       	out	0x3e, r29	; 62
    244e:	cf 91       	pop	r28
    2450:	df 91       	pop	r29
    2452:	1f 91       	pop	r17
    2454:	0f 91       	pop	r16
    2456:	ff 90       	pop	r15
    2458:	ef 90       	pop	r14
    245a:	df 90       	pop	r13
    245c:	cf 90       	pop	r12
    245e:	08 95       	ret

00002460 <_ZN10IMUManager10SampleRateEj>:
    _delay_ms(5*17); // One Frame
    _pBlueLed->OUTCLR = _LedPin;
    _bLedState        = false;
}

void IMUManager::SampleRate(uint16_t rate)
    2460:	af 92       	push	r10
    2462:	bf 92       	push	r11
    2464:	cf 92       	push	r12
    2466:	df 92       	push	r13
    2468:	ef 92       	push	r14
    246a:	ff 92       	push	r15
    246c:	0f 93       	push	r16
    246e:	1f 93       	push	r17
    2470:	df 93       	push	r29
    2472:	cf 93       	push	r28
    2474:	cd b7       	in	r28, 0x3d	; 61
    2476:	de b7       	in	r29, 0x3e	; 62
    2478:	e2 97       	sbiw	r28, 0x32	; 50
    247a:	cd bf       	out	0x3d, r28	; 61
    247c:	de bf       	out	0x3e, r29	; 62
    247e:	7c 01       	movw	r14, r24
{
    // Range Limit the rate.
    if (rate < 10) {
    2480:	6a 30       	cpi	r22, 0x0A	; 10
    2482:	71 05       	cpc	r23, r1
    2484:	c8 f4       	brcc	.+50     	; 0x24b8 <_ZN10IMUManager10SampleRateEj+0x58>
        _sampleRate = 10;
    2486:	28 e8       	ldi	r18, 0x88	; 136
    2488:	30 e0       	ldi	r19, 0x00	; 0
    248a:	e2 0e       	add	r14, r18
    248c:	f3 1e       	adc	r15, r19
    248e:	8a e0       	ldi	r24, 0x0A	; 10
    2490:	90 e0       	ldi	r25, 0x00	; 0
    2492:	d7 01       	movw	r26, r14
    2494:	8d 93       	st	X+, r24
    2496:	9c 93       	st	X, r25
    2498:	e8 e7       	ldi	r30, 0x78	; 120
    249a:	ff ef       	ldi	r31, 0xFF	; 255
    249c:	ee 0e       	add	r14, r30
    249e:	ff 1e       	adc	r15, r31
    24a0:	87 01       	movw	r16, r14
        _sampleRate = 200;
    } else {
        _sampleRate = rate;
    }

    ALL_IMUP(SampleRate,_sampleRate);
    24a2:	68 e8       	ldi	r22, 0x88	; 136
    24a4:	a6 2e       	mov	r10, r22
    24a6:	b1 2c       	mov	r11, r1
    24a8:	ae 0c       	add	r10, r14
    24aa:	bf 1c       	adc	r11, r15
    24ac:	58 e0       	ldi	r21, 0x08	; 8
    24ae:	c5 2e       	mov	r12, r21
    24b0:	d1 2c       	mov	r13, r1
    24b2:	ce 0c       	add	r12, r14
    24b4:	df 1c       	adc	r13, r15
    24b6:	0e c0       	rjmp	.+28     	; 0x24d4 <_ZN10IMUManager10SampleRateEj+0x74>
    24b8:	fc 01       	movw	r30, r24
    24ba:	e8 57       	subi	r30, 0x78	; 120
    24bc:	ff 4f       	sbci	r31, 0xFF	; 255
void IMUManager::SampleRate(uint16_t rate)
{
    // Range Limit the rate.
    if (rate < 10) {
        _sampleRate = 10;
    } else if (rate > 200) {
    24be:	69 3c       	cpi	r22, 0xC9	; 201
    24c0:	71 05       	cpc	r23, r1
    24c2:	28 f0       	brcs	.+10     	; 0x24ce <_ZN10IMUManager10SampleRateEj+0x6e>
        _sampleRate = 200;
    24c4:	88 ec       	ldi	r24, 0xC8	; 200
    24c6:	90 e0       	ldi	r25, 0x00	; 0
    24c8:	80 83       	st	Z, r24
    24ca:	91 83       	std	Z+1, r25	; 0x01
    24cc:	e9 cf       	rjmp	.-46     	; 0x24a0 <_ZN10IMUManager10SampleRateEj+0x40>
    } else {
        _sampleRate = rate;
    24ce:	60 83       	st	Z, r22
    24d0:	71 83       	std	Z+1, r23	; 0x01
    24d2:	e6 cf       	rjmp	.-52     	; 0x24a0 <_ZN10IMUManager10SampleRateEj+0x40>
    }

    ALL_IMUP(SampleRate,_sampleRate);
    24d4:	f8 01       	movw	r30, r16
    24d6:	a2 81       	ldd	r26, Z+2	; 0x02
    24d8:	b3 81       	ldd	r27, Z+3	; 0x03
    24da:	10 97       	sbiw	r26, 0x00	; 0
    24dc:	61 f0       	breq	.+24     	; 0x24f6 <_ZN10IMUManager10SampleRateEj+0x96>
    24de:	8d 91       	ld	r24, X+
    24e0:	9c 91       	ld	r25, X
    24e2:	11 97       	sbiw	r26, 0x01	; 1
    24e4:	f5 01       	movw	r30, r10
    24e6:	60 81       	ld	r22, Z
    24e8:	71 81       	ldd	r23, Z+1	; 0x01
    24ea:	fc 01       	movw	r30, r24
    24ec:	22 81       	ldd	r18, Z+2	; 0x02
    24ee:	33 81       	ldd	r19, Z+3	; 0x03
    24f0:	cd 01       	movw	r24, r26
    24f2:	f9 01       	movw	r30, r18
    24f4:	19 95       	eicall
    24f6:	0e 5f       	subi	r16, 0xFE	; 254
    24f8:	1f 4f       	sbci	r17, 0xFF	; 255
    24fa:	0c 15       	cp	r16, r12
    24fc:	1d 05       	cpc	r17, r13
    24fe:	51 f7       	brne	.-44     	; 0x24d4 <_ZN10IMUManager10SampleRateEj+0x74>
    
    
    if (pdbgserial) {
    2500:	80 91 2a 26 	lds	r24, 0x262A
    2504:	90 91 2b 26 	lds	r25, 0x262B
    2508:	89 2b       	or	r24, r25
    250a:	69 f1       	breq	.+90     	; 0x2566 <_ZN10IMUManager10SampleRateEj+0x106>
        char buffer[50];
        sprintf(buffer,"Sample rate set to %d\n", _sampleRate);
    250c:	00 d0       	rcall	.+0      	; 0x250e <_ZN10IMUManager10SampleRateEj+0xae>
    250e:	00 d0       	rcall	.+0      	; 0x2510 <_ZN10IMUManager10SampleRateEj+0xb0>
    2510:	ed b7       	in	r30, 0x3d	; 61
    2512:	fe b7       	in	r31, 0x3e	; 62
    2514:	31 96       	adiw	r30, 0x01	; 1
    2516:	8e 01       	movw	r16, r28
    2518:	0f 5f       	subi	r16, 0xFF	; 255
    251a:	1f 4f       	sbci	r17, 0xFF	; 255
    251c:	ad b7       	in	r26, 0x3d	; 61
    251e:	be b7       	in	r27, 0x3e	; 62
    2520:	11 96       	adiw	r26, 0x01	; 1
    2522:	0d 93       	st	X+, r16
    2524:	1c 93       	st	X, r17
    2526:	12 97       	sbiw	r26, 0x02	; 2
    2528:	8a ed       	ldi	r24, 0xDA	; 218
    252a:	91 e2       	ldi	r25, 0x21	; 33
    252c:	82 83       	std	Z+2, r24	; 0x02
    252e:	93 83       	std	Z+3, r25	; 0x03
    2530:	28 e8       	ldi	r18, 0x88	; 136
    2532:	30 e0       	ldi	r19, 0x00	; 0
    2534:	e2 0e       	add	r14, r18
    2536:	f3 1e       	adc	r15, r19
    2538:	d7 01       	movw	r26, r14
    253a:	8d 91       	ld	r24, X+
    253c:	9c 91       	ld	r25, X
    253e:	28 e7       	ldi	r18, 0x78	; 120
    2540:	3f ef       	ldi	r19, 0xFF	; 255
    2542:	e2 0e       	add	r14, r18
    2544:	f3 1e       	adc	r15, r19
    2546:	84 83       	std	Z+4, r24	; 0x04
    2548:	95 83       	std	Z+5, r25	; 0x05
    254a:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
        pdbgserial->print(buffer);
    254e:	8d b7       	in	r24, 0x3d	; 61
    2550:	9e b7       	in	r25, 0x3e	; 62
    2552:	06 96       	adiw	r24, 0x06	; 6
    2554:	8d bf       	out	0x3d, r24	; 61
    2556:	9e bf       	out	0x3e, r25	; 62
    2558:	80 91 2a 26 	lds	r24, 0x262A
    255c:	90 91 2b 26 	lds	r25, 0x262B
    2560:	b8 01       	movw	r22, r16
    2562:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>

    // Note: I had this set to 2X the sample rate (in milliseconds),
    // but that was a problem. The IMU's wait until there is 2X the
    // amount of data in the fifo, so that takes 2X the time, and we
    // would time out first time around.. bad idea.
    _maxMillisPerPacket = 3 * 1000/_sampleRate;
    2566:	f7 01       	movw	r30, r14
    2568:	e6 57       	subi	r30, 0x76	; 118
    256a:	ff 4f       	sbci	r31, 0xFF	; 255
    256c:	a8 e8       	ldi	r26, 0x88	; 136
    256e:	b0 e0       	ldi	r27, 0x00	; 0
    2570:	ea 0e       	add	r14, r26
    2572:	fb 1e       	adc	r15, r27
    2574:	d7 01       	movw	r26, r14
    2576:	6d 91       	ld	r22, X+
    2578:	7c 91       	ld	r23, X
    257a:	28 e7       	ldi	r18, 0x78	; 120
    257c:	3f ef       	ldi	r19, 0xFF	; 255
    257e:	e2 0e       	add	r14, r18
    2580:	f3 1e       	adc	r15, r19
    2582:	88 eb       	ldi	r24, 0xB8	; 184
    2584:	9b e0       	ldi	r25, 0x0B	; 11
    2586:	0e 94 4d 49 	call	0x929a	; 0x929a <__udivmodhi4>
    258a:	80 e0       	ldi	r24, 0x00	; 0
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	60 83       	st	Z, r22
    2590:	71 83       	std	Z+1, r23	; 0x01
    2592:	82 83       	std	Z+2, r24	; 0x02
    2594:	93 83       	std	Z+3, r25	; 0x03
    
    SetTimerPeriod();
    2596:	c7 01       	movw	r24, r14
    2598:	0e 94 be 11 	call	0x237c	; 0x237c <_ZN10IMUManager14SetTimerPeriodEv>
}
    259c:	e2 96       	adiw	r28, 0x32	; 50
    259e:	cd bf       	out	0x3d, r28	; 61
    25a0:	de bf       	out	0x3e, r29	; 62
    25a2:	cf 91       	pop	r28
    25a4:	df 91       	pop	r29
    25a6:	1f 91       	pop	r17
    25a8:	0f 91       	pop	r16
    25aa:	ff 90       	pop	r15
    25ac:	ef 90       	pop	r14
    25ae:	df 90       	pop	r13
    25b0:	cf 90       	pop	r12
    25b2:	bf 90       	pop	r11
    25b4:	af 90       	pop	r10
    25b6:	08 95       	ret

000025b8 <_ZN10IMUManager8SetTimerEP9TimerCntr>:
//! if a slower rate is used, just to avoid as much overhead.
//! The CPU Clock runs at 32Mhz, so the main timer clock is running
//! at 32/64 or 500us period. 
//! Timer set to same interrupt level as the I2C so that those
//! interrupts won't ever stomp on each other.
void IMUManager::SetTimer(TimerCntr* pTimer)
    25b8:	ef 92       	push	r14
    25ba:	ff 92       	push	r15
    25bc:	0f 93       	push	r16
    25be:	1f 93       	push	r17
    25c0:	8c 01       	movw	r16, r24
    25c2:	cb 01       	movw	r24, r22
{
    _pTimer = pTimer;
    25c4:	72 e8       	ldi	r23, 0x82	; 130
    25c6:	e7 2e       	mov	r14, r23
    25c8:	f1 2c       	mov	r15, r1
    25ca:	e0 0e       	add	r14, r16
    25cc:	f1 1e       	adc	r15, r17
    25ce:	f7 01       	movw	r30, r14
    25d0:	80 83       	st	Z, r24
    25d2:	91 83       	std	Z+1, r25	; 0x01
    
    //! This will be 2us period
    _pTimer->ClkSel(TC_CLKSEL_DIV64_gc);
    25d4:	65 e0       	ldi	r22, 0x05	; 5
    25d6:	0e 94 b6 32 	call	0x656c	; 0x656c <_ZN9TimerCntr6ClkSelE14TC_CLKSEL_enum>
    SetTimerPeriod();
    25da:	c8 01       	movw	r24, r16
    25dc:	0e 94 be 11 	call	0x237c	; 0x237c <_ZN10IMUManager14SetTimerPeriodEv>
    _pTimer->CCEnable(0);
    25e0:	f7 01       	movw	r30, r14
    25e2:	80 81       	ld	r24, Z
    25e4:	91 81       	ldd	r25, Z+1	; 0x01
    25e6:	60 e0       	ldi	r22, 0x00	; 0
    25e8:	0e 94 bc 32 	call	0x6578	; 0x6578 <_ZN9TimerCntr8CCEnableEh>
    _pTimer->WaveformGenMode(TC_WGMODE_NORMAL_gc);
    25ec:	f7 01       	movw	r30, r14
    25ee:	80 81       	ld	r24, Z
    25f0:	91 81       	ldd	r25, Z+1	; 0x01
    25f2:	60 e0       	ldi	r22, 0x00	; 0
    25f4:	0e 94 c7 32 	call	0x658e	; 0x658e <_ZN9TimerCntr15WaveformGenModeE14TC_WGMODE_enum>
    _pTimer->EventSetup(TC_EVACT_OFF_gc,TC_EVSEL_OFF_gc);
    25f8:	f7 01       	movw	r30, r14
    25fa:	80 81       	ld	r24, Z
    25fc:	91 81       	ldd	r25, Z+1	; 0x01
    25fe:	60 e0       	ldi	r22, 0x00	; 0
    2600:	40 e0       	ldi	r20, 0x00	; 0
    2602:	0e 94 d0 32 	call	0x65a0	; 0x65a0 <_ZN9TimerCntr10EventSetupE13TC_EVACT_enum13TC_EVSEL_enum>
    _pTimer->IntLvlA(0,1);
    2606:	f7 01       	movw	r30, r14
    2608:	80 81       	ld	r24, Z
    260a:	91 81       	ldd	r25, Z+1	; 0x01
    260c:	60 e0       	ldi	r22, 0x00	; 0
    260e:	41 e0       	ldi	r20, 0x01	; 1
    2610:	0e 94 d7 32 	call	0x65ae	; 0x65ae <_ZN9TimerCntr7IntLvlAEhh>
    _pTimer->IntLvlB(0);
    2614:	f7 01       	movw	r30, r14
    2616:	80 81       	ld	r24, Z
    2618:	91 81       	ldd	r25, Z+1	; 0x01
    261a:	60 e0       	ldi	r22, 0x00	; 0
    261c:	0e 94 e6 32 	call	0x65cc	; 0x65cc <_ZN9TimerCntr7IntLvlBEh>
    _pTimer->Notify(this,0);
    2620:	f7 01       	movw	r30, r14
    2622:	80 81       	ld	r24, Z
    2624:	91 81       	ldd	r25, Z+1	; 0x01
    2626:	b8 01       	movw	r22, r16
    2628:	40 e0       	ldi	r20, 0x00	; 0
    262a:	0e 94 5a 33 	call	0x66b4	; 0x66b4 <_ZN9TimerCntr6NotifyEP11TimerNotifyh>
}
    262e:	1f 91       	pop	r17
    2630:	0f 91       	pop	r16
    2632:	ff 90       	pop	r15
    2634:	ef 90       	pop	r14
    2636:	08 95       	ret

00002638 <_ZN10IMUManager10SendPacketEb>:
//! do not really know if they send back 1 or 2 IMU's
//! worth of information, but it does not matter since
//! we use pointer diff to determine how much data to return.
//! Send the appropriate header, then the packet data, then
//! a fooder including a CRC *not yet implemented though *
void IMUManager::SendPacket(bool bTimeout)
    2638:	cf 92       	push	r12
    263a:	df 92       	push	r13
    263c:	ef 92       	push	r14
    263e:	ff 92       	push	r15
    2640:	0f 93       	push	r16
    2642:	1f 93       	push	r17
    2644:	cf 93       	push	r28
    2646:	df 93       	push	r29
    2648:	ec 01       	movw	r28, r24
{
    uint8_t*    pPacket = &_dataPacket[0];
    264a:	f4 e1       	ldi	r31, 0x14	; 20
    264c:	cf 2e       	mov	r12, r31
    264e:	d1 2c       	mov	r13, r1
    2650:	c8 0e       	add	r12, r24
    2652:	d9 1e       	adc	r13, r25
    2654:	7c 01       	movw	r14, r24
    2656:	b6 01       	movw	r22, r12
    2658:	00 e0       	ldi	r16, 0x00	; 0
    265a:	10 e0       	ldi	r17, 0x00	; 0
    if (true || !bTimeout) {
        for (int x = 0;x<4;x++) {
            if (_pIMU[x]) {
    265c:	f7 01       	movw	r30, r14
    265e:	a2 81       	ldd	r26, Z+2	; 0x02
    2660:	b3 81       	ldd	r27, Z+3	; 0x03
    2662:	10 97       	sbiw	r26, 0x00	; 0
    2664:	49 f0       	breq	.+18     	; 0x2678 <_ZN10IMUManager10SendPacketEb+0x40>
                // This puts the data at the pointer,
                // then returns the end of the data.
                // This might be 2*14 or 1*14
                pPacket = _pIMU[x]->GetPacketData(pPacket);
    2666:	ed 91       	ld	r30, X+
    2668:	fc 91       	ld	r31, X
    266a:	11 97       	sbiw	r26, 0x01	; 1
    266c:	00 8c       	ldd	r0, Z+24	; 0x18
    266e:	f1 8d       	ldd	r31, Z+25	; 0x19
    2670:	e0 2d       	mov	r30, r0
    2672:	cd 01       	movw	r24, r26
    2674:	19 95       	eicall
    2676:	bc 01       	movw	r22, r24
//! a fooder including a CRC *not yet implemented though *
void IMUManager::SendPacket(bool bTimeout)
{
    uint8_t*    pPacket = &_dataPacket[0];
    if (true || !bTimeout) {
        for (int x = 0;x<4;x++) {
    2678:	0f 5f       	subi	r16, 0xFF	; 255
    267a:	1f 4f       	sbci	r17, 0xFF	; 255
    267c:	82 e0       	ldi	r24, 0x02	; 2
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	e8 0e       	add	r14, r24
    2682:	f9 1e       	adc	r15, r25
    2684:	04 30       	cpi	r16, 0x04	; 4
    2686:	11 05       	cpc	r17, r1
    2688:	49 f7       	brne	.-46     	; 0x265c <_ZN10IMUManager10SendPacketEb+0x24>
    // byte: packet type (0xB7)
    // byte(s): length bytes
    // bytes(2): 2 byte CRC
    // string: END
    // newline
    uint8_t size = pPacket - &_dataPacket[0];
    268a:	06 2f       	mov	r16, r22
    268c:	0c 19       	sub	r16, r12
    buffer[0] = 'S';
    268e:	83 e5       	ldi	r24, 0x53	; 83
    2690:	80 93 b4 26 	sts	0x26B4, r24
    buffer[1] = 'N';
    2694:	8e e4       	ldi	r24, 0x4E	; 78
    2696:	80 93 b5 26 	sts	0x26B5, r24
    buffer[2] = 'P';
    269a:	80 e5       	ldi	r24, 0x50	; 80
    269c:	80 93 b6 26 	sts	0x26B6, r24
    buffer[3] = 0xB7;
    26a0:	87 eb       	ldi	r24, 0xB7	; 183
    26a2:	80 93 b7 26 	sts	0x26B7, r24
    buffer[4] = _packetId++;
    26a6:	8b 89       	ldd	r24, Y+19	; 0x13
    26a8:	80 93 b8 26 	sts	0x26B8, r24
    26ac:	8f 5f       	subi	r24, 0xFF	; 255
    26ae:	8b 8b       	std	Y+19, r24	; 0x13
    buffer[5] = size;
    26b0:	00 93 b9 26 	sts	0x26B9, r16
    memcpy(&buffer[6],&_dataPacket[0],size);
    26b4:	ea eb       	ldi	r30, 0xBA	; 186
    26b6:	ee 2e       	mov	r14, r30
    26b8:	e6 e2       	ldi	r30, 0x26	; 38
    26ba:	fe 2e       	mov	r15, r30
    26bc:	c7 01       	movw	r24, r14
    26be:	b6 01       	movw	r22, r12
    26c0:	40 2f       	mov	r20, r16
    26c2:	50 e0       	ldi	r21, 0x00	; 0
    26c4:	0e 94 37 4b 	call	0x966e	; 0x966e <memcpy>
    // Compute CRC -- someday
    uint16_t crc = 0xaf5a;
    uint8_t crchi = (crc >> 8) & 0xff;
    uint8_t crclo = crc & 0xff;
    buffer[6+size]   = _nStreamWDCounter;
    26c8:	10 e0       	ldi	r17, 0x00	; 0
    26ca:	f8 01       	movw	r30, r16
    26cc:	ec 54       	subi	r30, 0x4C	; 76
    26ce:	f9 4d       	sbci	r31, 0xD9	; 217
    26d0:	89 89       	ldd	r24, Y+17	; 0x11
    26d2:	86 83       	std	Z+6, r24	; 0x06
    buffer[6+size+1]   = crchi;
    26d4:	8f ea       	ldi	r24, 0xAF	; 175
    26d6:	87 83       	std	Z+7, r24	; 0x07
    buffer[6+size+2] = crclo;
    26d8:	8a e5       	ldi	r24, 0x5A	; 90
    26da:	80 87       	std	Z+8, r24	; 0x08
    sprintf((char*)&buffer[6+size+3],"END\n");
    26dc:	c8 01       	movw	r24, r16
    26de:	83 54       	subi	r24, 0x43	; 67
    26e0:	99 4d       	sbci	r25, 0xD9	; 217
    26e2:	61 ef       	ldi	r22, 0xF1	; 241
    26e4:	71 e2       	ldi	r23, 0x21	; 33
    26e6:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
    _pSerial->write(&buffer[0],6+size+3+4);
    26ea:	cc 57       	subi	r28, 0x7C	; 124
    26ec:	df 4f       	sbci	r29, 0xFF	; 255
    26ee:	e8 81       	ld	r30, Y
    26f0:	f9 81       	ldd	r31, Y+1	; 0x01
    26f2:	a0 81       	ld	r26, Z
    26f4:	b1 81       	ldd	r27, Z+1	; 0x01
    26f6:	03 5f       	subi	r16, 0xF3	; 243
    26f8:	1f 4f       	sbci	r17, 0xFF	; 255
    26fa:	14 96       	adiw	r26, 0x04	; 4
    26fc:	2d 91       	ld	r18, X+
    26fe:	3c 91       	ld	r19, X
    2700:	15 97       	sbiw	r26, 0x05	; 5
    2702:	cf 01       	movw	r24, r30
    2704:	b7 01       	movw	r22, r14
    2706:	66 50       	subi	r22, 0x06	; 6
    2708:	70 40       	sbci	r23, 0x00	; 0
    270a:	a8 01       	movw	r20, r16
    270c:	f9 01       	movw	r30, r18
    270e:	19 95       	eicall
}
    2710:	df 91       	pop	r29
    2712:	cf 91       	pop	r28
    2714:	1f 91       	pop	r17
    2716:	0f 91       	pop	r16
    2718:	ff 90       	pop	r15
    271a:	ef 90       	pop	r14
    271c:	df 90       	pop	r13
    271e:	cf 90       	pop	r12
    2720:	08 95       	ret

00002722 <_ZN10IMUManager4LoopEv>:
//  that have 2 IMU devices on them. After this is all done,
//  we should have all of the required IMU data, then we can
//  initiate a packet send to the host with as much as six 
//  IMU's worth of data!
//
int IMUManager::Loop()
    2722:	cf 93       	push	r28
    2724:	df 93       	push	r29
    2726:	ec 01       	movw	r28, r24
{
    switch(_State) {
    2728:	88 89       	ldd	r24, Y+16	; 0x10
    272a:	82 30       	cpi	r24, 0x02	; 2
    272c:	c1 f0       	breq	.+48     	; 0x275e <_ZN10IMUManager4LoopEv+0x3c>
    272e:	83 30       	cpi	r24, 0x03	; 3
    2730:	18 f5       	brcc	.+70     	; 0x2778 <_ZN10IMUManager4LoopEv+0x56>
    2732:	81 30       	cpi	r24, 0x01	; 1
    2734:	a9 f5       	brne	.+106    	; 0x27a0 <_ZN10IMUManager4LoopEv+0x7e>
    case sIdle:
        break;
    case sDataWait:
        if (DataReady()) {
    2736:	ce 01       	movw	r24, r28
    2738:	0e 94 35 11 	call	0x226a	; 0x226a <_ZN10IMUManager9DataReadyEv>
    273c:	88 23       	and	r24, r24
    273e:	61 f0       	breq	.+24     	; 0x2758 <_ZN10IMUManager4LoopEv+0x36>
    void ShowLedStart();
    void ShowLedStop();
    
    inline void ResetDataReadyTO()
    {
        _lastSendMillis = millis();
    2740:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    2744:	c2 57       	subi	r28, 0x72	; 114
    2746:	df 4f       	sbci	r29, 0xFF	; 255
    2748:	68 83       	st	Y, r22
    274a:	79 83       	std	Y+1, r23	; 0x01
    274c:	8a 83       	std	Y+2, r24	; 0x02
    274e:	9b 83       	std	Y+3, r25	; 0x03
    2750:	ce 58       	subi	r28, 0x8E	; 142
    2752:	d0 40       	sbci	r29, 0x00	; 0
            ResetDataReadyTO();
            _State = sDataReady;
    2754:	82 e0       	ldi	r24, 0x02	; 2
    2756:	23 c0       	rjmp	.+70     	; 0x279e <_ZN10IMUManager4LoopEv+0x7c>
    }
  
    inline bool DataReadyTimeout()
    {
        if ((millis() - _lastSendMillis) > _maxMillisPerPacket) {
    2758:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    275c:	21 c0       	rjmp	.+66     	; 0x27a0 <_ZN10IMUManager4LoopEv+0x7e>
            ResetDataReadyTO();
            _State = sDataTimeout;
        }
        break;
    case sDataReady:
        PacketLedIndicator();
    275e:	ce 01       	movw	r24, r28
    2760:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <_ZN10IMUManager18PacketLedIndicatorEv>
        if (_nStreamWDCounter == 0) {
    2764:	89 89       	ldd	r24, Y+17	; 0x11
    2766:	9a 89       	ldd	r25, Y+18	; 0x12
    2768:	00 97       	sbiw	r24, 0x00	; 0
    276a:	69 f0       	breq	.+26     	; 0x2786 <_ZN10IMUManager4LoopEv+0x64>
            DiscardData();
            _State = sDataWait;
        } else {
            --_nStreamWDCounter;
    276c:	01 97       	sbiw	r24, 0x01	; 1
    276e:	89 8b       	std	Y+17, r24	; 0x11
    2770:	9a 8b       	std	Y+18, r25	; 0x12
            SendPacket(false);
    2772:	ce 01       	movw	r24, r28
    2774:	60 e0       	ldi	r22, 0x00	; 0
    2776:	10 c0       	rjmp	.+32     	; 0x2798 <_ZN10IMUManager4LoopEv+0x76>
            _State = sDataWait;
        }
        break;
    case sDataTimeout:
        PacketLedIndicator();
    2778:	ce 01       	movw	r24, r28
    277a:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <_ZN10IMUManager18PacketLedIndicatorEv>
        if (_nStreamWDCounter == 0) {
    277e:	89 89       	ldd	r24, Y+17	; 0x11
    2780:	9a 89       	ldd	r25, Y+18	; 0x12
    2782:	00 97       	sbiw	r24, 0x00	; 0
    2784:	21 f4       	brne	.+8      	; 0x278e <_ZN10IMUManager4LoopEv+0x6c>
            DiscardData();
    2786:	ce 01       	movw	r24, r28
    2788:	0e 94 96 11 	call	0x232c	; 0x232c <_ZN10IMUManager11DiscardDataEv>
    278c:	07 c0       	rjmp	.+14     	; 0x279c <_ZN10IMUManager4LoopEv+0x7a>
            _State = sDataWait;
        } else {
            --_nStreamWDCounter;
    278e:	01 97       	sbiw	r24, 0x01	; 1
    2790:	89 8b       	std	Y+17, r24	; 0x11
    2792:	9a 8b       	std	Y+18, r25	; 0x12
            SendPacket(true);
    2794:	ce 01       	movw	r24, r28
    2796:	61 e0       	ldi	r22, 0x01	; 1
    2798:	0e 94 1c 13 	call	0x2638	; 0x2638 <_ZN10IMUManager10SendPacketEb>
            _State = sDataWait;
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	88 8b       	std	Y+16, r24	; 0x10
        }
        break;
    }
    
    return 0;
}
    27a0:	80 e0       	ldi	r24, 0x00	; 0
    27a2:	90 e0       	ldi	r25, 0x00	; 0
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	08 95       	ret

000027aa <_ZN10IMUManager11StreamStartEb>:
//! If the current stream count == 0, then
//! re-configure all of the IMU's and make sure
//! everything is okay before we start.
//! If the count is > 0, then we are just
//! adding more streams to the count so continue.
int IMUManager::StreamStart(bool bUseGyro)
    27aa:	1f 93       	push	r17
    27ac:	cf 93       	push	r28
    27ae:	df 93       	push	r29
    27b0:	ec 01       	movw	r28, r24
    27b2:	16 2f       	mov	r17, r22
{
    if (_State != sIdle ) {
    27b4:	88 89       	ldd	r24, Y+16	; 0x10
    27b6:	88 23       	and	r24, r24
    27b8:	19 f0       	breq	.+6      	; 0x27c0 <_ZN10IMUManager11StreamStartEb+0x16>
        Stop();
    27ba:	ce 01       	movw	r24, r28
    27bc:	0e 94 65 10 	call	0x20ca	; 0x20ca <_ZN10IMUManager4StopEv>
    }
    
    IMUUseGyro(bUseGyro);
    27c0:	ce 01       	movw	r24, r28
    27c2:	61 2f       	mov	r22, r17
    27c4:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <_ZN10IMUManager10IMUUseGyroEb>
    
    int retc = Setup();
    27c8:	ce 01       	movw	r24, r28
    27ca:	0e 94 1b 10 	call	0x2036	; 0x2036 <_ZN10IMUManager5SetupEv>
    27ce:	9c 01       	movw	r18, r24
    if (retc < 0) {
    27d0:	97 fd       	sbrc	r25, 7
    27d2:	26 c0       	rjmp	.+76     	; 0x2820 <_ZN10IMUManager11StreamStartEb+0x76>
        return retc;
    }
    
    retc = Start();
    27d4:	ce 01       	movw	r24, r28
    27d6:	0e 94 40 10 	call	0x2080	; 0x2080 <_ZN10IMUManager5StartEv>
    27da:	9c 01       	movw	r18, r24
    
    if (retc < 0) {
    27dc:	97 fd       	sbrc	r25, 7
    27de:	20 c0       	rjmp	.+64     	; 0x2820 <_ZN10IMUManager11StreamStartEb+0x76>
        return retc;
    }
    
    ShowLedStart();
    27e0:	ce 01       	movw	r24, r28
    27e2:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <_ZN10IMUManager12ShowLedStartEv>
    _LedCounter = 0;
    27e6:	1e 86       	std	Y+14, r1	; 0x0e
    _packetId       = 0;
    27e8:	1b 8a       	std	Y+19, r1	; 0x13
    _nStreamWDCounter = 20;
    27ea:	84 e1       	ldi	r24, 0x14	; 20
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	89 8b       	std	Y+17, r24	; 0x11
    27f0:	9a 8b       	std	Y+18, r25	; 0x12
    int AddIMU(IMUBase* pIMU);
    void SetDebugPort(DebugPort* pPort);
    
    inline void SetState(StateType s)
    {
        _State = s;
    27f2:	81 e0       	ldi	r24, 0x01	; 1
    27f4:	88 8b       	std	Y+16, r24	; 0x10
        if (_pDBGPort) _pDBGPort->SetState((uint8_t)_State);
    27f6:	ca 57       	subi	r28, 0x7A	; 122
    27f8:	df 4f       	sbci	r29, 0xFF	; 255
    27fa:	88 81       	ld	r24, Y
    27fc:	99 81       	ldd	r25, Y+1	; 0x01
    27fe:	c6 58       	subi	r28, 0x86	; 134
    2800:	d0 40       	sbci	r29, 0x00	; 0
    2802:	00 97       	sbiw	r24, 0x00	; 0
    2804:	19 f0       	breq	.+6      	; 0x280c <_ZN10IMUManager11StreamStartEb+0x62>
    2806:	61 e0       	ldi	r22, 0x01	; 1
    2808:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
    void ShowLedStart();
    void ShowLedStop();
    
    inline void ResetDataReadyTO()
    {
        _lastSendMillis = millis();
    280c:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    2810:	c2 57       	subi	r28, 0x72	; 114
    2812:	df 4f       	sbci	r29, 0xFF	; 255
    2814:	68 83       	st	Y, r22
    2816:	79 83       	std	Y+1, r23	; 0x01
    2818:	8a 83       	std	Y+2, r24	; 0x02
    281a:	9b 83       	std	Y+3, r25	; 0x03
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	30 e0       	ldi	r19, 0x00	; 0
    
    SetState(sDataWait); // Jump ahead a state.
    ResetDataReadyTO();
    return 0;
}
    2820:	c9 01       	movw	r24, r18
    2822:	df 91       	pop	r29
    2824:	cf 91       	pop	r28
    2826:	1f 91       	pop	r17
    2828:	08 95       	ret

0000282a <_ZN13IMUPacketFifo5clearEv>:
    _pdata = (IMUPacket*)malloc(_size*sizeof(IMUPacket));
    clear();
}

//! Clear the fifo by resetting the start and end pointer.
void IMUPacketFifo::clear()
    282a:	fc 01       	movw	r30, r24
{
    _start = _end = _pdata;
    282c:	80 81       	ld	r24, Z
    282e:	91 81       	ldd	r25, Z+1	; 0x01
    2830:	84 83       	std	Z+4, r24	; 0x04
    2832:	95 83       	std	Z+5, r25	; 0x05
    2834:	82 83       	std	Z+2, r24	; 0x02
    2836:	93 83       	std	Z+3, r25	; 0x03
}
    2838:	08 95       	ret

0000283a <_ZN13IMUPacketFifo5countEv>:
//! In this case end < start, so data wraps around. The total count is equal to the
//! size of the buffer, minus the number of blank spots, or
//! \f$size - (start - end)\f$.<p>
//! The total number of possible elements that can be stored is size -1, so
//! 
uint8_t IMUPacketFifo::count()
    283a:	fc 01       	movw	r30, r24
{
    
    if (_end == _start) return 0;
    283c:	84 81       	ldd	r24, Z+4	; 0x04
    283e:	95 81       	ldd	r25, Z+5	; 0x05
    2840:	22 81       	ldd	r18, Z+2	; 0x02
    2842:	33 81       	ldd	r19, Z+3	; 0x03
    2844:	82 17       	cp	r24, r18
    2846:	93 07       	cpc	r25, r19
    2848:	11 f4       	brne	.+4      	; 0x284e <_ZN13IMUPacketFifo5countEv+0x14>
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	08 95       	ret
    if (_end > _start) {
    284e:	28 17       	cp	r18, r24
    2850:	39 07       	cpc	r19, r25
    2852:	28 f4       	brcc	.+10     	; 0x285e <_ZN13IMUPacketFifo5countEv+0x24>
        return _end - _start;
    2854:	82 1b       	sub	r24, r18
    2856:	93 0b       	sbc	r25, r19
    2858:	95 95       	asr	r25
    285a:	87 95       	ror	r24
    285c:	08 95       	ret
    }
    return _size - (_start - _end);
    285e:	28 1b       	sub	r18, r24
    2860:	39 0b       	sbc	r19, r25
    2862:	35 95       	asr	r19
    2864:	27 95       	ror	r18
    2866:	86 81       	ldd	r24, Z+6	; 0x06
    2868:	82 1b       	sub	r24, r18
}
    286a:	08 95       	ret

0000286c <_ZN13IMUPacketFifo4fullEv>:

//! Return true if the fifo is full.
bool IMUPacketFifo::full()
    286c:	0f 93       	push	r16
    286e:	1f 93       	push	r17
    2870:	8c 01       	movw	r16, r24
{
    return count() == (_size-1);
    2872:	0e 94 1d 14 	call	0x283a	; 0x283a <_ZN13IMUPacketFifo5countEv>
    2876:	40 e0       	ldi	r20, 0x00	; 0
    2878:	90 e0       	ldi	r25, 0x00	; 0
    287a:	f8 01       	movw	r30, r16
    287c:	26 81       	ldd	r18, Z+6	; 0x06
    287e:	30 e0       	ldi	r19, 0x00	; 0
    2880:	21 50       	subi	r18, 0x01	; 1
    2882:	30 40       	sbci	r19, 0x00	; 0
    2884:	82 17       	cp	r24, r18
    2886:	93 07       	cpc	r25, r19
    2888:	09 f4       	brne	.+2      	; 0x288c <_ZN13IMUPacketFifo4fullEv+0x20>
    288a:	41 e0       	ldi	r20, 0x01	; 1
}
    288c:	84 2f       	mov	r24, r20
    288e:	1f 91       	pop	r17
    2890:	0f 91       	pop	r16
    2892:	08 95       	ret

00002894 <_ZN13IMUPacketFifo5emptyEv>:

//! Return true if the fifo is empty.
bool IMUPacketFifo::empty()
    2894:	fc 01       	movw	r30, r24
    2896:	40 e0       	ldi	r20, 0x00	; 0
    2898:	22 81       	ldd	r18, Z+2	; 0x02
    289a:	33 81       	ldd	r19, Z+3	; 0x03
    289c:	84 81       	ldd	r24, Z+4	; 0x04
    289e:	95 81       	ldd	r25, Z+5	; 0x05
    28a0:	28 17       	cp	r18, r24
    28a2:	39 07       	cpc	r19, r25
    28a4:	09 f4       	brne	.+2      	; 0x28a8 <_ZN13IMUPacketFifo5emptyEv+0x14>
    28a6:	41 e0       	ldi	r20, 0x01	; 1
{
    return (_start == _end);
}
    28a8:	84 2f       	mov	r24, r20
    28aa:	08 95       	ret

000028ac <_ZN13IMUPacketFifo3popEPP9IMUPacket>:

//! Remove the top value from the Fifo.
//! I am passing out a reference to the internal value
//! for efficiency. This assumes that the caller will use and
//! then discard the pointer quickly.
int8_t IMUPacketFifo::pop(IMUPacket** ppPkt) 
    28ac:	fc 01       	movw	r30, r24
    28ae:	db 01       	movw	r26, r22
}

//! Return true if the fifo is empty.
bool IMUPacketFifo::empty()
{
    return (_start == _end);
    28b0:	22 81       	ldd	r18, Z+2	; 0x02
    28b2:	33 81       	ldd	r19, Z+3	; 0x03
//! I am passing out a reference to the internal value
//! for efficiency. This assumes that the caller will use and
//! then discard the pointer quickly.
int8_t IMUPacketFifo::pop(IMUPacket** ppPkt) 
{
    if (empty()) {
    28b4:	84 81       	ldd	r24, Z+4	; 0x04
    28b6:	95 81       	ldd	r25, Z+5	; 0x05
    28b8:	28 17       	cp	r18, r24
    28ba:	39 07       	cpc	r19, r25
    28bc:	11 f4       	brne	.+4      	; 0x28c2 <_ZN13IMUPacketFifo3popEPP9IMUPacket+0x16>
    28be:	8f ef       	ldi	r24, 0xFF	; 255
    28c0:	08 95       	ret
        return -1;
    }
    
    // Pass out a reference.
    *ppPkt = (_start++);
    28c2:	2d 93       	st	X+, r18
    28c4:	3c 93       	st	X, r19
    28c6:	2e 5f       	subi	r18, 0xFE	; 254
    28c8:	3f 4f       	sbci	r19, 0xFF	; 255
    28ca:	22 83       	std	Z+2, r18	; 0x02
    28cc:	33 83       	std	Z+3, r19	; 0x03
    
    if ((_start - _pdata) == _size) {
    28ce:	40 81       	ld	r20, Z
    28d0:	51 81       	ldd	r21, Z+1	; 0x01
    28d2:	24 1b       	sub	r18, r20
    28d4:	35 0b       	sbc	r19, r21
    28d6:	35 95       	asr	r19
    28d8:	27 95       	ror	r18
    28da:	86 81       	ldd	r24, Z+6	; 0x06
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	28 17       	cp	r18, r24
    28e0:	39 07       	cpc	r19, r25
    28e2:	11 f0       	breq	.+4      	; 0x28e8 <_ZN13IMUPacketFifo3popEPP9IMUPacket+0x3c>
    28e4:	80 e0       	ldi	r24, 0x00	; 0
    28e6:	08 95       	ret
        _start = _pdata;
    28e8:	42 83       	std	Z+2, r20	; 0x02
    28ea:	53 83       	std	Z+3, r21	; 0x03
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    }
    return 0;
}
    28ee:	08 95       	ret

000028f0 <_ZN13IMUPacketFifo4pushERK9IMUPacket>:
}

//! Push a new value onto the fifo. 
//! This function returns 0 if the operation succeeds, and a negative
//! value if the operation fails.
int8_t IMUPacketFifo::push(const IMUPacket& rPkt) 
    28f0:	0f 93       	push	r16
    28f2:	1f 93       	push	r17
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	ec 01       	movw	r28, r24
    28fa:	8b 01       	movw	r16, r22
{
    if (full()) return -1;
    28fc:	0e 94 36 14 	call	0x286c	; 0x286c <_ZN13IMUPacketFifo4fullEv>
    2900:	88 23       	and	r24, r24
    2902:	11 f0       	breq	.+4      	; 0x2908 <_ZN13IMUPacketFifo4pushERK9IMUPacket+0x18>
    2904:	8f ef       	ldi	r24, 0xFF	; 255
    2906:	24 c0       	rjmp	.+72     	; 0x2950 <_ZN13IMUPacketFifo4pushERK9IMUPacket+0x60>
    
    // Copy once, not twice on the call.
    *(_end++) = rPkt;
    2908:	ec 81       	ldd	r30, Y+4	; 0x04
    290a:	fd 81       	ldd	r31, Y+5	; 0x05
    290c:	32 96       	adiw	r30, 0x02	; 2
    290e:	ec 83       	std	Y+4, r30	; 0x04
    2910:	fd 83       	std	Y+5, r31	; 0x05
        }
    }
    
    IMUPacket& operator=(const IMUPacket& rhs)
    {
        memcpy(_pData+1,rhs._pData+1,PacketLen);
    2912:	b2 91       	ld	r27, -Z
    2914:	a2 91       	ld	r26, -Z
    2916:	f8 01       	movw	r30, r16
    2918:	20 81       	ld	r18, Z
    291a:	31 81       	ldd	r19, Z+1	; 0x01
    291c:	11 96       	adiw	r26, 0x01	; 1
    291e:	2f 5f       	subi	r18, 0xFF	; 255
    2920:	3f 4f       	sbci	r19, 0xFF	; 255
    2922:	80 e1       	ldi	r24, 0x10	; 16
    2924:	f9 01       	movw	r30, r18
    2926:	01 90       	ld	r0, Z+
    2928:	9f 01       	movw	r18, r30
    292a:	0d 92       	st	X+, r0
    292c:	81 50       	subi	r24, 0x01	; 1
    292e:	d1 f7       	brne	.-12     	; 0x2924 <_ZN13IMUPacketFifo4pushERK9IMUPacket+0x34>
    
    // Wrap the end back to the beginning.
    if ((_end - _pdata) == _size) {
    2930:	48 81       	ld	r20, Y
    2932:	59 81       	ldd	r21, Y+1	; 0x01
    2934:	2c 81       	ldd	r18, Y+4	; 0x04
    2936:	3d 81       	ldd	r19, Y+5	; 0x05
    2938:	24 1b       	sub	r18, r20
    293a:	35 0b       	sbc	r19, r21
    293c:	35 95       	asr	r19
    293e:	27 95       	ror	r18
    2940:	8e 81       	ldd	r24, Y+6	; 0x06
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	28 17       	cp	r18, r24
    2946:	39 07       	cpc	r19, r25
    2948:	11 f4       	brne	.+4      	; 0x294e <_ZN13IMUPacketFifo4pushERK9IMUPacket+0x5e>
        _end = _pdata;
    294a:	4c 83       	std	Y+4, r20	; 0x04
    294c:	5d 83       	std	Y+5, r21	; 0x05
    294e:	80 e0       	ldi	r24, 0x00	; 0
    }

    return 0;
}
    2950:	df 91       	pop	r29
    2952:	cf 91       	pop	r28
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	08 95       	ret

0000295a <_ZN13IMUPacketFifo4pushEP9IMUPacket>:
}

//! Push a new value onto the fifo. 
//! This function returns 0 if the operation succeeds, and a negative
//! value if the operation fails.
int8_t IMUPacketFifo::push(IMUPacket* pPkt) 
    295a:	0f 93       	push	r16
    295c:	1f 93       	push	r17
    295e:	cf 93       	push	r28
    2960:	df 93       	push	r29
    2962:	ec 01       	movw	r28, r24
    2964:	8b 01       	movw	r16, r22
{
    if (full()) return -1;
    2966:	0e 94 36 14 	call	0x286c	; 0x286c <_ZN13IMUPacketFifo4fullEv>
    296a:	88 23       	and	r24, r24
    296c:	11 f0       	breq	.+4      	; 0x2972 <_ZN13IMUPacketFifo4pushEP9IMUPacket+0x18>
    296e:	8f ef       	ldi	r24, 0xFF	; 255
    2970:	24 c0       	rjmp	.+72     	; 0x29ba <_ZN13IMUPacketFifo4pushEP9IMUPacket+0x60>
    
    // Copy once, not twice on the call.
    *(_end++) = *pPkt;
    2972:	ec 81       	ldd	r30, Y+4	; 0x04
    2974:	fd 81       	ldd	r31, Y+5	; 0x05
    2976:	32 96       	adiw	r30, 0x02	; 2
    2978:	ec 83       	std	Y+4, r30	; 0x04
    297a:	fd 83       	std	Y+5, r31	; 0x05
    297c:	b2 91       	ld	r27, -Z
    297e:	a2 91       	ld	r26, -Z
    2980:	f8 01       	movw	r30, r16
    2982:	20 81       	ld	r18, Z
    2984:	31 81       	ldd	r19, Z+1	; 0x01
    2986:	11 96       	adiw	r26, 0x01	; 1
    2988:	2f 5f       	subi	r18, 0xFF	; 255
    298a:	3f 4f       	sbci	r19, 0xFF	; 255
    298c:	80 e1       	ldi	r24, 0x10	; 16
    298e:	f9 01       	movw	r30, r18
    2990:	01 90       	ld	r0, Z+
    2992:	9f 01       	movw	r18, r30
    2994:	0d 92       	st	X+, r0
    2996:	81 50       	subi	r24, 0x01	; 1
    2998:	d1 f7       	brne	.-12     	; 0x298e <_ZN13IMUPacketFifo4pushEP9IMUPacket+0x34>
    
    // Wrap the end back to the beginning.
    if ((_end - _pdata) == _size) {
    299a:	48 81       	ld	r20, Y
    299c:	59 81       	ldd	r21, Y+1	; 0x01
    299e:	2c 81       	ldd	r18, Y+4	; 0x04
    29a0:	3d 81       	ldd	r19, Y+5	; 0x05
    29a2:	24 1b       	sub	r18, r20
    29a4:	35 0b       	sbc	r19, r21
    29a6:	35 95       	asr	r19
    29a8:	27 95       	ror	r18
    29aa:	8e 81       	ldd	r24, Y+6	; 0x06
    29ac:	90 e0       	ldi	r25, 0x00	; 0
    29ae:	28 17       	cp	r18, r24
    29b0:	39 07       	cpc	r19, r25
    29b2:	11 f4       	brne	.+4      	; 0x29b8 <_ZN13IMUPacketFifo4pushEP9IMUPacket+0x5e>
        _end = _pdata;
    29b4:	4c 83       	std	Y+4, r20	; 0x04
    29b6:	5d 83       	std	Y+5, r21	; 0x05
    29b8:	80 e0       	ldi	r24, 0x00	; 0
    }

    return 0;
}
    29ba:	df 91       	pop	r29
    29bc:	cf 91       	pop	r28
    29be:	1f 91       	pop	r17
    29c0:	0f 91       	pop	r16
    29c2:	08 95       	ret

000029c4 <_ZN13IMUPacketFifoC1Eh>:
//! Allocate memory for the specified number of elements
//! and set the internal value to indicate the size of the fifo.
//! Reset the start and end data points to their clear state. The
//! clear function is called to maintain consitency and insure that
//! clear() always does the right thing.
IMUPacketFifo::IMUPacketFifo(uint8_t size)
    29c4:	0f 93       	push	r16
    29c6:	1f 93       	push	r17
    29c8:	8c 01       	movw	r16, r24
    29ca:	86 2f       	mov	r24, r22
{
    _size = size;
    29cc:	f8 01       	movw	r30, r16
    29ce:	66 83       	std	Z+6, r22	; 0x06
    _pdata = (IMUPacket*)malloc(_size*sizeof(IMUPacket));
    29d0:	90 e0       	ldi	r25, 0x00	; 0
    29d2:	88 0f       	add	r24, r24
    29d4:	99 1f       	adc	r25, r25
    29d6:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    29da:	f8 01       	movw	r30, r16
    29dc:	80 83       	st	Z, r24
    29de:	91 83       	std	Z+1, r25	; 0x01
}

//! Clear the fifo by resetting the start and end pointer.
void IMUPacketFifo::clear()
{
    _start = _end = _pdata;
    29e0:	84 83       	std	Z+4, r24	; 0x04
    29e2:	95 83       	std	Z+5, r25	; 0x05
    29e4:	82 83       	std	Z+2, r24	; 0x02
    29e6:	93 83       	std	Z+3, r25	; 0x03
IMUPacketFifo::IMUPacketFifo(uint8_t size)
{
    _size = size;
    _pdata = (IMUPacket*)malloc(_size*sizeof(IMUPacket));
    clear();
}
    29e8:	1f 91       	pop	r17
    29ea:	0f 91       	pop	r16
    29ec:	08 95       	ret

000029ee <_ZN13IMUPacketFifoC2Eh>:
//! Allocate memory for the specified number of elements
//! and set the internal value to indicate the size of the fifo.
//! Reset the start and end data points to their clear state. The
//! clear function is called to maintain consitency and insure that
//! clear() always does the right thing.
IMUPacketFifo::IMUPacketFifo(uint8_t size)
    29ee:	0f 93       	push	r16
    29f0:	1f 93       	push	r17
    29f2:	8c 01       	movw	r16, r24
    29f4:	86 2f       	mov	r24, r22
{
    _size = size;
    29f6:	f8 01       	movw	r30, r16
    29f8:	66 83       	std	Z+6, r22	; 0x06
    _pdata = (IMUPacket*)malloc(_size*sizeof(IMUPacket));
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	88 0f       	add	r24, r24
    29fe:	99 1f       	adc	r25, r25
    2a00:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    2a04:	f8 01       	movw	r30, r16
    2a06:	80 83       	st	Z, r24
    2a08:	91 83       	std	Z+1, r25	; 0x01
}

//! Clear the fifo by resetting the start and end pointer.
void IMUPacketFifo::clear()
{
    _start = _end = _pdata;
    2a0a:	84 83       	std	Z+4, r24	; 0x04
    2a0c:	95 83       	std	Z+5, r25	; 0x05
    2a0e:	82 83       	std	Z+2, r24	; 0x02
    2a10:	93 83       	std	Z+3, r25	; 0x03
IMUPacketFifo::IMUPacketFifo(uint8_t size)
{
    _size = size;
    _pdata = (IMUPacket*)malloc(_size*sizeof(IMUPacket));
    clear();
}
    2a12:	1f 91       	pop	r17
    2a14:	0f 91       	pop	r16
    2a16:	08 95       	ret

00002a18 <_Z8CCPWritePVhh>:
 *  operation of writing to the registers.
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
    2a18:	0f 93       	push	r16
    2a1a:	df 93       	push	r29
    2a1c:	cf 93       	push	r28
    2a1e:	0f 92       	push	r0
    2a20:	cd b7       	in	r28, 0x3d	; 61
    2a22:	de b7       	in	r29, 0x3e	; 62
{
    AVR_ENTER_CRITICAL_REGION( );
    2a24:	2f b7       	in	r18, 0x3f	; 63
    2a26:	29 83       	std	Y+1, r18	; 0x01
    2a28:	f8 94       	cli
        "out   %3, r16"	      "\n\t"
        "st     Z,  %1"       "\n\t"
        :
        : "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
        : "r16", "r30", "r31"
    );
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	08 ed       	ldi	r16, 0xD8	; 216
    2a2e:	04 bf       	out	0x34, r16	; 52
    2a30:	60 83       	st	Z, r22

    AVR_LEAVE_CRITICAL_REGION( );
    2a32:	89 81       	ldd	r24, Y+1	; 0x01
    2a34:	8f bf       	out	0x3f, r24	; 63
}
    2a36:	0f 90       	pop	r0
    2a38:	cf 91       	pop	r28
    2a3a:	df 91       	pop	r29
    2a3c:	0f 91       	pop	r16
    2a3e:	08 95       	ret

00002a40 <_Z14clksystem_initv>:
void clksystem_init()
{
    // This board does not have an external oscillator,
    // so we need to use the internal oscillator.
    // Enable the internal 32Mhz oscillator. Disables all the rest.
    OSC.CTRL = OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm;
    2a40:	87 e0       	ldi	r24, 0x07	; 7
    2a42:	80 93 50 00 	sts	0x0050, r24
    2a46:	24 e6       	ldi	r18, 0x64	; 100
    2a48:	30 e0       	ldi	r19, 0x00	; 0
    2a4a:	4a e0       	ldi	r20, 0x0A	; 10
    2a4c:	50 e0       	ldi	r21, 0x00	; 0

    //OSC.XOSCCTRL = 0; // we don't care, just set this to some value.

    // Wait for the external oscilator. Don't wait forever though.
    int maxWait = 100; // Wait 1 second
    while (--maxWait && !(OSC.STATUS & (OSC_RC32MRDY_bm | OSC_RC32KRDY_bm | OSC_RC2MRDY_bm))) {
    2a4e:	21 50       	subi	r18, 0x01	; 1
    2a50:	30 40       	sbci	r19, 0x00	; 0
    2a52:	31 f1       	breq	.+76     	; 0x2aa0 <_Z14clksystem_initv+0x60>
    2a54:	80 91 51 00 	lds	r24, 0x0051
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	87 70       	andi	r24, 0x07	; 7
    2a5c:	90 70       	andi	r25, 0x00	; 0
    2a5e:	89 2b       	or	r24, r25
    2a60:	f9 f4       	brne	.+62     	; 0x2aa0 <_Z14clksystem_initv+0x60>
    2a62:	ca 01       	movw	r24, r20
    2a64:	01 97       	sbiw	r24, 0x01	; 1
    2a66:	f1 f7       	brne	.-4      	; 0x2a64 <_Z14clksystem_initv+0x24>
    2a68:	f2 cf       	rjmp	.-28     	; 0x2a4e <_Z14clksystem_initv+0xe>
    if (OSC.STATUS & ( OSC_RC32MRDY_bm | OSC_RC2MRDY_bm)) {
        // Setup the PLL to use the internal 32Mhz oscillator and a
        // factor of 4 to get a 128Mhz PLL Clock.

        // Make sure this is disabled before we try and configure it.
        OSC.CTRL &= ~OSC_PLLEN_bm;
    2a6a:	80 91 50 00 	lds	r24, 0x0050
    2a6e:	8f 7e       	andi	r24, 0xEF	; 239
    2a70:	80 93 50 00 	sts	0x0050, r24

        OSC.PLLCTRL = OSC_PLLSRC_RC32M_gc | (16 << OSC_PLLFAC_gp);
    2a74:	80 e9       	ldi	r24, 0x90	; 144
    2a76:	85 83       	std	Z+5, r24	; 0x05

        OSC.CTRL |= OSC_PLLEN_bm;
    2a78:	80 91 50 00 	lds	r24, 0x0050
    2a7c:	80 61       	ori	r24, 0x10	; 16
    2a7e:	80 93 50 00 	sts	0x0050, r24

        //OSC.CTRL = CLK_PSADIV_16_gc;
        // Wait for OSC.STATUS to indicate that PLL is ready..
        while (!(OSC.STATUS & OSC_PLLRDY_bm)) {
    2a82:	80 91 51 00 	lds	r24, 0x0051
    2a86:	84 ff       	sbrs	r24, 4
    2a88:	fc cf       	rjmp	.-8      	; 0x2a82 <_Z14clksystem_initv+0x42>
        }

        // Okay, the PLL is up on the new clock. Set the prescalers then
        // switch over to the PLL.

        CCP = CCP_IOREG_gc;
    2a8a:	98 ed       	ldi	r25, 0xD8	; 216
    2a8c:	94 bf       	out	0x34, r25	; 52
        CLK.PSCTRL = CLK_PSADIV_1_gc | CLK_PSBCDIV_2_2_gc;
    2a8e:	83 e0       	ldi	r24, 0x03	; 3
    2a90:	e0 e4       	ldi	r30, 0x40	; 64
    2a92:	f0 e0       	ldi	r31, 0x00	; 0
    2a94:	81 83       	std	Z+1, r24	; 0x01
        //CLK.PSCTRL = CLK_PSADIV_1_gc | CLK_PSBCDIV_1_1_gc;

        // When all is done, make the PLL be the clock source for the system.
        CCP = CCP_IOREG_gc;
    2a96:	94 bf       	out	0x34, r25	; 52
        CLK.CTRL = CLK_SCLKSEL_PLL_gc;
    2a98:	84 e0       	ldi	r24, 0x04	; 4
    2a9a:	80 93 40 00 	sts	0x0040, r24
    2a9e:	08 95       	ret
    int maxWait = 100; // Wait 1 second
    while (--maxWait && !(OSC.STATUS & (OSC_RC32MRDY_bm | OSC_RC32KRDY_bm | OSC_RC2MRDY_bm))) {
        _delay_loop_2(10);
    }

    OSC.DFLLCTRL = 0;
    2aa0:	e0 e5       	ldi	r30, 0x50	; 80
    2aa2:	f0 e0       	ldi	r31, 0x00	; 0
    2aa4:	16 82       	std	Z+6, r1	; 0x06
    DFLLRC32M.CTRL = 0x1;
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	80 93 60 00 	sts	0x0060, r24
    DFLLRC2M.CTRL = 0x1;
    2aac:	80 93 68 00 	sts	0x0068, r24

    // If the external oscilator is running, then we can switch the PLL
    // over to it and wait for the PLL to stabilize.
    if (OSC.STATUS & ( OSC_RC32MRDY_bm | OSC_RC2MRDY_bm)) {
    2ab0:	80 91 51 00 	lds	r24, 0x0051
    2ab4:	90 e0       	ldi	r25, 0x00	; 0
    2ab6:	83 70       	andi	r24, 0x03	; 3
    2ab8:	90 70       	andi	r25, 0x00	; 0
    2aba:	89 2b       	or	r24, r25
    2abc:	b1 f6       	brne	.-84     	; 0x2a6a <_Z14clksystem_initv+0x2a>
    2abe:	08 95       	ret

00002ac0 <_ZN16GyroCmdProcessor4LoopEv>:

GyroCmdProcessor::~GyroCmdProcessor()
{
}

void GyroCmdProcessor::Loop()
    2ac0:	6f 92       	push	r6
    2ac2:	7f 92       	push	r7
    2ac4:	8f 92       	push	r8
    2ac6:	9f 92       	push	r9
    2ac8:	af 92       	push	r10
    2aca:	bf 92       	push	r11
    2acc:	cf 92       	push	r12
    2ace:	df 92       	push	r13
    2ad0:	ef 92       	push	r14
    2ad2:	ff 92       	push	r15
    2ad4:	0f 93       	push	r16
    2ad6:	1f 93       	push	r17
    2ad8:	df 93       	push	r29
    2ada:	cf 93       	push	r28
    2adc:	00 d0       	rcall	.+0      	; 0x2ade <_ZN16GyroCmdProcessor4LoopEv+0x1e>
    2ade:	00 d0       	rcall	.+0      	; 0x2ae0 <_ZN16GyroCmdProcessor4LoopEv+0x20>
    2ae0:	cd b7       	in	r28, 0x3d	; 61
    2ae2:	de b7       	in	r29, 0x3e	; 62
    2ae4:	6c 01       	movw	r12, r24
{
    // Process commands from the command interface.
    //if (false) {
    if (checkCommands()) {
    2ae6:	78 2e       	mov	r7, r24
    2ae8:	6d 2c       	mov	r6, r13
    2aea:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <_ZN12CmdProcessor13checkCommandsEv>
    2aee:	88 23       	and	r24, r24
    2af0:	09 f4       	brne	.+2      	; 0x2af4 <_ZN16GyroCmdProcessor4LoopEv+0x34>
    2af2:	57 c3       	rjmp	.+1710   	; 0x31a2 <_ZN16GyroCmdProcessor4LoopEv+0x6e2>
        // Process the command
        
        const char *pCmd = getCmd();
    2af4:	c6 01       	movw	r24, r12
    2af6:	0e 94 5a 19 	call	0x32b4	; 0x32b4 <_ZN12CmdProcessor6getCmdEv>
    2afa:	7c 01       	movw	r14, r24

        // What is the best way? An enum would work, but hard to
        // manage. A string is easy, but inefficient... but easy.
        if (strcmp(pCmd,"checkid") == 0) {
    2afc:	6a e0       	ldi	r22, 0x0A	; 10
    2afe:	72 e2       	ldi	r23, 0x22	; 34
    2b00:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2b04:	00 97       	sbiw	r24, 0x00	; 0
    2b06:	09 f0       	breq	.+2      	; 0x2b0a <_ZN16GyroCmdProcessor4LoopEv+0x4a>
    2b08:	40 c0       	rjmp	.+128    	; 0x2b8a <_ZN16GyroCmdProcessor4LoopEv+0xca>
            if (paramCnt() < 2) {
    2b0a:	c6 01       	movw	r24, r12
    2b0c:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2b10:	82 30       	cpi	r24, 0x02	; 2
    2b12:	08 f4       	brcc	.+2      	; 0x2b16 <_ZN16GyroCmdProcessor4LoopEv+0x56>
    2b14:	d9 c0       	rjmp	.+434    	; 0x2cc8 <_ZN16GyroCmdProcessor4LoopEv+0x208>
                _pHW->print("Fail:incorrect param count\n");
            } else {
                uint8_t idx = 0;
    2b16:	1b 82       	std	Y+3, r1	; 0x03
                uint8_t id;
                getParam(0,idx);
    2b18:	c6 01       	movw	r24, r12
    2b1a:	60 e0       	ldi	r22, 0x00	; 0
    2b1c:	ae 01       	movw	r20, r28
    2b1e:	4d 5f       	subi	r20, 0xFD	; 253
    2b20:	5f 4f       	sbci	r21, 0xFF	; 255
    2b22:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(1,id);
    2b26:	c6 01       	movw	r24, r12
    2b28:	61 e0       	ldi	r22, 0x01	; 1
    2b2a:	ae 01       	movw	r20, r28
    2b2c:	4e 5f       	subi	r20, 0xFE	; 254
    2b2e:	5f 4f       	sbci	r21, 0xFF	; 255
    2b30:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                if (idx < 4) {
    2b34:	eb 81       	ldd	r30, Y+3	; 0x03
    2b36:	e4 30       	cpi	r30, 0x04	; 4
    2b38:	08 f0       	brcs	.+2      	; 0x2b3c <_ZN16GyroCmdProcessor4LoopEv+0x7c>
    2b3a:	2f c3       	rjmp	.+1630   	; 0x319a <_ZN16GyroCmdProcessor4LoopEv+0x6da>
                    int retc = _pMaster[idx]->CheckID(id);
    2b3c:	f0 e0       	ldi	r31, 0x00	; 0
    2b3e:	ee 0f       	add	r30, r30
    2b40:	ff 1f       	adc	r31, r31
    2b42:	ec 0d       	add	r30, r12
    2b44:	fd 1d       	adc	r31, r13
    2b46:	81 a1       	ldd	r24, Z+33	; 0x21
    2b48:	92 a1       	ldd	r25, Z+34	; 0x22
    2b4a:	6a 81       	ldd	r22, Y+2	; 0x02
    2b4c:	0e 94 9e 28 	call	0x513c	; 0x513c <_ZN10I2C_Master7CheckIDEh>
    2b50:	28 2f       	mov	r18, r24
    2b52:	33 27       	eor	r19, r19
    2b54:	27 fd       	sbrc	r18, 7
    2b56:	30 95       	com	r19
                    if (retc == 0) {
    2b58:	21 15       	cp	r18, r1
    2b5a:	31 05       	cpc	r19, r1
    2b5c:	31 f4       	brne	.+12     	; 0x2b6a <_ZN16GyroCmdProcessor4LoopEv+0xaa>
                        _pHW->print("Ok:Ack.\n");
    2b5e:	f6 01       	movw	r30, r12
    2b60:	80 81       	ld	r24, Z
    2b62:	91 81       	ldd	r25, Z+1	; 0x01
    2b64:	6e e2       	ldi	r22, 0x2E	; 46
    2b66:	72 e2       	ldi	r23, 0x22	; 34
    2b68:	16 c3       	rjmp	.+1580   	; 0x3196 <_ZN16GyroCmdProcessor4LoopEv+0x6d6>
                    } else {
                        sprintf(buffer,"Ok:(%d) NAck\n", retc);
    2b6a:	00 d0       	rcall	.+0      	; 0x2b6c <_ZN16GyroCmdProcessor4LoopEv+0xac>
    2b6c:	00 d0       	rcall	.+0      	; 0x2b6e <_ZN16GyroCmdProcessor4LoopEv+0xae>
    2b6e:	ed b7       	in	r30, 0x3d	; 61
    2b70:	fe b7       	in	r31, 0x3e	; 62
    2b72:	31 96       	adiw	r30, 0x01	; 1
    2b74:	03 eb       	ldi	r16, 0xB3	; 179
    2b76:	17 e2       	ldi	r17, 0x27	; 39
    2b78:	ad b7       	in	r26, 0x3d	; 61
    2b7a:	be b7       	in	r27, 0x3e	; 62
    2b7c:	11 96       	adiw	r26, 0x01	; 1
    2b7e:	0d 93       	st	X+, r16
    2b80:	1c 93       	st	X, r17
    2b82:	12 97       	sbiw	r26, 0x02	; 2
    2b84:	87 e3       	ldi	r24, 0x37	; 55
    2b86:	92 e2       	ldi	r25, 0x22	; 34
    2b88:	e6 c0       	rjmp	.+460    	; 0x2d56 <_ZN16GyroCmdProcessor4LoopEv+0x296>
                        _pHW->print(buffer);
                    }
                }
            }
        } else if(strcmp(pCmd,"checkids") == 0) {
    2b8a:	c7 01       	movw	r24, r14
    2b8c:	65 e4       	ldi	r22, 0x45	; 69
    2b8e:	72 e2       	ldi	r23, 0x22	; 34
    2b90:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2b94:	00 97       	sbiw	r24, 0x00	; 0
    2b96:	e9 f4       	brne	.+58     	; 0x2bd2 <_ZN16GyroCmdProcessor4LoopEv+0x112>
            int idx = -1;
    2b98:	8f ef       	ldi	r24, 0xFF	; 255
    2b9a:	9f ef       	ldi	r25, 0xFF	; 255
    2b9c:	8b 83       	std	Y+3, r24	; 0x03
    2b9e:	9c 83       	std	Y+4, r25	; 0x04
            if (paramCnt() > 0) {
    2ba0:	c6 01       	movw	r24, r12
    2ba2:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2ba6:	88 23       	and	r24, r24
    2ba8:	39 f0       	breq	.+14     	; 0x2bb8 <_ZN16GyroCmdProcessor4LoopEv+0xf8>
                getParam(0,idx);
    2baa:	c6 01       	movw	r24, r12
    2bac:	60 e0       	ldi	r22, 0x00	; 0
    2bae:	ae 01       	movw	r20, r28
    2bb0:	4d 5f       	subi	r20, 0xFD	; 253
    2bb2:	5f 4f       	sbci	r21, 0xFF	; 255
    2bb4:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN12CmdProcessor8getParamEhRi>
            }
            _pMgr->CheckIDs(_pHW,idx);
    2bb8:	f6 01       	movw	r30, r12
    2bba:	60 81       	ld	r22, Z
    2bbc:	71 81       	ldd	r23, Z+1	; 0x01
    2bbe:	4b 81       	ldd	r20, Y+3	; 0x03
    2bc0:	5c 81       	ldd	r21, Y+4	; 0x04
    2bc2:	81 a5       	ldd	r24, Z+41	; 0x29
    2bc4:	92 a5       	ldd	r25, Z+42	; 0x2a
    2bc6:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <_ZN10IMUManager8CheckIDsEP14HardwareSeriali>
            _pHW->print("Ok\n");
    2bca:	d6 01       	movw	r26, r12
    2bcc:	8d 91       	ld	r24, X+
    2bce:	9c 91       	ld	r25, X
    2bd0:	c6 c1       	rjmp	.+908    	; 0x2f5e <_ZN16GyroCmdProcessor4LoopEv+0x49e>
        } else if(strcmp(pCmd,"i2cwr") == 0) {
    2bd2:	c7 01       	movw	r24, r14
    2bd4:	62 e5       	ldi	r22, 0x52	; 82
    2bd6:	72 e2       	ldi	r23, 0x22	; 34
    2bd8:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2bdc:	00 97       	sbiw	r24, 0x00	; 0
    2bde:	09 f0       	breq	.+2      	; 0x2be2 <_ZN16GyroCmdProcessor4LoopEv+0x122>
    2be0:	66 c0       	rjmp	.+204    	; 0x2cae <_ZN16GyroCmdProcessor4LoopEv+0x1ee>
            if (paramCnt() < 4) {
    2be2:	c6 01       	movw	r24, r12
    2be4:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2be8:	84 30       	cpi	r24, 0x04	; 4
    2bea:	20 f4       	brcc	.+8      	; 0x2bf4 <_ZN16GyroCmdProcessor4LoopEv+0x134>
                _pHW->print("Fail:incorrect param count\n");
    2bec:	f6 01       	movw	r30, r12
    2bee:	80 81       	ld	r24, Z
    2bf0:	91 81       	ldd	r25, Z+1	; 0x01
    2bf2:	6d c0       	rjmp	.+218    	; 0x2cce <_ZN16GyroCmdProcessor4LoopEv+0x20e>
            } else {
                uint8_t idx = 0;
    2bf4:	1a 82       	std	Y+2, r1	; 0x02
                uint8_t  ID;
                getParam(0,idx);
    2bf6:	c6 01       	movw	r24, r12
    2bf8:	60 e0       	ldi	r22, 0x00	; 0
    2bfa:	ae 01       	movw	r20, r28
    2bfc:	4e 5f       	subi	r20, 0xFE	; 254
    2bfe:	5f 4f       	sbci	r21, 0xFF	; 255
    2c00:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(1,ID);
    2c04:	c6 01       	movw	r24, r12
    2c06:	61 e0       	ldi	r22, 0x01	; 1
    2c08:	ae 01       	movw	r20, r28
    2c0a:	4d 5f       	subi	r20, 0xFD	; 253
    2c0c:	5f 4f       	sbci	r21, 0xFF	; 255
    2c0e:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                uint8_t* pParams;
                pParams = (uint8_t*)malloc(paramCnt());
    2c12:	c6 01       	movw	r24, r12
    2c14:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2c18:	90 e0       	ldi	r25, 0x00	; 0
    2c1a:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    2c1e:	b8 2e       	mov	r11, r24
    2c20:	a9 2e       	mov	r10, r25
    2c22:	9c 01       	movw	r18, r24
    2c24:	79 01       	movw	r14, r18
    2c26:	02 e0       	ldi	r16, 0x02	; 2
    2c28:	10 e0       	ldi	r17, 0x00	; 0
                for (int x=2;x<paramCnt();x++) {
                    uint8_t p;
                    getParam(x,p);
    2c2a:	75 e0       	ldi	r23, 0x05	; 5
    2c2c:	87 2e       	mov	r8, r23
    2c2e:	91 2c       	mov	r9, r1
    2c30:	8c 0e       	add	r8, r28
    2c32:	9d 1e       	adc	r9, r29
    2c34:	0c c0       	rjmp	.+24     	; 0x2c4e <_ZN16GyroCmdProcessor4LoopEv+0x18e>
    2c36:	87 2d       	mov	r24, r7
    2c38:	96 2d       	mov	r25, r6
    2c3a:	60 2f       	mov	r22, r16
    2c3c:	a4 01       	movw	r20, r8
    2c3e:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                    pParams[x-2] = p;
    2c42:	8d 81       	ldd	r24, Y+5	; 0x05
    2c44:	d7 01       	movw	r26, r14
    2c46:	8d 93       	st	X+, r24
    2c48:	7d 01       	movw	r14, r26
                uint8_t  ID;
                getParam(0,idx);
                getParam(1,ID);
                uint8_t* pParams;
                pParams = (uint8_t*)malloc(paramCnt());
                for (int x=2;x<paramCnt();x++) {
    2c4a:	0f 5f       	subi	r16, 0xFF	; 255
    2c4c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c4e:	87 2d       	mov	r24, r7
    2c50:	96 2d       	mov	r25, r6
    2c52:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	08 17       	cp	r16, r24
    2c5a:	19 07       	cpc	r17, r25
    2c5c:	64 f3       	brlt	.-40     	; 0x2c36 <_ZN16GyroCmdProcessor4LoopEv+0x176>
                    uint8_t p;
                    getParam(x,p);
                    pParams[x-2] = p;
                }
                int retc = _pMaster[idx]->WriteSync(ID, pParams, paramCnt()-2);
    2c5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c60:	f0 e0       	ldi	r31, 0x00	; 0
    2c62:	ee 0f       	add	r30, r30
    2c64:	ff 1f       	adc	r31, r31
    2c66:	ec 0d       	add	r30, r12
    2c68:	fd 1d       	adc	r31, r13
    2c6a:	01 a1       	ldd	r16, Z+33	; 0x21
    2c6c:	12 a1       	ldd	r17, Z+34	; 0x22
    2c6e:	fb 80       	ldd	r15, Y+3	; 0x03
    2c70:	87 2d       	mov	r24, r7
    2c72:	96 2d       	mov	r25, r6
    2c74:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2c78:	28 2f       	mov	r18, r24
    2c7a:	22 50       	subi	r18, 0x02	; 2
    2c7c:	c8 01       	movw	r24, r16
    2c7e:	6f 2d       	mov	r22, r15
    2c80:	4b 2d       	mov	r20, r11
    2c82:	5a 2d       	mov	r21, r10
    2c84:	0e 94 89 28 	call	0x5112	; 0x5112 <_ZN10I2C_Master9WriteSyncEhPhh>
    2c88:	f6 01       	movw	r30, r12
    2c8a:	20 81       	ld	r18, Z
    2c8c:	31 81       	ldd	r19, Z+1	; 0x01
                if (retc < 0) {
    2c8e:	87 ff       	sbrs	r24, 7
    2c90:	04 c0       	rjmp	.+8      	; 0x2c9a <_ZN16GyroCmdProcessor4LoopEv+0x1da>
                    _pHW->println("Fail");
    2c92:	c9 01       	movw	r24, r18
    2c94:	68 e5       	ldi	r22, 0x58	; 88
    2c96:	72 e2       	ldi	r23, 0x22	; 34
    2c98:	03 c0       	rjmp	.+6      	; 0x2ca0 <_ZN16GyroCmdProcessor4LoopEv+0x1e0>
                } else {
                    _pHW->println("Ok");
    2c9a:	c9 01       	movw	r24, r18
    2c9c:	6d e5       	ldi	r22, 0x5D	; 93
    2c9e:	72 e2       	ldi	r23, 0x22	; 34
    2ca0:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
                }
                free(pParams);
    2ca4:	8b 2d       	mov	r24, r11
    2ca6:	9a 2d       	mov	r25, r10
    2ca8:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    2cac:	76 c2       	rjmp	.+1260   	; 0x319a <_ZN16GyroCmdProcessor4LoopEv+0x6da>
            }
        } else if(strcmp(pCmd,"i2crd") == 0) {
    2cae:	c7 01       	movw	r24, r14
    2cb0:	60 e6       	ldi	r22, 0x60	; 96
    2cb2:	72 e2       	ldi	r23, 0x22	; 34
    2cb4:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2cb8:	00 97       	sbiw	r24, 0x00	; 0
    2cba:	09 f0       	breq	.+2      	; 0x2cbe <_ZN16GyroCmdProcessor4LoopEv+0x1fe>
    2cbc:	9d c0       	rjmp	.+314    	; 0x2df8 <_ZN16GyroCmdProcessor4LoopEv+0x338>
            if (paramCnt() < 4) {
    2cbe:	c6 01       	movw	r24, r12
    2cc0:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2cc4:	84 30       	cpi	r24, 0x04	; 4
    2cc6:	30 f4       	brcc	.+12     	; 0x2cd4 <_ZN16GyroCmdProcessor4LoopEv+0x214>
                _pHW->print("Fail:incorrect param count\n");
    2cc8:	d6 01       	movw	r26, r12
    2cca:	8d 91       	ld	r24, X+
    2ccc:	9c 91       	ld	r25, X
    2cce:	62 e1       	ldi	r22, 0x12	; 18
    2cd0:	72 e2       	ldi	r23, 0x22	; 34
    2cd2:	61 c2       	rjmp	.+1218   	; 0x3196 <_ZN16GyroCmdProcessor4LoopEv+0x6d6>
            } else {
                uint8_t idx = 0;
    2cd4:	1d 82       	std	Y+5, r1	; 0x05
                uint8_t  ID;
                uint8_t  nRdBytes;
                uint8_t  addr;
                getParam(0,idx);
    2cd6:	c6 01       	movw	r24, r12
    2cd8:	60 e0       	ldi	r22, 0x00	; 0
    2cda:	ae 01       	movw	r20, r28
    2cdc:	4b 5f       	subi	r20, 0xFB	; 251
    2cde:	5f 4f       	sbci	r21, 0xFF	; 255
    2ce0:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(1,ID);
    2ce4:	c6 01       	movw	r24, r12
    2ce6:	61 e0       	ldi	r22, 0x01	; 1
    2ce8:	ae 01       	movw	r20, r28
    2cea:	4d 5f       	subi	r20, 0xFD	; 253
    2cec:	5f 4f       	sbci	r21, 0xFF	; 255
    2cee:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(2,addr);
    2cf2:	c6 01       	movw	r24, r12
    2cf4:	62 e0       	ldi	r22, 0x02	; 2
    2cf6:	8e 01       	movw	r16, r28
    2cf8:	0f 5f       	subi	r16, 0xFF	; 255
    2cfa:	1f 4f       	sbci	r17, 0xFF	; 255
    2cfc:	a8 01       	movw	r20, r16
    2cfe:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(3,nRdBytes);
    2d02:	c6 01       	movw	r24, r12
    2d04:	63 e0       	ldi	r22, 0x03	; 3
    2d06:	ae 01       	movw	r20, r28
    2d08:	4e 5f       	subi	r20, 0xFE	; 254
    2d0a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d0c:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                int retc = _pMaster[idx]->WriteReadSync(ID, &addr, 1,nRdBytes);
    2d10:	ed 81       	ldd	r30, Y+5	; 0x05
    2d12:	f0 e0       	ldi	r31, 0x00	; 0
    2d14:	ee 0f       	add	r30, r30
    2d16:	ff 1f       	adc	r31, r31
    2d18:	ec 0d       	add	r30, r12
    2d1a:	fd 1d       	adc	r31, r13
    2d1c:	81 a1       	ldd	r24, Z+33	; 0x21
    2d1e:	92 a1       	ldd	r25, Z+34	; 0x22
    2d20:	6b 81       	ldd	r22, Y+3	; 0x03
    2d22:	a8 01       	movw	r20, r16
    2d24:	21 e0       	ldi	r18, 0x01	; 1
    2d26:	0a 81       	ldd	r16, Y+2	; 0x02
    2d28:	0e 94 4a 28 	call	0x5094	; 0x5094 <_ZN10I2C_Master13WriteReadSyncEhPhhh>
    2d2c:	28 2f       	mov	r18, r24
    2d2e:	33 27       	eor	r19, r19
    2d30:	27 fd       	sbrc	r18, 7
    2d32:	30 95       	com	r19
    2d34:	03 eb       	ldi	r16, 0xB3	; 179
    2d36:	17 e2       	ldi	r17, 0x27	; 39
                if (retc < 0) {
    2d38:	37 ff       	sbrs	r19, 7
    2d3a:	12 c0       	rjmp	.+36     	; 0x2d60 <_ZN16GyroCmdProcessor4LoopEv+0x2a0>
                    sprintf(buffer,"Fail:%d\n",retc);
    2d3c:	00 d0       	rcall	.+0      	; 0x2d3e <_ZN16GyroCmdProcessor4LoopEv+0x27e>
    2d3e:	00 d0       	rcall	.+0      	; 0x2d40 <_ZN16GyroCmdProcessor4LoopEv+0x280>
    2d40:	ed b7       	in	r30, 0x3d	; 61
    2d42:	fe b7       	in	r31, 0x3e	; 62
    2d44:	31 96       	adiw	r30, 0x01	; 1
    2d46:	ad b7       	in	r26, 0x3d	; 61
    2d48:	be b7       	in	r27, 0x3e	; 62
    2d4a:	11 96       	adiw	r26, 0x01	; 1
    2d4c:	0d 93       	st	X+, r16
    2d4e:	1c 93       	st	X, r17
    2d50:	12 97       	sbiw	r26, 0x02	; 2
    2d52:	86 e6       	ldi	r24, 0x66	; 102
    2d54:	92 e2       	ldi	r25, 0x22	; 34
    2d56:	82 83       	std	Z+2, r24	; 0x02
    2d58:	93 83       	std	Z+3, r25	; 0x03
    2d5a:	24 83       	std	Z+4, r18	; 0x04
    2d5c:	35 83       	std	Z+5, r19	; 0x05
    2d5e:	10 c2       	rjmp	.+1056   	; 0x3180 <_ZN16GyroCmdProcessor4LoopEv+0x6c0>
                    _pHW->print(buffer);
                } else {
                    char* cp = &buffer[0];
                    int n = sprintf(cp,"Ok:");
    2d60:	c8 01       	movw	r24, r16
    2d62:	6f e6       	ldi	r22, 0x6F	; 111
    2d64:	72 e2       	ldi	r23, 0x22	; 34
    2d66:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
    2d6a:	43 e0       	ldi	r20, 0x03	; 3
    2d6c:	e4 2e       	mov	r14, r20
    2d6e:	f1 2c       	mov	r15, r1
    2d70:	e0 0e       	add	r14, r16
    2d72:	f1 1e       	adc	r15, r17
    2d74:	00 e0       	ldi	r16, 0x00	; 0
    2d76:	10 e0       	ldi	r17, 0x00	; 0
                    cp += n;
                    for (int x=0;x<_pMaster[idx]->nReadBytes();x++) {
                        int n = sprintf(cp,"0x%x ",_pMaster[idx]->ReadData(x));
    2d78:	33 e7       	ldi	r19, 0x73	; 115
    2d7a:	a3 2e       	mov	r10, r19
    2d7c:	32 e2       	ldi	r19, 0x22	; 34
    2d7e:	b3 2e       	mov	r11, r19
    2d80:	25 c0       	rjmp	.+74     	; 0x2dcc <_ZN16GyroCmdProcessor4LoopEv+0x30c>
    2d82:	ed 81       	ldd	r30, Y+5	; 0x05
    2d84:	f0 e0       	ldi	r31, 0x00	; 0
    2d86:	ee 0f       	add	r30, r30
    2d88:	ff 1f       	adc	r31, r31
    2d8a:	ec 0d       	add	r30, r12
    2d8c:	fd 1d       	adc	r31, r13
    2d8e:	81 a1       	ldd	r24, Z+33	; 0x21
    2d90:	92 a1       	ldd	r25, Z+34	; 0x22
    2d92:	60 2f       	mov	r22, r16
    2d94:	0e 94 3c 21 	call	0x4278	; 0x4278 <_ZN10I2C_Master8ReadDataEh>
    2d98:	00 d0       	rcall	.+0      	; 0x2d9a <_ZN16GyroCmdProcessor4LoopEv+0x2da>
    2d9a:	00 d0       	rcall	.+0      	; 0x2d9c <_ZN16GyroCmdProcessor4LoopEv+0x2dc>
    2d9c:	ed b7       	in	r30, 0x3d	; 61
    2d9e:	fe b7       	in	r31, 0x3e	; 62
    2da0:	31 96       	adiw	r30, 0x01	; 1
    2da2:	ad b7       	in	r26, 0x3d	; 61
    2da4:	be b7       	in	r27, 0x3e	; 62
    2da6:	11 96       	adiw	r26, 0x01	; 1
    2da8:	ed 92       	st	X+, r14
    2daa:	fc 92       	st	X, r15
    2dac:	12 97       	sbiw	r26, 0x02	; 2
    2dae:	a2 82       	std	Z+2, r10	; 0x02
    2db0:	b3 82       	std	Z+3, r11	; 0x03
    2db2:	84 83       	std	Z+4, r24	; 0x04
    2db4:	15 82       	std	Z+5, r1	; 0x05
    2db6:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
                        cp += n;
    2dba:	e8 0e       	add	r14, r24
    2dbc:	f9 1e       	adc	r15, r25
                    _pHW->print(buffer);
                } else {
                    char* cp = &buffer[0];
                    int n = sprintf(cp,"Ok:");
                    cp += n;
                    for (int x=0;x<_pMaster[idx]->nReadBytes();x++) {
    2dbe:	0f 5f       	subi	r16, 0xFF	; 255
    2dc0:	1f 4f       	sbci	r17, 0xFF	; 255
    2dc2:	ed b7       	in	r30, 0x3d	; 61
    2dc4:	fe b7       	in	r31, 0x3e	; 62
    2dc6:	36 96       	adiw	r30, 0x06	; 6
    2dc8:	ed bf       	out	0x3d, r30	; 61
    2dca:	fe bf       	out	0x3e, r31	; 62
    2dcc:	ed 81       	ldd	r30, Y+5	; 0x05
    2dce:	f0 e0       	ldi	r31, 0x00	; 0
    2dd0:	ee 0f       	add	r30, r30
    2dd2:	ff 1f       	adc	r31, r31
    2dd4:	ec 0d       	add	r30, r12
    2dd6:	fd 1d       	adc	r31, r13
    2dd8:	81 a1       	ldd	r24, Z+33	; 0x21
    2dda:	92 a1       	ldd	r25, Z+34	; 0x22
    2ddc:	0e 94 4f 21 	call	0x429e	; 0x429e <_ZN10I2C_Master10nReadBytesEv>
    2de0:	90 e0       	ldi	r25, 0x00	; 0
    2de2:	08 17       	cp	r16, r24
    2de4:	19 07       	cpc	r17, r25
    2de6:	6c f2       	brlt	.-102    	; 0x2d82 <_ZN16GyroCmdProcessor4LoopEv+0x2c2>
                        int n = sprintf(cp,"0x%x ",_pMaster[idx]->ReadData(x));
                        cp += n;
                    }
                    _pHW->println(buffer);
    2de8:	d6 01       	movw	r26, r12
    2dea:	8d 91       	ld	r24, X+
    2dec:	9c 91       	ld	r25, X
    2dee:	63 eb       	ldi	r22, 0xB3	; 179
    2df0:	77 e2       	ldi	r23, 0x27	; 39
    2df2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    2df6:	d1 c1       	rjmp	.+930    	; 0x319a <_ZN16GyroCmdProcessor4LoopEv+0x6da>
                }
            }
        } else if(strcmp(pCmd,"streamstart") == 0) {
    2df8:	c7 01       	movw	r24, r14
    2dfa:	69 e7       	ldi	r22, 0x79	; 121
    2dfc:	72 e2       	ldi	r23, 0x22	; 34
    2dfe:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2e02:	00 97       	sbiw	r24, 0x00	; 0
    2e04:	29 f5       	brne	.+74     	; 0x2e50 <_ZN16GyroCmdProcessor4LoopEv+0x390>
            uint16_t bUseGyro = 0;
    2e06:	1b 82       	std	Y+3, r1	; 0x03
    2e08:	1c 82       	std	Y+4, r1	; 0x04
            if (paramCnt() > 0) {
    2e0a:	c6 01       	movw	r24, r12
    2e0c:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2e10:	88 23       	and	r24, r24
    2e12:	39 f0       	breq	.+14     	; 0x2e22 <_ZN16GyroCmdProcessor4LoopEv+0x362>
                getParam(0,bUseGyro);
    2e14:	c6 01       	movw	r24, r12
    2e16:	60 e0       	ldi	r22, 0x00	; 0
    2e18:	ae 01       	movw	r20, r28
    2e1a:	4d 5f       	subi	r20, 0xFD	; 253
    2e1c:	5f 4f       	sbci	r21, 0xFF	; 255
    2e1e:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <_ZN12CmdProcessor8getParamEhRj>
            }
            int retc = _pMgr->StreamStart(bUseGyro == 1);
    2e22:	f6 01       	movw	r30, r12
    2e24:	21 a5       	ldd	r18, Z+41	; 0x29
    2e26:	32 a5       	ldd	r19, Z+42	; 0x2a
    2e28:	60 e0       	ldi	r22, 0x00	; 0
    2e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2e:	01 97       	sbiw	r24, 0x01	; 1
    2e30:	09 f4       	brne	.+2      	; 0x2e34 <_ZN16GyroCmdProcessor4LoopEv+0x374>
    2e32:	61 e0       	ldi	r22, 0x01	; 1
    2e34:	c9 01       	movw	r24, r18
    2e36:	0e 94 d5 13 	call	0x27aa	; 0x27aa <_ZN10IMUManager11StreamStartEb>
    2e3a:	9c 01       	movw	r18, r24
            if (retc < 0) {
    2e3c:	97 ff       	sbrs	r25, 7
    2e3e:	8c c0       	rjmp	.+280    	; 0x2f58 <_ZN16GyroCmdProcessor4LoopEv+0x498>
                sprintf(buffer,"Fail:%d\n",retc);
    2e40:	00 d0       	rcall	.+0      	; 0x2e42 <_ZN16GyroCmdProcessor4LoopEv+0x382>
    2e42:	00 d0       	rcall	.+0      	; 0x2e44 <_ZN16GyroCmdProcessor4LoopEv+0x384>
    2e44:	ed b7       	in	r30, 0x3d	; 61
    2e46:	fe b7       	in	r31, 0x3e	; 62
    2e48:	31 96       	adiw	r30, 0x01	; 1
    2e4a:	03 eb       	ldi	r16, 0xB3	; 179
    2e4c:	17 e2       	ldi	r17, 0x27	; 39
    2e4e:	7b cf       	rjmp	.-266    	; 0x2d46 <_ZN16GyroCmdProcessor4LoopEv+0x286>
                _pHW->print(buffer);
            } else {
                _pHW->print("Ok\n");
            }
        } else if(strcmp(pCmd,"streamstop") == 0) {
    2e50:	c7 01       	movw	r24, r14
    2e52:	65 e8       	ldi	r22, 0x85	; 133
    2e54:	72 e2       	ldi	r23, 0x22	; 34
    2e56:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2e5a:	00 97       	sbiw	r24, 0x00	; 0
    2e5c:	41 f4       	brne	.+16     	; 0x2e6e <_ZN16GyroCmdProcessor4LoopEv+0x3ae>
            _pMgr->Stop();
    2e5e:	d6 01       	movw	r26, r12
    2e60:	99 96       	adiw	r26, 0x29	; 41
    2e62:	8d 91       	ld	r24, X+
    2e64:	9c 91       	ld	r25, X
    2e66:	9a 97       	sbiw	r26, 0x2a	; 42
    2e68:	0e 94 65 10 	call	0x20ca	; 0x20ca <_ZN10IMUManager4StopEv>
    2e6c:	75 c0       	rjmp	.+234    	; 0x2f58 <_ZN16GyroCmdProcessor4LoopEv+0x498>
            _pHW->print("Ok\n");
        } else if(strcmp(pCmd,"wd") == 0) {
    2e6e:	c7 01       	movw	r24, r14
    2e70:	60 e9       	ldi	r22, 0x90	; 144
    2e72:	72 e2       	ldi	r23, 0x22	; 34
    2e74:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2e78:	00 97       	sbiw	r24, 0x00	; 0
    2e7a:	41 f4       	brne	.+16     	; 0x2e8c <_ZN16GyroCmdProcessor4LoopEv+0x3cc>
            // Tell the Stream Manager we are still here
            // Automatically stops if we don't get this after
            // 20 streams..
            _pMgr->StreamWatchdog();
    2e7c:	d6 01       	movw	r26, r12
    2e7e:	99 96       	adiw	r26, 0x29	; 41
    2e80:	8d 91       	ld	r24, X+
    2e82:	9c 91       	ld	r25, X
    2e84:	9a 97       	sbiw	r26, 0x2a	; 42
    2e86:	0e 94 7f 11 	call	0x22fe	; 0x22fe <_ZN10IMUManager14StreamWatchdogEv>
    2e8a:	87 c1       	rjmp	.+782    	; 0x319a <_ZN16GyroCmdProcessor4LoopEv+0x6da>
        } else if(strcmp(pCmd,"dbgport") == 0) {
    2e8c:	c7 01       	movw	r24, r14
    2e8e:	63 e9       	ldi	r22, 0x93	; 147
    2e90:	72 e2       	ldi	r23, 0x22	; 34
    2e92:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2e96:	00 97       	sbiw	r24, 0x00	; 0
    2e98:	79 f4       	brne	.+30     	; 0x2eb8 <_ZN16GyroCmdProcessor4LoopEv+0x3f8>
            uint8_t st;
            getParam(0,st);
    2e9a:	c6 01       	movw	r24, r12
    2e9c:	60 e0       	ldi	r22, 0x00	; 0
    2e9e:	ae 01       	movw	r20, r28
    2ea0:	4f 5f       	subi	r20, 0xFF	; 255
    2ea2:	5f 4f       	sbci	r21, 0xFF	; 255
    2ea4:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
            pdbgport->SetState(st);
    2ea8:	80 91 2c 26 	lds	r24, 0x262C
    2eac:	90 91 2d 26 	lds	r25, 0x262D
    2eb0:	69 81       	ldd	r22, Y+1	; 0x01
    2eb2:	0e 94 7d 20 	call	0x40fa	; 0x40fa <_ZN9DebugPort8SetStateEh>
    2eb6:	50 c0       	rjmp	.+160    	; 0x2f58 <_ZN16GyroCmdProcessor4LoopEv+0x498>
            _pHW->print("Ok\n");
        } else if(strcmp(pCmd,"force_startstop") == 0) {
    2eb8:	c7 01       	movw	r24, r14
    2eba:	6b e9       	ldi	r22, 0x9B	; 155
    2ebc:	72 e2       	ldi	r23, 0x22	; 34
    2ebe:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2ec2:	00 97       	sbiw	r24, 0x00	; 0
    2ec4:	41 f4       	brne	.+16     	; 0x2ed6 <_ZN16GyroCmdProcessor4LoopEv+0x416>
            _pMgr->ForceStartStop();
    2ec6:	d6 01       	movw	r26, r12
    2ec8:	99 96       	adiw	r26, 0x29	; 41
    2eca:	8d 91       	ld	r24, X+
    2ecc:	9c 91       	ld	r25, X
    2ece:	9a 97       	sbiw	r26, 0x2a	; 42
    2ed0:	0e 94 db 10 	call	0x21b6	; 0x21b6 <_ZN10IMUManager14ForceStartStopEv>
    2ed4:	55 c0       	rjmp	.+170    	; 0x2f80 <_ZN16GyroCmdProcessor4LoopEv+0x4c0>
            sprintf(buffer,"Ok\n");
            _pHW->print(buffer);
        } else if(strcmp(pCmd,"wiggle") == 0) {
    2ed6:	c7 01       	movw	r24, r14
    2ed8:	6b ea       	ldi	r22, 0xAB	; 171
    2eda:	72 e2       	ldi	r23, 0x22	; 34
    2edc:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2ee0:	00 97       	sbiw	r24, 0x00	; 0
    2ee2:	09 f0       	breq	.+2      	; 0x2ee6 <_ZN16GyroCmdProcessor4LoopEv+0x426>
    2ee4:	3f c0       	rjmp	.+126    	; 0x2f64 <_ZN16GyroCmdProcessor4LoopEv+0x4a4>
            uint8_t  idx;
            uint16_t cnt;
            uint8_t pinA;
            uint8_t pinB;
            if (paramCnt() < 4) {
    2ee6:	8c 2d       	mov	r24, r12
    2ee8:	9d 2d       	mov	r25, r13
    2eea:	0e 94 5e 19 	call	0x32bc	; 0x32bc <_ZN12CmdProcessor8paramCntEv>
    2eee:	84 30       	cpi	r24, 0x04	; 4
    2ef0:	30 f4       	brcc	.+12     	; 0x2efe <_ZN16GyroCmdProcessor4LoopEv+0x43e>
                _pHW->print("Fail:Invalid Param Count\n");
    2ef2:	d6 01       	movw	r26, r12
    2ef4:	8d 91       	ld	r24, X+
    2ef6:	9c 91       	ld	r25, X
    2ef8:	62 eb       	ldi	r22, 0xB2	; 178
    2efa:	72 e2       	ldi	r23, 0x22	; 34
    2efc:	4c c1       	rjmp	.+664    	; 0x3196 <_ZN16GyroCmdProcessor4LoopEv+0x6d6>
            } else {
                getParam(0,idx);
    2efe:	8c 2d       	mov	r24, r12
    2f00:	9d 2d       	mov	r25, r13
    2f02:	60 e0       	ldi	r22, 0x00	; 0
    2f04:	ae 01       	movw	r20, r28
    2f06:	4f 5f       	subi	r20, 0xFF	; 255
    2f08:	5f 4f       	sbci	r21, 0xFF	; 255
    2f0a:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(1,cnt);
    2f0e:	8c 2d       	mov	r24, r12
    2f10:	9d 2d       	mov	r25, r13
    2f12:	61 e0       	ldi	r22, 0x01	; 1
    2f14:	ae 01       	movw	r20, r28
    2f16:	4b 5f       	subi	r20, 0xFB	; 251
    2f18:	5f 4f       	sbci	r21, 0xFF	; 255
    2f1a:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <_ZN12CmdProcessor8getParamEhRj>
                getParam(2,pinA);
    2f1e:	8c 2d       	mov	r24, r12
    2f20:	9d 2d       	mov	r25, r13
    2f22:	62 e0       	ldi	r22, 0x02	; 2
    2f24:	ae 01       	movw	r20, r28
    2f26:	4e 5f       	subi	r20, 0xFE	; 254
    2f28:	5f 4f       	sbci	r21, 0xFF	; 255
    2f2a:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                getParam(3,pinB);
    2f2e:	8c 2d       	mov	r24, r12
    2f30:	9d 2d       	mov	r25, r13
    2f32:	63 e0       	ldi	r22, 0x03	; 3
    2f34:	ae 01       	movw	r20, r28
    2f36:	4d 5f       	subi	r20, 0xFD	; 253
    2f38:	5f 4f       	sbci	r21, 0xFF	; 255
    2f3a:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <_ZN12CmdProcessor8getParamEhRh>
                _pMaster[idx]->WigglePin(cnt,pinA, pinB);
    2f3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f40:	f0 e0       	ldi	r31, 0x00	; 0
    2f42:	ee 0f       	add	r30, r30
    2f44:	ff 1f       	adc	r31, r31
    2f46:	ec 0d       	add	r30, r12
    2f48:	fd 1d       	adc	r31, r13
    2f4a:	81 a1       	ldd	r24, Z+33	; 0x21
    2f4c:	92 a1       	ldd	r25, Z+34	; 0x22
    2f4e:	6d 81       	ldd	r22, Y+5	; 0x05
    2f50:	4a 81       	ldd	r20, Y+2	; 0x02
    2f52:	2b 81       	ldd	r18, Y+3	; 0x03
    2f54:	0e 94 07 22 	call	0x440e	; 0x440e <_ZN10I2C_Master9WigglePinEhhh>
                _pHW->print("Ok\n");
    2f58:	f6 01       	movw	r30, r12
    2f5a:	80 81       	ld	r24, Z
    2f5c:	91 81       	ldd	r25, Z+1	; 0x01
    2f5e:	6e e4       	ldi	r22, 0x4E	; 78
    2f60:	72 e2       	ldi	r23, 0x22	; 34
    2f62:	19 c1       	rjmp	.+562    	; 0x3196 <_ZN16GyroCmdProcessor4LoopEv+0x6d6>
            }
        } else if(strcmp(pCmd,"reset") == 0) {
    2f64:	c7 01       	movw	r24, r14
    2f66:	6c ec       	ldi	r22, 0xCC	; 204
    2f68:	72 e2       	ldi	r23, 0x22	; 34
    2f6a:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2f6e:	00 97       	sbiw	r24, 0x00	; 0
    2f70:	61 f4       	brne	.+24     	; 0x2f8a <_ZN16GyroCmdProcessor4LoopEv+0x4ca>
            _pMgr->Reset();
    2f72:	d6 01       	movw	r26, r12
    2f74:	99 96       	adiw	r26, 0x29	; 41
    2f76:	8d 91       	ld	r24, X+
    2f78:	9c 91       	ld	r25, X
    2f7a:	9a 97       	sbiw	r26, 0x2a	; 42
    2f7c:	0e 94 95 10 	call	0x212a	; 0x212a <_ZN10IMUManager5ResetEv>
            sprintf(buffer,"Ok\n");
    2f80:	83 eb       	ldi	r24, 0xB3	; 179
    2f82:	97 e2       	ldi	r25, 0x27	; 39
    2f84:	6e e4       	ldi	r22, 0x4E	; 78
    2f86:	72 e2       	ldi	r23, 0x22	; 34
    2f88:	b1 c0       	rjmp	.+354    	; 0x30ec <_ZN16GyroCmdProcessor4LoopEv+0x62c>
            _pHW->print(buffer);
        } else if(strcmp(pCmd,"devreset") == 0) {
    2f8a:	c7 01       	movw	r24, r14
    2f8c:	62 ed       	ldi	r22, 0xD2	; 210
    2f8e:	72 e2       	ldi	r23, 0x22	; 34
    2f90:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2f94:	00 97       	sbiw	r24, 0x00	; 0
    2f96:	41 f4       	brne	.+16     	; 0x2fa8 <_ZN16GyroCmdProcessor4LoopEv+0x4e8>
            _pMgr->ResetDevices();
    2f98:	d6 01       	movw	r26, r12
    2f9a:	99 96       	adiw	r26, 0x29	; 41
    2f9c:	8d 91       	ld	r24, X+
    2f9e:	9c 91       	ld	r25, X
    2fa0:	9a 97       	sbiw	r26, 0x2a	; 42
    2fa2:	0e 94 bc 10 	call	0x2178	; 0x2178 <_ZN10IMUManager12ResetDevicesEv>
    2fa6:	ec cf       	rjmp	.-40     	; 0x2f80 <_ZN16GyroCmdProcessor4LoopEv+0x4c0>
            sprintf(buffer,"Ok\n");
            _pHW->print(buffer);
        } else if(strcmp(pCmd,"rate") == 0) {
    2fa8:	c7 01       	movw	r24, r14
    2faa:	6b ed       	ldi	r22, 0xDB	; 219
    2fac:	72 e2       	ldi	r23, 0x22	; 34
    2fae:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    2fb2:	00 97       	sbiw	r24, 0x00	; 0
    2fb4:	39 f5       	brne	.+78     	; 0x3004 <_ZN16GyroCmdProcessor4LoopEv+0x544>
            uint16_t rate;
            getParam(0,rate);
    2fb6:	8c 2d       	mov	r24, r12
    2fb8:	9d 2d       	mov	r25, r13
    2fba:	60 e0       	ldi	r22, 0x00	; 0
    2fbc:	ae 01       	movw	r20, r28
    2fbe:	4b 5f       	subi	r20, 0xFB	; 251
    2fc0:	5f 4f       	sbci	r21, 0xFF	; 255
    2fc2:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <_ZN12CmdProcessor8getParamEhRj>
            _pMgr->SampleRate(rate);
    2fc6:	6d 81       	ldd	r22, Y+5	; 0x05
    2fc8:	7e 81       	ldd	r23, Y+6	; 0x06
    2fca:	d6 01       	movw	r26, r12
    2fcc:	99 96       	adiw	r26, 0x29	; 41
    2fce:	8d 91       	ld	r24, X+
    2fd0:	9c 91       	ld	r25, X
    2fd2:	9a 97       	sbiw	r26, 0x2a	; 42
    2fd4:	0e 94 30 12 	call	0x2460	; 0x2460 <_ZN10IMUManager10SampleRateEj>
            sprintf(buffer,"Ok:%d\n",rate);
    2fd8:	00 d0       	rcall	.+0      	; 0x2fda <_ZN16GyroCmdProcessor4LoopEv+0x51a>
    2fda:	00 d0       	rcall	.+0      	; 0x2fdc <_ZN16GyroCmdProcessor4LoopEv+0x51c>
    2fdc:	ed b7       	in	r30, 0x3d	; 61
    2fde:	fe b7       	in	r31, 0x3e	; 62
    2fe0:	31 96       	adiw	r30, 0x01	; 1
    2fe2:	03 eb       	ldi	r16, 0xB3	; 179
    2fe4:	17 e2       	ldi	r17, 0x27	; 39
    2fe6:	ad b7       	in	r26, 0x3d	; 61
    2fe8:	be b7       	in	r27, 0x3e	; 62
    2fea:	11 96       	adiw	r26, 0x01	; 1
    2fec:	0d 93       	st	X+, r16
    2fee:	1c 93       	st	X, r17
    2ff0:	12 97       	sbiw	r26, 0x02	; 2
    2ff2:	80 ee       	ldi	r24, 0xE0	; 224
    2ff4:	92 e2       	ldi	r25, 0x22	; 34
    2ff6:	82 83       	std	Z+2, r24	; 0x02
    2ff8:	93 83       	std	Z+3, r25	; 0x03
    2ffa:	8d 81       	ldd	r24, Y+5	; 0x05
    2ffc:	9e 81       	ldd	r25, Y+6	; 0x06
    2ffe:	84 83       	std	Z+4, r24	; 0x04
    3000:	95 83       	std	Z+5, r25	; 0x05
    3002:	be c0       	rjmp	.+380    	; 0x3180 <_ZN16GyroCmdProcessor4LoopEv+0x6c0>
            _pHW->print(buffer);
        } else if(strcmp(pCmd,"settime") == 0) {
    3004:	c7 01       	movw	r24, r14
    3006:	67 ee       	ldi	r22, 0xE7	; 231
    3008:	72 e2       	ldi	r23, 0x22	; 34
    300a:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    300e:	00 97       	sbiw	r24, 0x00	; 0
    3010:	49 f4       	brne	.+18     	; 0x3024 <_ZN16GyroCmdProcessor4LoopEv+0x564>
            uint16_t tval;
            getParam(0,tval);
    3012:	8c 2d       	mov	r24, r12
    3014:	9d 2d       	mov	r25, r13
    3016:	60 e0       	ldi	r22, 0x00	; 0
    3018:	ae 01       	movw	r20, r28
    301a:	4b 5f       	subi	r20, 0xFB	; 251
    301c:	5f 4f       	sbci	r21, 0xFF	; 255
    301e:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <_ZN12CmdProcessor8getParamEhRj>
    3022:	ae cf       	rjmp	.-164    	; 0x2f80 <_ZN16GyroCmdProcessor4LoopEv+0x4c0>
            sprintf(buffer,"Ok\n");
            _pHW->print(buffer);
        } else if(strcmp(pCmd,"gettime") == 0) {
    3024:	c7 01       	movw	r24, r14
    3026:	6f ee       	ldi	r22, 0xEF	; 239
    3028:	72 e2       	ldi	r23, 0x22	; 34
    302a:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    302e:	00 97       	sbiw	r24, 0x00	; 0
    3030:	a1 f4       	brne	.+40     	; 0x305a <_ZN16GyroCmdProcessor4LoopEv+0x59a>
            sprintf(buffer,"Ok:%d\n",0);
    3032:	00 d0       	rcall	.+0      	; 0x3034 <_ZN16GyroCmdProcessor4LoopEv+0x574>
    3034:	00 d0       	rcall	.+0      	; 0x3036 <_ZN16GyroCmdProcessor4LoopEv+0x576>
    3036:	ed b7       	in	r30, 0x3d	; 61
    3038:	fe b7       	in	r31, 0x3e	; 62
    303a:	31 96       	adiw	r30, 0x01	; 1
    303c:	03 eb       	ldi	r16, 0xB3	; 179
    303e:	17 e2       	ldi	r17, 0x27	; 39
    3040:	ad b7       	in	r26, 0x3d	; 61
    3042:	be b7       	in	r27, 0x3e	; 62
    3044:	11 96       	adiw	r26, 0x01	; 1
    3046:	0d 93       	st	X+, r16
    3048:	1c 93       	st	X, r17
    304a:	12 97       	sbiw	r26, 0x02	; 2
    304c:	80 ee       	ldi	r24, 0xE0	; 224
    304e:	92 e2       	ldi	r25, 0x22	; 34
    3050:	82 83       	std	Z+2, r24	; 0x02
    3052:	93 83       	std	Z+3, r25	; 0x03
    3054:	14 82       	std	Z+4, r1	; 0x04
    3056:	15 82       	std	Z+5, r1	; 0x05
    3058:	93 c0       	rjmp	.+294    	; 0x3180 <_ZN16GyroCmdProcessor4LoopEv+0x6c0>
            _pHW->print(buffer);
        } else if(strcmp(pCmd,"baudquery") == 0) {
    305a:	c7 01       	movw	r24, r14
    305c:	67 ef       	ldi	r22, 0xF7	; 247
    305e:	72 e2       	ldi	r23, 0x22	; 34
    3060:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    3064:	00 97       	sbiw	r24, 0x00	; 0
    3066:	01 f5       	brne	.+64     	; 0x30a8 <_ZN16GyroCmdProcessor4LoopEv+0x5e8>
            sprintf(buffer,"Ok:0x%x 0x%x\n",
                USARTD0.BAUDCTRLA,USARTD0.BAUDCTRLB);
    3068:	20 91 a6 09 	lds	r18, 0x09A6
    306c:	30 91 a7 09 	lds	r19, 0x09A7
    3070:	ed b7       	in	r30, 0x3d	; 61
    3072:	fe b7       	in	r31, 0x3e	; 62
    3074:	38 97       	sbiw	r30, 0x08	; 8
    3076:	ed bf       	out	0x3d, r30	; 61
    3078:	fe bf       	out	0x3e, r31	; 62
    307a:	31 96       	adiw	r30, 0x01	; 1
    307c:	03 eb       	ldi	r16, 0xB3	; 179
    307e:	17 e2       	ldi	r17, 0x27	; 39
    3080:	ad b7       	in	r26, 0x3d	; 61
    3082:	be b7       	in	r27, 0x3e	; 62
    3084:	11 96       	adiw	r26, 0x01	; 1
    3086:	0d 93       	st	X+, r16
    3088:	1c 93       	st	X, r17
    308a:	12 97       	sbiw	r26, 0x02	; 2
    308c:	81 e0       	ldi	r24, 0x01	; 1
    308e:	93 e2       	ldi	r25, 0x23	; 35
    3090:	82 83       	std	Z+2, r24	; 0x02
    3092:	93 83       	std	Z+3, r25	; 0x03
    3094:	24 83       	std	Z+4, r18	; 0x04
    3096:	15 82       	std	Z+5, r1	; 0x05
    3098:	36 83       	std	Z+6, r19	; 0x06
    309a:	17 82       	std	Z+7, r1	; 0x07
    309c:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
            _pHW->print(buffer);
    30a0:	ed b7       	in	r30, 0x3d	; 61
    30a2:	fe b7       	in	r31, 0x3e	; 62
    30a4:	38 96       	adiw	r30, 0x08	; 8
    30a6:	71 c0       	rjmp	.+226    	; 0x318a <_ZN16GyroCmdProcessor4LoopEv+0x6ca>
        } else if(strcmp(pCmd,"debug") == 0) {
    30a8:	c7 01       	movw	r24, r14
    30aa:	6f e0       	ldi	r22, 0x0F	; 15
    30ac:	73 e2       	ldi	r23, 0x23	; 35
    30ae:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    30b2:	00 97       	sbiw	r24, 0x00	; 0
    30b4:	19 f5       	brne	.+70     	; 0x30fc <_ZN16GyroCmdProcessor4LoopEv+0x63c>
            uint16_t tf;
            getParam(0,tf);
    30b6:	8c 2d       	mov	r24, r12
    30b8:	9d 2d       	mov	r25, r13
    30ba:	60 e0       	ldi	r22, 0x00	; 0
    30bc:	ae 01       	movw	r20, r28
    30be:	4b 5f       	subi	r20, 0xFB	; 251
    30c0:	5f 4f       	sbci	r21, 0xFF	; 255
    30c2:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <_ZN12CmdProcessor8getParamEhRj>
            if (tf) {
    30c6:	8d 81       	ldd	r24, Y+5	; 0x05
    30c8:	9e 81       	ldd	r25, Y+6	; 0x06
    30ca:	20 91 2a 26 	lds	r18, 0x262A
    30ce:	30 91 2b 26 	lds	r19, 0x262B
    30d2:	89 2b       	or	r24, r25
    30d4:	19 f0       	breq	.+6      	; 0x30dc <_ZN16GyroCmdProcessor4LoopEv+0x61c>
                pdbgserial->enable(true);
    30d6:	c9 01       	movw	r24, r18
    30d8:	61 e0       	ldi	r22, 0x01	; 1
    30da:	02 c0       	rjmp	.+4      	; 0x30e0 <_ZN16GyroCmdProcessor4LoopEv+0x620>
            } else {
                pdbgserial->enable(false);
    30dc:	c9 01       	movw	r24, r18
    30de:	60 e0       	ldi	r22, 0x00	; 0
    30e0:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <_ZN14HardwareSerial6enableEb>
            }
            sprintf(buffer,"Ok:\n");
    30e4:	83 eb       	ldi	r24, 0xB3	; 179
    30e6:	97 e2       	ldi	r25, 0x27	; 39
    30e8:	65 e1       	ldi	r22, 0x15	; 21
    30ea:	73 e2       	ldi	r23, 0x23	; 35
    30ec:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
            _pHW->print(buffer);
    30f0:	f6 01       	movw	r30, r12
    30f2:	80 81       	ld	r24, Z
    30f4:	91 81       	ldd	r25, Z+1	; 0x01
    30f6:	63 eb       	ldi	r22, 0xB3	; 179
    30f8:	77 e2       	ldi	r23, 0x27	; 39
    30fa:	4d c0       	rjmp	.+154    	; 0x3196 <_ZN16GyroCmdProcessor4LoopEv+0x6d6>
        } else if(strcmp(pCmd,"fast") == 0) {
    30fc:	c7 01       	movw	r24, r14
    30fe:	6a e1       	ldi	r22, 0x1A	; 26
    3100:	73 e2       	ldi	r23, 0x23	; 35
    3102:	0e 94 52 4b 	call	0x96a4	; 0x96a4 <strcmp>
    3106:	00 97       	sbiw	r24, 0x00	; 0
    3108:	41 f5       	brne	.+80     	; 0x315a <_ZN16GyroCmdProcessor4LoopEv+0x69a>
            // Try and switch the command interface into fast mode.. 
            // see if this actually works!!
            uint16_t tf;
            getParam(0,tf);
    310a:	8c 2d       	mov	r24, r12
    310c:	9d 2d       	mov	r25, r13
    310e:	60 e0       	ldi	r22, 0x00	; 0
    3110:	ae 01       	movw	r20, r28
    3112:	4b 5f       	subi	r20, 0xFB	; 251
    3114:	5f 4f       	sbci	r21, 0xFF	; 255
    3116:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <_ZN12CmdProcessor8getParamEhRj>
            if (tf) {
    311a:	8d 81       	ldd	r24, Y+5	; 0x05
    311c:	9e 81       	ldd	r25, Y+6	; 0x06
    311e:	d6 01       	movw	r26, r12
    3120:	2d 91       	ld	r18, X+
    3122:	3c 91       	ld	r19, X
    3124:	89 2b       	or	r24, r25
    3126:	59 f0       	breq	.+22     	; 0x313e <_ZN16GyroCmdProcessor4LoopEv+0x67e>
                _pHW->end();
    3128:	c9 01       	movw	r24, r18
    312a:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN14HardwareSerial3endEv>
                _pHW->begin(489795);
    312e:	f6 01       	movw	r30, r12
    3130:	80 81       	ld	r24, Z
    3132:	91 81       	ldd	r25, Z+1	; 0x01
    3134:	43 e4       	ldi	r20, 0x43	; 67
    3136:	59 e7       	ldi	r21, 0x79	; 121
    3138:	67 e0       	ldi	r22, 0x07	; 7
    313a:	70 e0       	ldi	r23, 0x00	; 0
    313c:	0a c0       	rjmp	.+20     	; 0x3152 <_ZN16GyroCmdProcessor4LoopEv+0x692>
            } else {
                _pHW->end();
    313e:	c9 01       	movw	r24, r18
    3140:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN14HardwareSerial3endEv>
                _pHW->begin(115200);
    3144:	d6 01       	movw	r26, r12
    3146:	8d 91       	ld	r24, X+
    3148:	9c 91       	ld	r25, X
    314a:	40 e0       	ldi	r20, 0x00	; 0
    314c:	52 ec       	ldi	r21, 0xC2	; 194
    314e:	61 e0       	ldi	r22, 0x01	; 1
    3150:	70 e0       	ldi	r23, 0x00	; 0
    3152:	20 e0       	ldi	r18, 0x00	; 0
    3154:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_ZN14HardwareSerial5beginEla>
    3158:	20 c0       	rjmp	.+64     	; 0x319a <_ZN16GyroCmdProcessor4LoopEv+0x6da>
            }
        } else {
            sprintf(buffer,"Fail:This is an Invalid Cmd:%s\n",pCmd);
    315a:	00 d0       	rcall	.+0      	; 0x315c <_ZN16GyroCmdProcessor4LoopEv+0x69c>
    315c:	00 d0       	rcall	.+0      	; 0x315e <_ZN16GyroCmdProcessor4LoopEv+0x69e>
    315e:	ed b7       	in	r30, 0x3d	; 61
    3160:	fe b7       	in	r31, 0x3e	; 62
    3162:	31 96       	adiw	r30, 0x01	; 1
    3164:	03 eb       	ldi	r16, 0xB3	; 179
    3166:	17 e2       	ldi	r17, 0x27	; 39
    3168:	ad b7       	in	r26, 0x3d	; 61
    316a:	be b7       	in	r27, 0x3e	; 62
    316c:	11 96       	adiw	r26, 0x01	; 1
    316e:	0d 93       	st	X+, r16
    3170:	1c 93       	st	X, r17
    3172:	12 97       	sbiw	r26, 0x02	; 2
    3174:	8f e1       	ldi	r24, 0x1F	; 31
    3176:	93 e2       	ldi	r25, 0x23	; 35
    3178:	82 83       	std	Z+2, r24	; 0x02
    317a:	93 83       	std	Z+3, r25	; 0x03
    317c:	e4 82       	std	Z+4, r14	; 0x04
    317e:	f5 82       	std	Z+5, r15	; 0x05
    3180:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
            _pHW->print(buffer);
    3184:	ed b7       	in	r30, 0x3d	; 61
    3186:	fe b7       	in	r31, 0x3e	; 62
    3188:	36 96       	adiw	r30, 0x06	; 6
    318a:	ed bf       	out	0x3d, r30	; 61
    318c:	fe bf       	out	0x3e, r31	; 62
    318e:	d6 01       	movw	r26, r12
    3190:	8d 91       	ld	r24, X+
    3192:	9c 91       	ld	r25, X
    3194:	b8 01       	movw	r22, r16
    3196:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
        }

        resetCmd();
    319a:	87 2d       	mov	r24, r7
    319c:	96 2d       	mov	r25, r6
    319e:	0e 94 55 19 	call	0x32aa	; 0x32aa <_ZN12CmdProcessor8resetCmdEv>
    }
}
    31a2:	26 96       	adiw	r28, 0x06	; 6
    31a4:	cd bf       	out	0x3d, r28	; 61
    31a6:	de bf       	out	0x3e, r29	; 62
    31a8:	cf 91       	pop	r28
    31aa:	df 91       	pop	r29
    31ac:	1f 91       	pop	r17
    31ae:	0f 91       	pop	r16
    31b0:	ff 90       	pop	r15
    31b2:	ef 90       	pop	r14
    31b4:	df 90       	pop	r13
    31b6:	cf 90       	pop	r12
    31b8:	bf 90       	pop	r11
    31ba:	af 90       	pop	r10
    31bc:	9f 90       	pop	r9
    31be:	8f 90       	pop	r8
    31c0:	7f 90       	pop	r7
    31c2:	6f 90       	pop	r6
    31c4:	08 95       	ret

000031c6 <_ZN16GyroCmdProcessorD1Ev>:
    _pMgr = pMgr;
}

GyroCmdProcessor::~GyroCmdProcessor()
{
}
    31c6:	0e 94 37 1b 	call	0x366e	; 0x366e <_ZN12CmdProcessorD2Ev>
    31ca:	08 95       	ret

000031cc <_ZN16GyroCmdProcessorD2Ev>:
    31cc:	0e 94 37 1b 	call	0x366e	; 0x366e <_ZN12CmdProcessorD2Ev>
    31d0:	08 95       	ret

000031d2 <_ZN16GyroCmdProcessorC1EP14HardwareSerialPP10I2C_MasterP10IMUManager>:

GyroCmdProcessor::GyroCmdProcessor(
        HardwareSerial*     pHW,
        I2C_Master**        pMasterList,
        IMUManager*         pMgr
    ) : CmdProcessor(pHW)
    31d2:	cf 92       	push	r12
    31d4:	df 92       	push	r13
    31d6:	ef 92       	push	r14
    31d8:	ff 92       	push	r15
    31da:	0f 93       	push	r16
    31dc:	1f 93       	push	r17
    31de:	8c 01       	movw	r16, r24
    31e0:	7a 01       	movw	r14, r20
    31e2:	69 01       	movw	r12, r18
    31e4:	0e 94 f3 1a 	call	0x35e6	; 0x35e6 <_ZN12CmdProcessorC2EP14HardwareSerial>
{
    for (int x=0;x<4;x++) {
        _pMaster[x] = (*pMasterList+x);
    31e8:	f7 01       	movw	r30, r14
    31ea:	80 81       	ld	r24, Z
    31ec:	91 81       	ldd	r25, Z+1	; 0x01
    31ee:	f8 01       	movw	r30, r16
    31f0:	81 a3       	std	Z+33, r24	; 0x21
    31f2:	92 a3       	std	Z+34, r25	; 0x22
    31f4:	f7 01       	movw	r30, r14
    31f6:	80 81       	ld	r24, Z
    31f8:	91 81       	ldd	r25, Z+1	; 0x01
    31fa:	88 56       	subi	r24, 0x68	; 104
    31fc:	9f 4f       	sbci	r25, 0xFF	; 255
    31fe:	f8 01       	movw	r30, r16
    3200:	83 a3       	std	Z+35, r24	; 0x23
    3202:	94 a3       	std	Z+36, r25	; 0x24
    3204:	f7 01       	movw	r30, r14
    3206:	80 81       	ld	r24, Z
    3208:	91 81       	ldd	r25, Z+1	; 0x01
    320a:	80 5d       	subi	r24, 0xD0	; 208
    320c:	9e 4f       	sbci	r25, 0xFE	; 254
    320e:	f8 01       	movw	r30, r16
    3210:	85 a3       	std	Z+37, r24	; 0x25
    3212:	96 a3       	std	Z+38, r25	; 0x26
    3214:	f7 01       	movw	r30, r14
    3216:	80 81       	ld	r24, Z
    3218:	91 81       	ldd	r25, Z+1	; 0x01
    321a:	88 53       	subi	r24, 0x38	; 56
    321c:	9e 4f       	sbci	r25, 0xFE	; 254
    321e:	f8 01       	movw	r30, r16
    3220:	87 a3       	std	Z+39, r24	; 0x27
    3222:	90 a7       	std	Z+40, r25	; 0x28
    }
    _pMgr = pMgr;
    3224:	c1 a6       	std	Z+41, r12	; 0x29
    3226:	d2 a6       	std	Z+42, r13	; 0x2a
}
    3228:	1f 91       	pop	r17
    322a:	0f 91       	pop	r16
    322c:	ff 90       	pop	r15
    322e:	ef 90       	pop	r14
    3230:	df 90       	pop	r13
    3232:	cf 90       	pop	r12
    3234:	08 95       	ret

00003236 <_ZN16GyroCmdProcessorC2EP14HardwareSerialPP10I2C_MasterP10IMUManager>:

GyroCmdProcessor::GyroCmdProcessor(
        HardwareSerial*     pHW,
        I2C_Master**        pMasterList,
        IMUManager*         pMgr
    ) : CmdProcessor(pHW)
    3236:	cf 92       	push	r12
    3238:	df 92       	push	r13
    323a:	ef 92       	push	r14
    323c:	ff 92       	push	r15
    323e:	0f 93       	push	r16
    3240:	1f 93       	push	r17
    3242:	8c 01       	movw	r16, r24
    3244:	7a 01       	movw	r14, r20
    3246:	69 01       	movw	r12, r18
    3248:	0e 94 f3 1a 	call	0x35e6	; 0x35e6 <_ZN12CmdProcessorC2EP14HardwareSerial>
{
    for (int x=0;x<4;x++) {
        _pMaster[x] = (*pMasterList+x);
    324c:	f7 01       	movw	r30, r14
    324e:	80 81       	ld	r24, Z
    3250:	91 81       	ldd	r25, Z+1	; 0x01
    3252:	f8 01       	movw	r30, r16
    3254:	81 a3       	std	Z+33, r24	; 0x21
    3256:	92 a3       	std	Z+34, r25	; 0x22
    3258:	f7 01       	movw	r30, r14
    325a:	80 81       	ld	r24, Z
    325c:	91 81       	ldd	r25, Z+1	; 0x01
    325e:	88 56       	subi	r24, 0x68	; 104
    3260:	9f 4f       	sbci	r25, 0xFF	; 255
    3262:	f8 01       	movw	r30, r16
    3264:	83 a3       	std	Z+35, r24	; 0x23
    3266:	94 a3       	std	Z+36, r25	; 0x24
    3268:	f7 01       	movw	r30, r14
    326a:	80 81       	ld	r24, Z
    326c:	91 81       	ldd	r25, Z+1	; 0x01
    326e:	80 5d       	subi	r24, 0xD0	; 208
    3270:	9e 4f       	sbci	r25, 0xFE	; 254
    3272:	f8 01       	movw	r30, r16
    3274:	85 a3       	std	Z+37, r24	; 0x25
    3276:	96 a3       	std	Z+38, r25	; 0x26
    3278:	f7 01       	movw	r30, r14
    327a:	80 81       	ld	r24, Z
    327c:	91 81       	ldd	r25, Z+1	; 0x01
    327e:	88 53       	subi	r24, 0x38	; 56
    3280:	9e 4f       	sbci	r25, 0xFE	; 254
    3282:	f8 01       	movw	r30, r16
    3284:	87 a3       	std	Z+39, r24	; 0x27
    3286:	90 a7       	std	Z+40, r25	; 0x28
    }
    _pMgr = pMgr;
    3288:	c1 a6       	std	Z+41, r12	; 0x29
    328a:	d2 a6       	std	Z+42, r13	; 0x2a
}
    328c:	1f 91       	pop	r17
    328e:	0f 91       	pop	r16
    3290:	ff 90       	pop	r15
    3292:	ef 90       	pop	r14
    3294:	df 90       	pop	r13
    3296:	cf 90       	pop	r12
    3298:	08 95       	ret

0000329a <_ZN12CmdProcessor7cmdTermEv>:
    free(_pCmdDelim);
    free(_pCmdTerm);
}

//! Return pointer to termination string.
char* CmdProcessor::cmdTerm() { return _pCmdTerm; }
    329a:	fc 01       	movw	r30, r24
    329c:	84 8d       	ldd	r24, Z+28	; 0x1c
    329e:	95 8d       	ldd	r25, Z+29	; 0x1d
    32a0:	08 95       	ret

000032a2 <_ZN12CmdProcessor8cmdDelimEv>:
    _pCmdTerm = (char*)malloc(strlen(t) + 1);
    strcpy(_pCmdTerm,t);
}

//! Return current delimiter string.
const char* CmdProcessor::cmdDelim()
    32a2:	fc 01       	movw	r30, r24
{
    return _pCmdDelim;
}
    32a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    32a6:	97 8d       	ldd	r25, Z+31	; 0x1f
    32a8:	08 95       	ret

000032aa <_ZN12CmdProcessor8resetCmdEv>:
        _validCmd = true;
    }
}

//! Clear the command status values so a new command can be started.
void CmdProcessor::resetCmd()
    32aa:	fc 01       	movw	r30, r24
{
    _cmdPos = 0;
    32ac:	12 8e       	std	Z+26, r1	; 0x1a
    _validCmd = false;
    32ae:	13 8e       	std	Z+27, r1	; 0x1b
    _paramCnt = 0;
    32b0:	10 a2       	std	Z+32, r1	; 0x20
}
    32b2:	08 95       	ret

000032b4 <_ZN12CmdProcessor6getCmdEv>:

//! Return the command string.
const char* CmdProcessor::getCmd()
    32b4:	fc 01       	movw	r30, r24
{
    return _pCmd;
}
    32b6:	86 89       	ldd	r24, Z+22	; 0x16
    32b8:	97 89       	ldd	r25, Z+23	; 0x17
    32ba:	08 95       	ret

000032bc <_ZN12CmdProcessor8paramCntEv>:

//! Return the number of parameters parsed from the current command.
uint8_t CmdProcessor::paramCnt()
{
    return _paramCnt;
}
    32bc:	fc 01       	movw	r30, r24
    32be:	80 a1       	ldd	r24, Z+32	; 0x20
    32c0:	08 95       	ret

000032c2 <_ZN12CmdProcessor8getParamEhRPch>:
        //p = atof(_pTokens[idx]);
    }
}

//! Parse the index parameter into a string with the length specified.
void CmdProcessor::getParam(uint8_t idx,char*& p, uint8_t maxlen)
    32c2:	cf 93       	push	r28
    32c4:	df 93       	push	r29
    32c6:	dc 01       	movw	r26, r24
    32c8:	ea 01       	movw	r28, r20
{
    if (idx < _paramCnt) {
    32ca:	90 96       	adiw	r26, 0x20	; 32
    32cc:	8c 91       	ld	r24, X
    32ce:	90 97       	sbiw	r26, 0x20	; 32
    32d0:	68 17       	cp	r22, r24
    32d2:	78 f4       	brcc	.+30     	; 0x32f2 <_ZN12CmdProcessor8getParamEhRPch+0x30>
        strncpy(p,_pTokens[idx],maxlen);
    32d4:	e6 2f       	mov	r30, r22
    32d6:	f0 e0       	ldi	r31, 0x00	; 0
    32d8:	31 96       	adiw	r30, 0x01	; 1
    32da:	ee 0f       	add	r30, r30
    32dc:	ff 1f       	adc	r31, r31
    32de:	ea 0f       	add	r30, r26
    32e0:	fb 1f       	adc	r31, r27
    32e2:	60 81       	ld	r22, Z
    32e4:	71 81       	ldd	r23, Z+1	; 0x01
    32e6:	88 81       	ld	r24, Y
    32e8:	99 81       	ldd	r25, Y+1	; 0x01
    32ea:	42 2f       	mov	r20, r18
    32ec:	50 e0       	ldi	r21, 0x00	; 0
    32ee:	0e 94 62 4b 	call	0x96c4	; 0x96c4 <strncpy>
    }
}
    32f2:	df 91       	pop	r29
    32f4:	cf 91       	pop	r28
    32f6:	08 95       	ret

000032f8 <_ZN12CmdProcessor8getParamEhRd>:
        l = atol(_pTokens[idx]);
    }
}

//! Parse the index parameter into a double.
void CmdProcessor::getParam(uint8_t idx,double &p)
    32f8:	cf 93       	push	r28
    32fa:	df 93       	push	r29
    32fc:	ec 01       	movw	r28, r24
{
    if (idx < _paramCnt) {
    32fe:	88 a1       	ldd	r24, Y+32	; 0x20
    3300:	68 17       	cp	r22, r24
    3302:	18 f5       	brcc	.+70     	; 0x334a <_ZN12CmdProcessor8getParamEhRd+0x52>
        uint8_t nScans;
        nScans = sscanf(_pTokens[idx],"%lf", &p);
    3304:	00 d0       	rcall	.+0      	; 0x3306 <_ZN12CmdProcessor8getParamEhRd+0xe>
    3306:	00 d0       	rcall	.+0      	; 0x3308 <_ZN12CmdProcessor8getParamEhRd+0x10>
    3308:	ad b7       	in	r26, 0x3d	; 61
    330a:	be b7       	in	r27, 0x3e	; 62
    330c:	11 96       	adiw	r26, 0x01	; 1
    330e:	e6 2f       	mov	r30, r22
    3310:	f0 e0       	ldi	r31, 0x00	; 0
    3312:	31 96       	adiw	r30, 0x01	; 1
    3314:	ee 0f       	add	r30, r30
    3316:	ff 1f       	adc	r31, r31
    3318:	ec 0f       	add	r30, r28
    331a:	fd 1f       	adc	r31, r29
    331c:	80 81       	ld	r24, Z
    331e:	91 81       	ldd	r25, Z+1	; 0x01
    3320:	ed b7       	in	r30, 0x3d	; 61
    3322:	fe b7       	in	r31, 0x3e	; 62
    3324:	81 83       	std	Z+1, r24	; 0x01
    3326:	92 83       	std	Z+2, r25	; 0x02
    3328:	8f e3       	ldi	r24, 0x3F	; 63
    332a:	93 e2       	ldi	r25, 0x23	; 35
    332c:	12 96       	adiw	r26, 0x02	; 2
    332e:	8d 93       	st	X+, r24
    3330:	9c 93       	st	X, r25
    3332:	13 97       	sbiw	r26, 0x03	; 3
    3334:	14 96       	adiw	r26, 0x04	; 4
    3336:	4d 93       	st	X+, r20
    3338:	5c 93       	st	X, r21
    333a:	15 97       	sbiw	r26, 0x05	; 5
    333c:	0e 94 ee 4b 	call	0x97dc	; 0x97dc <sscanf>
    3340:	8d b7       	in	r24, 0x3d	; 61
    3342:	9e b7       	in	r25, 0x3e	; 62
    3344:	06 96       	adiw	r24, 0x06	; 6
    3346:	8d bf       	out	0x3d, r24	; 61
    3348:	9e bf       	out	0x3e, r25	; 62
        //p = atof(_pTokens[idx]);
    }
}
    334a:	df 91       	pop	r29
    334c:	cf 91       	pop	r28
    334e:	08 95       	ret

00003350 <_ZN12CmdProcessor8getParamEhRl>:
    if (idx < _paramCnt) {
        p = atoi(_pTokens[idx]);
    }
}

void CmdProcessor::getParam(uint8_t idx,long &l)
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    3354:	dc 01       	movw	r26, r24
    3356:	ea 01       	movw	r28, r20
{
    if (idx < _paramCnt) {
    3358:	90 96       	adiw	r26, 0x20	; 32
    335a:	8c 91       	ld	r24, X
    335c:	90 97       	sbiw	r26, 0x20	; 32
    335e:	68 17       	cp	r22, r24
    3360:	78 f4       	brcc	.+30     	; 0x3380 <_ZN12CmdProcessor8getParamEhRl+0x30>
        l = atol(_pTokens[idx]);
    3362:	e6 2f       	mov	r30, r22
    3364:	f0 e0       	ldi	r31, 0x00	; 0
    3366:	31 96       	adiw	r30, 0x01	; 1
    3368:	ee 0f       	add	r30, r30
    336a:	ff 1f       	adc	r31, r31
    336c:	ea 0f       	add	r30, r26
    336e:	fb 1f       	adc	r31, r27
    3370:	80 81       	ld	r24, Z
    3372:	91 81       	ldd	r25, Z+1	; 0x01
    3374:	0e 94 0b 4b 	call	0x9616	; 0x9616 <atol>
    3378:	68 83       	st	Y, r22
    337a:	79 83       	std	Y+1, r23	; 0x01
    337c:	8a 83       	std	Y+2, r24	; 0x02
    337e:	9b 83       	std	Y+3, r25	; 0x03
    }
}
    3380:	df 91       	pop	r29
    3382:	cf 91       	pop	r28
    3384:	08 95       	ret

00003386 <_ZN12CmdProcessor8getParamEhRi>:
    if (idx < _paramCnt) {
        p = atoi(_pTokens[idx]);
    }
}

void CmdProcessor::getParam(uint8_t idx,int &p)
    3386:	cf 93       	push	r28
    3388:	df 93       	push	r29
    338a:	dc 01       	movw	r26, r24
    338c:	ea 01       	movw	r28, r20
{
    if (idx < _paramCnt) {
    338e:	90 96       	adiw	r26, 0x20	; 32
    3390:	8c 91       	ld	r24, X
    3392:	90 97       	sbiw	r26, 0x20	; 32
    3394:	68 17       	cp	r22, r24
    3396:	68 f4       	brcc	.+26     	; 0x33b2 <_ZN12CmdProcessor8getParamEhRi+0x2c>
        p = atoi(_pTokens[idx]);
    3398:	e6 2f       	mov	r30, r22
    339a:	f0 e0       	ldi	r31, 0x00	; 0
    339c:	31 96       	adiw	r30, 0x01	; 1
    339e:	ee 0f       	add	r30, r30
    33a0:	ff 1f       	adc	r31, r31
    33a2:	ea 0f       	add	r30, r26
    33a4:	fb 1f       	adc	r31, r27
    33a6:	80 81       	ld	r24, Z
    33a8:	91 81       	ldd	r25, Z+1	; 0x01
    33aa:	0e 94 ed 4a 	call	0x95da	; 0x95da <atoi>
    33ae:	88 83       	st	Y, r24
    33b0:	99 83       	std	Y+1, r25	; 0x01
    }
}
    33b2:	df 91       	pop	r29
    33b4:	cf 91       	pop	r28
    33b6:	08 95       	ret

000033b8 <_ZN12CmdProcessor8getParamEhRh>:
        p = atoi(_pTokens[idx]);
    }
}

//! Parse the index parameter into a unsigned 8 bit integer.
void CmdProcessor::getParam(uint8_t idx,uint8_t &p)
    33b8:	cf 93       	push	r28
    33ba:	df 93       	push	r29
    33bc:	dc 01       	movw	r26, r24
    33be:	ea 01       	movw	r28, r20
{
    if (idx < _paramCnt) {
    33c0:	90 96       	adiw	r26, 0x20	; 32
    33c2:	8c 91       	ld	r24, X
    33c4:	90 97       	sbiw	r26, 0x20	; 32
    33c6:	68 17       	cp	r22, r24
    33c8:	60 f4       	brcc	.+24     	; 0x33e2 <_ZN12CmdProcessor8getParamEhRh+0x2a>
        p = atoi(_pTokens[idx]);
    33ca:	e6 2f       	mov	r30, r22
    33cc:	f0 e0       	ldi	r31, 0x00	; 0
    33ce:	31 96       	adiw	r30, 0x01	; 1
    33d0:	ee 0f       	add	r30, r30
    33d2:	ff 1f       	adc	r31, r31
    33d4:	ea 0f       	add	r30, r26
    33d6:	fb 1f       	adc	r31, r27
    33d8:	80 81       	ld	r24, Z
    33da:	91 81       	ldd	r25, Z+1	; 0x01
    33dc:	0e 94 ed 4a 	call	0x95da	; 0x95da <atoi>
    33e0:	88 83       	st	Y, r24
    }
}
    33e2:	df 91       	pop	r29
    33e4:	cf 91       	pop	r28
    33e6:	08 95       	ret

000033e8 <_ZN12CmdProcessor8getParamEhRj>:
 
*/
//@{

//! Parse the index parameter into a unsigned 16 bit integer.
void CmdProcessor::getParam(uint8_t idx,uint16_t &p)
    33e8:	cf 93       	push	r28
    33ea:	df 93       	push	r29
    33ec:	dc 01       	movw	r26, r24
    33ee:	ea 01       	movw	r28, r20
{
    if (idx < _paramCnt) {
    33f0:	90 96       	adiw	r26, 0x20	; 32
    33f2:	8c 91       	ld	r24, X
    33f4:	90 97       	sbiw	r26, 0x20	; 32
    33f6:	68 17       	cp	r22, r24
    33f8:	68 f4       	brcc	.+26     	; 0x3414 <_ZN12CmdProcessor8getParamEhRj+0x2c>
        p = atoi(_pTokens[idx]);
    33fa:	e6 2f       	mov	r30, r22
    33fc:	f0 e0       	ldi	r31, 0x00	; 0
    33fe:	31 96       	adiw	r30, 0x01	; 1
    3400:	ee 0f       	add	r30, r30
    3402:	ff 1f       	adc	r31, r31
    3404:	ea 0f       	add	r30, r26
    3406:	fb 1f       	adc	r31, r27
    3408:	80 81       	ld	r24, Z
    340a:	91 81       	ldd	r25, Z+1	; 0x01
    340c:	0e 94 ed 4a 	call	0x95da	; 0x95da <atoi>
    3410:	88 83       	st	Y, r24
    3412:	99 83       	std	Y+1, r25	; 0x01
    }
}
    3414:	df 91       	pop	r29
    3416:	cf 91       	pop	r28
    3418:	08 95       	ret

0000341a <_ZN12CmdProcessor10processCmdEv>:

//! Process the commands in the command buffer
//! Split the command into parameters based on the
//! command delimiter. The maximum number of command
//! tokens is 10.
void CmdProcessor::processCmd()
    341a:	ef 92       	push	r14
    341c:	ff 92       	push	r15
    341e:	0f 93       	push	r16
    3420:	1f 93       	push	r17
    3422:	cf 93       	push	r28
    3424:	df 93       	push	r29
    3426:	ec 01       	movw	r28, r24
{
    // See if the command delimiter exists in the
    // command. if it does not, then the command
    // is the entire string.
    if (strpbrk(_pCmdString,_pCmdDelim)) {
    3428:	08 8d       	ldd	r16, Y+24	; 0x18
    342a:	19 8d       	ldd	r17, Y+25	; 0x19
    342c:	ee 8c       	ldd	r14, Y+30	; 0x1e
    342e:	ff 8c       	ldd	r15, Y+31	; 0x1f
    3430:	c8 01       	movw	r24, r16
    3432:	b7 01       	movw	r22, r14
    3434:	0e 94 71 4b 	call	0x96e2	; 0x96e2 <strpbrk>
    3438:	00 97       	sbiw	r24, 0x00	; 0
    343a:	31 f1       	breq	.+76     	; 0x3488 <_ZN12CmdProcessor10processCmdEv+0x6e>
        _pCmd = strtok(_pCmdString,_pCmdDelim);
    343c:	c8 01       	movw	r24, r16
    343e:	b7 01       	movw	r22, r14
    3440:	0e 94 32 4b 	call	0x9664	; 0x9664 <strtok>
    3444:	8e 8b       	std	Y+22, r24	; 0x16
    3446:	9f 8b       	std	Y+23, r25	; 0x17
        char* pTok = strtok(0,_pCmdDelim);
    3448:	6e 8d       	ldd	r22, Y+30	; 0x1e
    344a:	7f 8d       	ldd	r23, Y+31	; 0x1f
    344c:	80 e0       	ldi	r24, 0x00	; 0
    344e:	90 e0       	ldi	r25, 0x00	; 0
    3450:	0e 94 32 4b 	call	0x9664	; 0x9664 <strtok>
    3454:	7e 01       	movw	r14, r28
    3456:	00 e0       	ldi	r16, 0x00	; 0
    3458:	10 e0       	ldi	r17, 0x00	; 0
    345a:	12 c0       	rjmp	.+36     	; 0x3480 <_ZN12CmdProcessor10processCmdEv+0x66>
        int i = 0;
        while (i < 10 && pTok) {
            _pTokens[i++] = pTok;
    345c:	f7 01       	movw	r30, r14
    345e:	82 83       	std	Z+2, r24	; 0x02
    3460:	93 83       	std	Z+3, r25	; 0x03
    3462:	0f 5f       	subi	r16, 0xFF	; 255
    3464:	1f 4f       	sbci	r17, 0xFF	; 255
            pTok = strtok(0,_pCmdDelim);
    3466:	6e 8d       	ldd	r22, Y+30	; 0x1e
    3468:	7f 8d       	ldd	r23, Y+31	; 0x1f
    346a:	80 e0       	ldi	r24, 0x00	; 0
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	0e 94 32 4b 	call	0x9664	; 0x9664 <strtok>
    3472:	22 e0       	ldi	r18, 0x02	; 2
    3474:	30 e0       	ldi	r19, 0x00	; 0
    3476:	e2 0e       	add	r14, r18
    3478:	f3 1e       	adc	r15, r19
    // is the entire string.
    if (strpbrk(_pCmdString,_pCmdDelim)) {
        _pCmd = strtok(_pCmdString,_pCmdDelim);
        char* pTok = strtok(0,_pCmdDelim);
        int i = 0;
        while (i < 10 && pTok) {
    347a:	0a 30       	cpi	r16, 0x0A	; 10
    347c:	11 05       	cpc	r17, r1
    347e:	11 f0       	breq	.+4      	; 0x3484 <_ZN12CmdProcessor10processCmdEv+0x6a>
    3480:	00 97       	sbiw	r24, 0x00	; 0
    3482:	61 f7       	brne	.-40     	; 0x345c <_ZN12CmdProcessor10processCmdEv+0x42>
            _pTokens[i++] = pTok;
            pTok = strtok(0,_pCmdDelim);
        }
        _paramCnt = i;
    3484:	08 a3       	std	Y+32, r16	; 0x20
    3486:	03 c0       	rjmp	.+6      	; 0x348e <_ZN12CmdProcessor10processCmdEv+0x74>
        _validCmd = true;
    } else {
        _pCmd = _pCmdString;
    3488:	0e 8b       	std	Y+22, r16	; 0x16
    348a:	1f 8b       	std	Y+23, r17	; 0x17
        _paramCnt = 0;
    348c:	18 a2       	std	Y+32, r1	; 0x20
        _validCmd = true;
    348e:	81 e0       	ldi	r24, 0x01	; 1
    3490:	8b 8f       	std	Y+27, r24	; 0x1b
    }
}
    3492:	df 91       	pop	r29
    3494:	cf 91       	pop	r28
    3496:	1f 91       	pop	r17
    3498:	0f 91       	pop	r16
    349a:	ff 90       	pop	r15
    349c:	ef 90       	pop	r14
    349e:	08 95       	ret

000034a0 <_ZN12CmdProcessor13checkCommandsEv>:
//! Read any new characters into the command buffer.
//! Look for the command terminator. If the terminator
//! is found, store the command, process the command buffer
//! and return 1 to indicate that a new command is availble.
//! If a full command is not yet present, then return zero.
bool CmdProcessor::checkCommands()
    34a0:	1f 93       	push	r17
    34a2:	cf 93       	push	r28
    34a4:	df 93       	push	r29
    34a6:	ec 01       	movw	r28, r24
    34a8:	22 c0       	rjmp	.+68     	; 0x34ee <_ZN12CmdProcessor13checkCommandsEv+0x4e>
{
    while (_pHW->available() > 0) {
        unsigned char c = _pHW->read();
    34aa:	88 81       	ld	r24, Y
    34ac:	99 81       	ldd	r25, Y+1	; 0x01
    34ae:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <_ZN14HardwareSerial4readEv>
    34b2:	18 2f       	mov	r17, r24
        if (strchr(_pCmdTerm,c) != 0) {
    34b4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    34b6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    34b8:	61 2f       	mov	r22, r17
    34ba:	70 e0       	ldi	r23, 0x00	; 0
    34bc:	0e 94 47 4b 	call	0x968e	; 0x968e <strchr>
    34c0:	9c 01       	movw	r18, r24
    34c2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    34c4:	23 2b       	or	r18, r19
    34c6:	61 f0       	breq	.+24     	; 0x34e0 <_ZN12CmdProcessor13checkCommandsEv+0x40>
            if (_cmdPos > 0) {
    34c8:	88 23       	and	r24, r24
    34ca:	89 f0       	breq	.+34     	; 0x34ee <_ZN12CmdProcessor13checkCommandsEv+0x4e>
                // Done with this command.
                _pCmdString[_cmdPos] = 0; // Null terminate command
    34cc:	e8 8d       	ldd	r30, Y+24	; 0x18
    34ce:	f9 8d       	ldd	r31, Y+25	; 0x19
    34d0:	e8 0f       	add	r30, r24
    34d2:	f1 1d       	adc	r31, r1
    34d4:	10 82       	st	Z, r1
                processCmd();
    34d6:	ce 01       	movw	r24, r28
    34d8:	0e 94 0d 1a 	call	0x341a	; 0x341a <_ZN12CmdProcessor10processCmdEv>
    34dc:	81 e0       	ldi	r24, 0x01	; 1
    34de:	0d c0       	rjmp	.+26     	; 0x34fa <_ZN12CmdProcessor13checkCommandsEv+0x5a>
                return 1;
            }
        } else {
            _pCmdString[_cmdPos++] = c;
    34e0:	e8 8d       	ldd	r30, Y+24	; 0x18
    34e2:	f9 8d       	ldd	r31, Y+25	; 0x19
    34e4:	e8 0f       	add	r30, r24
    34e6:	f1 1d       	adc	r31, r1
    34e8:	10 83       	st	Z, r17
    34ea:	8f 5f       	subi	r24, 0xFF	; 255
    34ec:	8a 8f       	std	Y+26, r24	; 0x1a
//! is found, store the command, process the command buffer
//! and return 1 to indicate that a new command is availble.
//! If a full command is not yet present, then return zero.
bool CmdProcessor::checkCommands()
{
    while (_pHW->available() > 0) {
    34ee:	88 81       	ld	r24, Y
    34f0:	99 81       	ldd	r25, Y+1	; 0x01
    34f2:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <_ZN14HardwareSerial9availableEv>
    34f6:	88 23       	and	r24, r24
    34f8:	c1 f6       	brne	.-80     	; 0x34aa <_ZN12CmdProcessor13checkCommandsEv+0xa>
        } else {
            _pCmdString[_cmdPos++] = c;
        }
    }
    return 0;
}
    34fa:	df 91       	pop	r29
    34fc:	cf 91       	pop	r28
    34fe:	1f 91       	pop	r17
    3500:	08 95       	ret

00003502 <_ZN12CmdProcessor8cmdDelimEPKc>:
    return _pCmdDelim;
}

//! Set new delimiter string. 
//! Free memory, allocate new memory and copy new value.
void CmdProcessor::cmdDelim(const char* d)
    3502:	ef 92       	push	r14
    3504:	ff 92       	push	r15
    3506:	0f 93       	push	r16
    3508:	1f 93       	push	r17
    350a:	8c 01       	movw	r16, r24
    350c:	f6 2e       	mov	r15, r22
    350e:	e7 2e       	mov	r14, r23
{
    free(_pCmdDelim);
    3510:	fc 01       	movw	r30, r24
    3512:	86 8d       	ldd	r24, Z+30	; 0x1e
    3514:	97 8d       	ldd	r25, Z+31	; 0x1f
    3516:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    _pCmdDelim = (char*)malloc(strlen(d) + 1);
    351a:	ef 2d       	mov	r30, r15
    351c:	fe 2d       	mov	r31, r14
    351e:	df 01       	movw	r26, r30
    3520:	0d 90       	ld	r0, X+
    3522:	00 20       	and	r0, r0
    3524:	e9 f7       	brne	.-6      	; 0x3520 <_ZN12CmdProcessor8cmdDelimEPKc+0x1e>
    3526:	cd 01       	movw	r24, r26
    3528:	8e 1b       	sub	r24, r30
    352a:	9f 0b       	sbc	r25, r31
    352c:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    3530:	f8 01       	movw	r30, r16
    3532:	86 8f       	std	Z+30, r24	; 0x1e
    3534:	97 8f       	std	Z+31, r25	; 0x1f
    strcpy(_pCmdDelim,d);
    3536:	6f 2d       	mov	r22, r15
    3538:	7e 2d       	mov	r23, r14
    353a:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
}
    353e:	1f 91       	pop	r17
    3540:	0f 91       	pop	r16
    3542:	ff 90       	pop	r15
    3544:	ef 90       	pop	r14
    3546:	08 95       	ret

00003548 <_ZN12CmdProcessor7cmdTermEPc>:
//! Return pointer to termination string.
char* CmdProcessor::cmdTerm() { return _pCmdTerm; }

//! Set a new command terminator. Free memory for previous
//! value, allocate new memory and save the new value.
void CmdProcessor::cmdTerm(char* t) 
    3548:	ef 92       	push	r14
    354a:	ff 92       	push	r15
    354c:	0f 93       	push	r16
    354e:	1f 93       	push	r17
    3550:	8c 01       	movw	r16, r24
    3552:	f6 2e       	mov	r15, r22
    3554:	e7 2e       	mov	r14, r23
{ 
    free(_pCmdTerm);
    3556:	fc 01       	movw	r30, r24
    3558:	84 8d       	ldd	r24, Z+28	; 0x1c
    355a:	95 8d       	ldd	r25, Z+29	; 0x1d
    355c:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    _pCmdTerm = (char*)malloc(strlen(t) + 1);
    3560:	ef 2d       	mov	r30, r15
    3562:	fe 2d       	mov	r31, r14
    3564:	df 01       	movw	r26, r30
    3566:	0d 90       	ld	r0, X+
    3568:	00 20       	and	r0, r0
    356a:	e9 f7       	brne	.-6      	; 0x3566 <_ZN12CmdProcessor7cmdTermEPc+0x1e>
    356c:	cd 01       	movw	r24, r26
    356e:	8e 1b       	sub	r24, r30
    3570:	9f 0b       	sbc	r25, r31
    3572:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    3576:	f8 01       	movw	r30, r16
    3578:	84 8f       	std	Z+28, r24	; 0x1c
    357a:	95 8f       	std	Z+29, r25	; 0x1d
    strcpy(_pCmdTerm,t);
    357c:	6f 2d       	mov	r22, r15
    357e:	7e 2d       	mov	r23, r14
    3580:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
}
    3584:	1f 91       	pop	r17
    3586:	0f 91       	pop	r16
    3588:	ff 90       	pop	r15
    358a:	ef 90       	pop	r14
    358c:	08 95       	ret

0000358e <_ZN12CmdProcessorC1EP14HardwareSerial>:
//! Construct a new CmdProcessor.
//! Pass in reference to the HardwareSerial class to use
//! for command processing. Store the serial pointer and
//! then initialize the internal data strings used during
//! command input processing and output processing.
CmdProcessor::CmdProcessor(HardwareSerial* pHW)
    358e:	0f 93       	push	r16
    3590:	1f 93       	push	r17
    3592:	8c 01       	movw	r16, r24
{
    _pHW = pHW;
    3594:	fc 01       	movw	r30, r24
    3596:	60 83       	st	Z, r22
    3598:	71 83       	std	Z+1, r23	; 0x01
    
    _pCmdString = (char*)malloc(128);
    359a:	80 e8       	ldi	r24, 0x80	; 128
    359c:	90 e0       	ldi	r25, 0x00	; 0
    359e:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    35a2:	f8 01       	movw	r30, r16
    35a4:	80 8f       	std	Z+24, r24	; 0x18
    35a6:	91 8f       	std	Z+25, r25	; 0x19
    _pCmd = 0;
    35a8:	16 8a       	std	Z+22, r1	; 0x16
    35aa:	17 8a       	std	Z+23, r1	; 0x17
    _pCmdTerm = (char*)malloc(3);
    35ac:	83 e0       	ldi	r24, 0x03	; 3
    35ae:	90 e0       	ldi	r25, 0x00	; 0
    35b0:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    35b4:	f8 01       	movw	r30, r16
    35b6:	84 8f       	std	Z+28, r24	; 0x1c
    35b8:	95 8f       	std	Z+29, r25	; 0x1d
    strcpy(_pCmdTerm,"\n\r");
    35ba:	63 e4       	ldi	r22, 0x43	; 67
    35bc:	73 e2       	ldi	r23, 0x23	; 35
    35be:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
    _pCmdDelim = (char*)malloc(3);
    35c2:	83 e0       	ldi	r24, 0x03	; 3
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    35c6:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    35ca:	f8 01       	movw	r30, r16
    35cc:	86 8f       	std	Z+30, r24	; 0x1e
    35ce:	97 8f       	std	Z+31, r25	; 0x1f
    strcpy(_pCmdDelim," \t");
    35d0:	66 e4       	ldi	r22, 0x46	; 70
    35d2:	73 e2       	ldi	r23, 0x23	; 35
    35d4:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
}

//! Clear the command status values so a new command can be started.
void CmdProcessor::resetCmd()
{
    _cmdPos = 0;
    35d8:	f8 01       	movw	r30, r16
    35da:	12 8e       	std	Z+26, r1	; 0x1a
    _validCmd = false;
    35dc:	13 8e       	std	Z+27, r1	; 0x1b
    _paramCnt = 0;
    35de:	10 a2       	std	Z+32, r1	; 0x20
    _pCmdTerm = (char*)malloc(3);
    strcpy(_pCmdTerm,"\n\r");
    _pCmdDelim = (char*)malloc(3);
    strcpy(_pCmdDelim," \t");
    resetCmd();
}
    35e0:	1f 91       	pop	r17
    35e2:	0f 91       	pop	r16
    35e4:	08 95       	ret

000035e6 <_ZN12CmdProcessorC2EP14HardwareSerial>:
//! Construct a new CmdProcessor.
//! Pass in reference to the HardwareSerial class to use
//! for command processing. Store the serial pointer and
//! then initialize the internal data strings used during
//! command input processing and output processing.
CmdProcessor::CmdProcessor(HardwareSerial* pHW)
    35e6:	0f 93       	push	r16
    35e8:	1f 93       	push	r17
    35ea:	8c 01       	movw	r16, r24
{
    _pHW = pHW;
    35ec:	fc 01       	movw	r30, r24
    35ee:	60 83       	st	Z, r22
    35f0:	71 83       	std	Z+1, r23	; 0x01
    
    _pCmdString = (char*)malloc(128);
    35f2:	80 e8       	ldi	r24, 0x80	; 128
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    35fa:	f8 01       	movw	r30, r16
    35fc:	80 8f       	std	Z+24, r24	; 0x18
    35fe:	91 8f       	std	Z+25, r25	; 0x19
    _pCmd = 0;
    3600:	16 8a       	std	Z+22, r1	; 0x16
    3602:	17 8a       	std	Z+23, r1	; 0x17
    _pCmdTerm = (char*)malloc(3);
    3604:	83 e0       	ldi	r24, 0x03	; 3
    3606:	90 e0       	ldi	r25, 0x00	; 0
    3608:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    360c:	f8 01       	movw	r30, r16
    360e:	84 8f       	std	Z+28, r24	; 0x1c
    3610:	95 8f       	std	Z+29, r25	; 0x1d
    strcpy(_pCmdTerm,"\n\r");
    3612:	63 e4       	ldi	r22, 0x43	; 67
    3614:	73 e2       	ldi	r23, 0x23	; 35
    3616:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
    _pCmdDelim = (char*)malloc(3);
    361a:	83 e0       	ldi	r24, 0x03	; 3
    361c:	90 e0       	ldi	r25, 0x00	; 0
    361e:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    3622:	f8 01       	movw	r30, r16
    3624:	86 8f       	std	Z+30, r24	; 0x1e
    3626:	97 8f       	std	Z+31, r25	; 0x1f
    strcpy(_pCmdDelim," \t");
    3628:	66 e4       	ldi	r22, 0x46	; 70
    362a:	73 e2       	ldi	r23, 0x23	; 35
    362c:	0e 94 5b 4b 	call	0x96b6	; 0x96b6 <strcpy>
}

//! Clear the command status values so a new command can be started.
void CmdProcessor::resetCmd()
{
    _cmdPos = 0;
    3630:	f8 01       	movw	r30, r16
    3632:	12 8e       	std	Z+26, r1	; 0x1a
    _validCmd = false;
    3634:	13 8e       	std	Z+27, r1	; 0x1b
    _paramCnt = 0;
    3636:	10 a2       	std	Z+32, r1	; 0x20
    _pCmdTerm = (char*)malloc(3);
    strcpy(_pCmdTerm,"\n\r");
    _pCmdDelim = (char*)malloc(3);
    strcpy(_pCmdDelim," \t");
    resetCmd();
}
    3638:	1f 91       	pop	r17
    363a:	0f 91       	pop	r16
    363c:	08 95       	ret

0000363e <_ZN12CmdProcessorD1Ev>:

//! Destructor. Release memory allocated in constructor.
CmdProcessor::~CmdProcessor()
    363e:	cf 93       	push	r28
    3640:	df 93       	push	r29
    3642:	ec 01       	movw	r28, r24
{
    if (_pHW) {
    3644:	88 81       	ld	r24, Y
    3646:	99 81       	ldd	r25, Y+1	; 0x01
    3648:	00 97       	sbiw	r24, 0x00	; 0
    364a:	11 f0       	breq	.+4      	; 0x3650 <_ZN12CmdProcessorD1Ev+0x12>
        _pHW->end();
    364c:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN14HardwareSerial3endEv>
    }
    free(_pCmdString);
    3650:	88 8d       	ldd	r24, Y+24	; 0x18
    3652:	99 8d       	ldd	r25, Y+25	; 0x19
    3654:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    free(_pCmdDelim);
    3658:	8e 8d       	ldd	r24, Y+30	; 0x1e
    365a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    365c:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    free(_pCmdTerm);
    3660:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3662:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3664:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
}
    3668:	df 91       	pop	r29
    366a:	cf 91       	pop	r28
    366c:	08 95       	ret

0000366e <_ZN12CmdProcessorD2Ev>:
    strcpy(_pCmdDelim," \t");
    resetCmd();
}

//! Destructor. Release memory allocated in constructor.
CmdProcessor::~CmdProcessor()
    366e:	cf 93       	push	r28
    3670:	df 93       	push	r29
    3672:	ec 01       	movw	r28, r24
{
    if (_pHW) {
    3674:	88 81       	ld	r24, Y
    3676:	99 81       	ldd	r25, Y+1	; 0x01
    3678:	00 97       	sbiw	r24, 0x00	; 0
    367a:	11 f0       	breq	.+4      	; 0x3680 <_ZN12CmdProcessorD2Ev+0x12>
        _pHW->end();
    367c:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN14HardwareSerial3endEv>
    }
    free(_pCmdString);
    3680:	88 8d       	ldd	r24, Y+24	; 0x18
    3682:	99 8d       	ldd	r25, Y+25	; 0x19
    3684:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    free(_pCmdDelim);
    3688:	8e 8d       	ldd	r24, Y+30	; 0x1e
    368a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    368c:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    free(_pCmdTerm);
    3690:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3692:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3694:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
}
    3698:	df 91       	pop	r29
    369a:	cf 91       	pop	r28
    369c:	08 95       	ret

0000369e <__vector_26>:
}\
ISR(usart##_TXC_vect) {\
    if (usart##cp) usart##cp->txc();\
}

SERIAL_ISR_DEF(USARTC0);
    369e:	1f 92       	push	r1
    36a0:	0f 92       	push	r0
    36a2:	0f b6       	in	r0, 0x3f	; 63
    36a4:	0f 92       	push	r0
    36a6:	08 b6       	in	r0, 0x38	; 56
    36a8:	0f 92       	push	r0
    36aa:	11 24       	eor	r1, r1
    36ac:	18 be       	out	0x38, r1	; 56
    36ae:	0f 90       	pop	r0
    36b0:	08 be       	out	0x38, r0	; 56
    36b2:	0f 90       	pop	r0
    36b4:	0f be       	out	0x3f, r0	; 63
    36b6:	0f 90       	pop	r0
    36b8:	1f 90       	pop	r1
    36ba:	18 95       	reti

000036bc <__vector_27>:
    36bc:	1f 92       	push	r1
    36be:	0f 92       	push	r0
    36c0:	0f b6       	in	r0, 0x3f	; 63
    36c2:	0f 92       	push	r0
    36c4:	08 b6       	in	r0, 0x38	; 56
    36c6:	0f 92       	push	r0
    36c8:	11 24       	eor	r1, r1
    36ca:	18 be       	out	0x38, r1	; 56
    36cc:	0f 90       	pop	r0
    36ce:	08 be       	out	0x38, r0	; 56
    36d0:	0f 90       	pop	r0
    36d2:	0f be       	out	0x3f, r0	; 63
    36d4:	0f 90       	pop	r0
    36d6:	1f 90       	pop	r1
    36d8:	18 95       	reti

000036da <__vector_29>:
SERIAL_ISR_DEF(USARTC1);
    36da:	1f 92       	push	r1
    36dc:	0f 92       	push	r0
    36de:	0f b6       	in	r0, 0x3f	; 63
    36e0:	0f 92       	push	r0
    36e2:	08 b6       	in	r0, 0x38	; 56
    36e4:	0f 92       	push	r0
    36e6:	11 24       	eor	r1, r1
    36e8:	18 be       	out	0x38, r1	; 56
    36ea:	0f 90       	pop	r0
    36ec:	08 be       	out	0x38, r0	; 56
    36ee:	0f 90       	pop	r0
    36f0:	0f be       	out	0x3f, r0	; 63
    36f2:	0f 90       	pop	r0
    36f4:	1f 90       	pop	r1
    36f6:	18 95       	reti

000036f8 <__vector_30>:
    36f8:	1f 92       	push	r1
    36fa:	0f 92       	push	r0
    36fc:	0f b6       	in	r0, 0x3f	; 63
    36fe:	0f 92       	push	r0
    3700:	08 b6       	in	r0, 0x38	; 56
    3702:	0f 92       	push	r0
    3704:	11 24       	eor	r1, r1
    3706:	18 be       	out	0x38, r1	; 56
    3708:	0f 90       	pop	r0
    370a:	08 be       	out	0x38, r0	; 56
    370c:	0f 90       	pop	r0
    370e:	0f be       	out	0x3f, r0	; 63
    3710:	0f 90       	pop	r0
    3712:	1f 90       	pop	r1
    3714:	18 95       	reti

00003716 <__vector_89>:
SERIAL_ISR_DEF(USARTD0);
    3716:	1f 92       	push	r1
    3718:	0f 92       	push	r0
    371a:	0f b6       	in	r0, 0x3f	; 63
    371c:	0f 92       	push	r0
    371e:	08 b6       	in	r0, 0x38	; 56
    3720:	0f 92       	push	r0
    3722:	11 24       	eor	r1, r1
    3724:	18 be       	out	0x38, r1	; 56
    3726:	0f 90       	pop	r0
    3728:	08 be       	out	0x38, r0	; 56
    372a:	0f 90       	pop	r0
    372c:	0f be       	out	0x3f, r0	; 63
    372e:	0f 90       	pop	r0
    3730:	1f 90       	pop	r1
    3732:	18 95       	reti

00003734 <__vector_90>:
    3734:	1f 92       	push	r1
    3736:	0f 92       	push	r0
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	0f 92       	push	r0
    373c:	08 b6       	in	r0, 0x38	; 56
    373e:	0f 92       	push	r0
    3740:	11 24       	eor	r1, r1
    3742:	18 be       	out	0x38, r1	; 56
    3744:	0f 90       	pop	r0
    3746:	08 be       	out	0x38, r0	; 56
    3748:	0f 90       	pop	r0
    374a:	0f be       	out	0x3f, r0	; 63
    374c:	0f 90       	pop	r0
    374e:	1f 90       	pop	r1
    3750:	18 95       	reti

00003752 <__vector_92>:
SERIAL_ISR_DEF(USARTD1);
    3752:	1f 92       	push	r1
    3754:	0f 92       	push	r0
    3756:	0f b6       	in	r0, 0x3f	; 63
    3758:	0f 92       	push	r0
    375a:	08 b6       	in	r0, 0x38	; 56
    375c:	0f 92       	push	r0
    375e:	11 24       	eor	r1, r1
    3760:	18 be       	out	0x38, r1	; 56
    3762:	0f 90       	pop	r0
    3764:	08 be       	out	0x38, r0	; 56
    3766:	0f 90       	pop	r0
    3768:	0f be       	out	0x3f, r0	; 63
    376a:	0f 90       	pop	r0
    376c:	1f 90       	pop	r1
    376e:	18 95       	reti

00003770 <__vector_93>:
    3770:	1f 92       	push	r1
    3772:	0f 92       	push	r0
    3774:	0f b6       	in	r0, 0x3f	; 63
    3776:	0f 92       	push	r0
    3778:	08 b6       	in	r0, 0x38	; 56
    377a:	0f 92       	push	r0
    377c:	11 24       	eor	r1, r1
    377e:	18 be       	out	0x38, r1	; 56
    3780:	0f 90       	pop	r0
    3782:	08 be       	out	0x38, r0	; 56
    3784:	0f 90       	pop	r0
    3786:	0f be       	out	0x3f, r0	; 63
    3788:	0f 90       	pop	r0
    378a:	1f 90       	pop	r1
    378c:	18 95       	reti

0000378e <__vector_59>:
SERIAL_ISR_DEF(USARTE0);
    378e:	1f 92       	push	r1
    3790:	0f 92       	push	r0
    3792:	0f b6       	in	r0, 0x3f	; 63
    3794:	0f 92       	push	r0
    3796:	08 b6       	in	r0, 0x38	; 56
    3798:	0f 92       	push	r0
    379a:	11 24       	eor	r1, r1
    379c:	18 be       	out	0x38, r1	; 56
    379e:	0f 90       	pop	r0
    37a0:	08 be       	out	0x38, r0	; 56
    37a2:	0f 90       	pop	r0
    37a4:	0f be       	out	0x3f, r0	; 63
    37a6:	0f 90       	pop	r0
    37a8:	1f 90       	pop	r1
    37aa:	18 95       	reti

000037ac <__vector_60>:
    37ac:	1f 92       	push	r1
    37ae:	0f 92       	push	r0
    37b0:	0f b6       	in	r0, 0x3f	; 63
    37b2:	0f 92       	push	r0
    37b4:	08 b6       	in	r0, 0x38	; 56
    37b6:	0f 92       	push	r0
    37b8:	11 24       	eor	r1, r1
    37ba:	18 be       	out	0x38, r1	; 56
    37bc:	0f 90       	pop	r0
    37be:	08 be       	out	0x38, r0	; 56
    37c0:	0f 90       	pop	r0
    37c2:	0f be       	out	0x3f, r0	; 63
    37c4:	0f 90       	pop	r0
    37c6:	1f 90       	pop	r1
    37c8:	18 95       	reti

000037ca <__vector_62>:
SERIAL_ISR_DEF(USARTE1);
    37ca:	1f 92       	push	r1
    37cc:	0f 92       	push	r0
    37ce:	0f b6       	in	r0, 0x3f	; 63
    37d0:	0f 92       	push	r0
    37d2:	08 b6       	in	r0, 0x38	; 56
    37d4:	0f 92       	push	r0
    37d6:	11 24       	eor	r1, r1
    37d8:	18 be       	out	0x38, r1	; 56
    37da:	0f 90       	pop	r0
    37dc:	08 be       	out	0x38, r0	; 56
    37de:	0f 90       	pop	r0
    37e0:	0f be       	out	0x3f, r0	; 63
    37e2:	0f 90       	pop	r0
    37e4:	1f 90       	pop	r1
    37e6:	18 95       	reti

000037e8 <__vector_63>:
    37e8:	1f 92       	push	r1
    37ea:	0f 92       	push	r0
    37ec:	0f b6       	in	r0, 0x3f	; 63
    37ee:	0f 92       	push	r0
    37f0:	08 b6       	in	r0, 0x38	; 56
    37f2:	0f 92       	push	r0
    37f4:	11 24       	eor	r1, r1
    37f6:	18 be       	out	0x38, r1	; 56
    37f8:	0f 90       	pop	r0
    37fa:	08 be       	out	0x38, r0	; 56
    37fc:	0f 90       	pop	r0
    37fe:	0f be       	out	0x3f, r0	; 63
    3800:	0f 90       	pop	r0
    3802:	1f 90       	pop	r1
    3804:	18 95       	reti

00003806 <__vector_120>:
SERIAL_ISR_DEF(USARTF0);
    3806:	1f 92       	push	r1
    3808:	0f 92       	push	r0
    380a:	0f b6       	in	r0, 0x3f	; 63
    380c:	0f 92       	push	r0
    380e:	08 b6       	in	r0, 0x38	; 56
    3810:	0f 92       	push	r0
    3812:	11 24       	eor	r1, r1
    3814:	18 be       	out	0x38, r1	; 56
    3816:	0f 90       	pop	r0
    3818:	08 be       	out	0x38, r0	; 56
    381a:	0f 90       	pop	r0
    381c:	0f be       	out	0x3f, r0	; 63
    381e:	0f 90       	pop	r0
    3820:	1f 90       	pop	r1
    3822:	18 95       	reti

00003824 <__vector_121>:
    3824:	1f 92       	push	r1
    3826:	0f 92       	push	r0
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	0f 92       	push	r0
    382c:	08 b6       	in	r0, 0x38	; 56
    382e:	0f 92       	push	r0
    3830:	11 24       	eor	r1, r1
    3832:	18 be       	out	0x38, r1	; 56
    3834:	0f 90       	pop	r0
    3836:	08 be       	out	0x38, r0	; 56
    3838:	0f 90       	pop	r0
    383a:	0f be       	out	0x3f, r0	; 63
    383c:	0f 90       	pop	r0
    383e:	1f 90       	pop	r1
    3840:	18 95       	reti

00003842 <__vector_123>:
#if defined(USARTF1_RXC_vect)
SERIAL_ISR_DEF(USARTF1);
    3842:	1f 92       	push	r1
    3844:	0f 92       	push	r0
    3846:	0f b6       	in	r0, 0x3f	; 63
    3848:	0f 92       	push	r0
    384a:	08 b6       	in	r0, 0x38	; 56
    384c:	0f 92       	push	r0
    384e:	11 24       	eor	r1, r1
    3850:	18 be       	out	0x38, r1	; 56
    3852:	0f 90       	pop	r0
    3854:	08 be       	out	0x38, r0	; 56
    3856:	0f 90       	pop	r0
    3858:	0f be       	out	0x3f, r0	; 63
    385a:	0f 90       	pop	r0
    385c:	1f 90       	pop	r1
    385e:	18 95       	reti

00003860 <__vector_124>:
    3860:	1f 92       	push	r1
    3862:	0f 92       	push	r0
    3864:	0f b6       	in	r0, 0x3f	; 63
    3866:	0f 92       	push	r0
    3868:	08 b6       	in	r0, 0x38	; 56
    386a:	0f 92       	push	r0
    386c:	11 24       	eor	r1, r1
    386e:	18 be       	out	0x38, r1	; 56
    3870:	0f 90       	pop	r0
    3872:	08 be       	out	0x38, r0	; 56
    3874:	0f 90       	pop	r0
    3876:	0f be       	out	0x3f, r0	; 63
    3878:	0f 90       	pop	r0
    387a:	1f 90       	pop	r1
    387c:	18 95       	reti

0000387e <_ZL10SetPointerP12USART_structP14HardwareSerial>:
static void SetPointer(USART_t* usart,HardwareSerial* p)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if(usart == &USARTC0) {
    387e:	28 e0       	ldi	r18, 0x08	; 8
    3880:	80 3a       	cpi	r24, 0xA0	; 160
    3882:	92 07       	cpc	r25, r18
    3884:	29 f4       	brne	.+10     	; 0x3890 <_ZL10SetPointerP12USART_structP14HardwareSerial+0x12>
        USARTC0cp = p;
    3886:	60 93 b3 2b 	sts	0x2BB3, r22
    388a:	70 93 b4 2b 	sts	0x2BB4, r23
    388e:	08 95       	ret
    } else if (usart == &USARTC1) {
    3890:	28 e0       	ldi	r18, 0x08	; 8
    3892:	80 3b       	cpi	r24, 0xB0	; 176
    3894:	92 07       	cpc	r25, r18
    3896:	29 f4       	brne	.+10     	; 0x38a2 <_ZL10SetPointerP12USART_structP14HardwareSerial+0x24>
        USARTC1cp = p;
    3898:	60 93 b5 2b 	sts	0x2BB5, r22
    389c:	70 93 b6 2b 	sts	0x2BB6, r23
    38a0:	08 95       	ret
    } else if (usart ==  &USARTD0) {
    38a2:	29 e0       	ldi	r18, 0x09	; 9
    38a4:	80 3a       	cpi	r24, 0xA0	; 160
    38a6:	92 07       	cpc	r25, r18
    38a8:	29 f4       	brne	.+10     	; 0x38b4 <_ZL10SetPointerP12USART_structP14HardwareSerial+0x36>
        USARTD0cp = p;
    38aa:	60 93 b7 2b 	sts	0x2BB7, r22
    38ae:	70 93 b8 2b 	sts	0x2BB8, r23
    38b2:	08 95       	ret
    } else if (usart ==  &USARTD1) {
    38b4:	29 e0       	ldi	r18, 0x09	; 9
    38b6:	80 3b       	cpi	r24, 0xB0	; 176
    38b8:	92 07       	cpc	r25, r18
    38ba:	29 f4       	brne	.+10     	; 0x38c6 <_ZL10SetPointerP12USART_structP14HardwareSerial+0x48>
        USARTD1cp = p;
    38bc:	60 93 b9 2b 	sts	0x2BB9, r22
    38c0:	70 93 ba 2b 	sts	0x2BBA, r23
    38c4:	08 95       	ret
    } else if (usart ==  &USARTE0) {
    38c6:	2a e0       	ldi	r18, 0x0A	; 10
    38c8:	80 3a       	cpi	r24, 0xA0	; 160
    38ca:	92 07       	cpc	r25, r18
    38cc:	29 f4       	brne	.+10     	; 0x38d8 <_ZL10SetPointerP12USART_structP14HardwareSerial+0x5a>
        USARTE0cp = p;
    38ce:	60 93 bb 2b 	sts	0x2BBB, r22
    38d2:	70 93 bc 2b 	sts	0x2BBC, r23
    38d6:	08 95       	ret
    } else if (usart ==  &USARTE1) {
    38d8:	2a e0       	ldi	r18, 0x0A	; 10
    38da:	80 3b       	cpi	r24, 0xB0	; 176
    38dc:	92 07       	cpc	r25, r18
    38de:	29 f4       	brne	.+10     	; 0x38ea <_ZL10SetPointerP12USART_structP14HardwareSerial+0x6c>
        USARTE1cp = p;
    38e0:	60 93 bd 2b 	sts	0x2BBD, r22
    38e4:	70 93 be 2b 	sts	0x2BBE, r23
    38e8:	08 95       	ret
    } else if (usart ==  &USARTF0) {
    38ea:	2b e0       	ldi	r18, 0x0B	; 11
    38ec:	80 3a       	cpi	r24, 0xA0	; 160
    38ee:	92 07       	cpc	r25, r18
    38f0:	29 f4       	brne	.+10     	; 0x38fc <_ZL10SetPointerP12USART_structP14HardwareSerial+0x7e>
        USARTF0cp = p;
    38f2:	60 93 bf 2b 	sts	0x2BBF, r22
    38f6:	70 93 c0 2b 	sts	0x2BC0, r23
    38fa:	08 95       	ret
#if defined(USARTF1_RXC_vect)
    } else if (usart ==  &USARTF1) {
    38fc:	80 5b       	subi	r24, 0xB0	; 176
    38fe:	9b 40       	sbci	r25, 0x0B	; 11
    3900:	21 f4       	brne	.+8      	; 0x390a <_ZL10SetPointerP12USART_structP14HardwareSerial+0x8c>
        USARTF1cp = p;
    3902:	60 93 c1 2b 	sts	0x2BC1, r22
    3906:	70 93 c2 2b 	sts	0x2BC2, r23
    390a:	08 95       	ret

0000390c <_ZN14HardwareSerial3rxcEv>:
There are three possible interrupts for the USART. Receive done, Transmit
done and Data Register Ready.
*/
//@{

void HardwareSerial::rxc()
    390c:	0f 93       	push	r16
    390e:	1f 93       	push	r17
    3910:	cf 93       	push	r28
    3912:	df 93       	push	r29
    3914:	fc 01       	movw	r30, r24
{
    unsigned char c = _usart->DATA;
    3916:	a4 81       	ldd	r26, Z+4	; 0x04
    3918:	b5 81       	ldd	r27, Z+5	; 0x05
    391a:	4c 91       	ld	r20, X
    store_char(c,_rx_buffer);
    391c:	02 80       	ldd	r0, Z+2	; 0x02
    391e:	f3 81       	ldd	r31, Z+3	; 0x03
    3920:	e0 2d       	mov	r30, r0
SERIAL_ISR_DEF(USARTF1);
#endif

inline void store_char(unsigned char c, ring_buffer *rx_buffer)
{
    int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
    3922:	8f 01       	movw	r16, r30
    3924:	00 58       	subi	r16, 0x80	; 128
    3926:	1f 4f       	sbci	r17, 0xFF	; 255
    3928:	d8 01       	movw	r26, r16
    392a:	cd 91       	ld	r28, X+
    392c:	dc 91       	ld	r29, X
    392e:	ce 01       	movw	r24, r28
    3930:	01 96       	adiw	r24, 0x01	; 1
    3932:	60 e8       	ldi	r22, 0x80	; 128
    3934:	70 e0       	ldi	r23, 0x00	; 0
    3936:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    393a:	9c 01       	movw	r18, r24
    
    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != rx_buffer->tail) {
    393c:	ee 57       	subi	r30, 0x7E	; 126
    393e:	ff 4f       	sbci	r31, 0xFF	; 255
    3940:	80 81       	ld	r24, Z
    3942:	91 81       	ldd	r25, Z+1	; 0x01
    3944:	e2 58       	subi	r30, 0x82	; 130
    3946:	f0 40       	sbci	r31, 0x00	; 0
    3948:	28 17       	cp	r18, r24
    394a:	39 07       	cpc	r19, r25
    394c:	31 f0       	breq	.+12     	; 0x395a <_ZN14HardwareSerial3rxcEv+0x4e>
        rx_buffer->buffer[rx_buffer->head] = c;
    394e:	ec 0f       	add	r30, r28
    3950:	fd 1f       	adc	r31, r29
    3952:	40 83       	st	Z, r20
        rx_buffer->head = i;
    3954:	f8 01       	movw	r30, r16
    3956:	20 83       	st	Z, r18
    3958:	31 83       	std	Z+1, r19	; 0x01

void HardwareSerial::rxc()
{
    unsigned char c = _usart->DATA;
    store_char(c,_rx_buffer);
}
    395a:	df 91       	pop	r29
    395c:	cf 91       	pop	r28
    395e:	1f 91       	pop	r17
    3960:	0f 91       	pop	r16
    3962:	08 95       	ret

00003964 <__vector_122>:
SERIAL_ISR_DEF(USARTD1);
SERIAL_ISR_DEF(USARTE0);
SERIAL_ISR_DEF(USARTE1);
SERIAL_ISR_DEF(USARTF0);
#if defined(USARTF1_RXC_vect)
SERIAL_ISR_DEF(USARTF1);
    3964:	1f 92       	push	r1
    3966:	0f 92       	push	r0
    3968:	0f b6       	in	r0, 0x3f	; 63
    396a:	0f 92       	push	r0
    396c:	08 b6       	in	r0, 0x38	; 56
    396e:	0f 92       	push	r0
    3970:	09 b6       	in	r0, 0x39	; 57
    3972:	0f 92       	push	r0
    3974:	0b b6       	in	r0, 0x3b	; 59
    3976:	0f 92       	push	r0
    3978:	11 24       	eor	r1, r1
    397a:	18 be       	out	0x38, r1	; 56
    397c:	19 be       	out	0x39, r1	; 57
    397e:	1b be       	out	0x3b, r1	; 59
    3980:	2f 93       	push	r18
    3982:	3f 93       	push	r19
    3984:	4f 93       	push	r20
    3986:	5f 93       	push	r21
    3988:	6f 93       	push	r22
    398a:	7f 93       	push	r23
    398c:	8f 93       	push	r24
    398e:	9f 93       	push	r25
    3990:	af 93       	push	r26
    3992:	bf 93       	push	r27
    3994:	ef 93       	push	r30
    3996:	ff 93       	push	r31
    3998:	80 91 c1 2b 	lds	r24, 0x2BC1
    399c:	90 91 c2 2b 	lds	r25, 0x2BC2
    39a0:	00 97       	sbiw	r24, 0x00	; 0
    39a2:	11 f0       	breq	.+4      	; 0x39a8 <__vector_122+0x44>
    39a4:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    39a8:	ff 91       	pop	r31
    39aa:	ef 91       	pop	r30
    39ac:	bf 91       	pop	r27
    39ae:	af 91       	pop	r26
    39b0:	9f 91       	pop	r25
    39b2:	8f 91       	pop	r24
    39b4:	7f 91       	pop	r23
    39b6:	6f 91       	pop	r22
    39b8:	5f 91       	pop	r21
    39ba:	4f 91       	pop	r20
    39bc:	3f 91       	pop	r19
    39be:	2f 91       	pop	r18
    39c0:	0f 90       	pop	r0
    39c2:	0b be       	out	0x3b, r0	; 59
    39c4:	0f 90       	pop	r0
    39c6:	09 be       	out	0x39, r0	; 57
    39c8:	0f 90       	pop	r0
    39ca:	08 be       	out	0x38, r0	; 56
    39cc:	0f 90       	pop	r0
    39ce:	0f be       	out	0x3f, r0	; 63
    39d0:	0f 90       	pop	r0
    39d2:	1f 90       	pop	r1
    39d4:	18 95       	reti

000039d6 <__vector_119>:
SERIAL_ISR_DEF(USARTC1);
SERIAL_ISR_DEF(USARTD0);
SERIAL_ISR_DEF(USARTD1);
SERIAL_ISR_DEF(USARTE0);
SERIAL_ISR_DEF(USARTE1);
SERIAL_ISR_DEF(USARTF0);
    39d6:	1f 92       	push	r1
    39d8:	0f 92       	push	r0
    39da:	0f b6       	in	r0, 0x3f	; 63
    39dc:	0f 92       	push	r0
    39de:	08 b6       	in	r0, 0x38	; 56
    39e0:	0f 92       	push	r0
    39e2:	09 b6       	in	r0, 0x39	; 57
    39e4:	0f 92       	push	r0
    39e6:	0b b6       	in	r0, 0x3b	; 59
    39e8:	0f 92       	push	r0
    39ea:	11 24       	eor	r1, r1
    39ec:	18 be       	out	0x38, r1	; 56
    39ee:	19 be       	out	0x39, r1	; 57
    39f0:	1b be       	out	0x3b, r1	; 59
    39f2:	2f 93       	push	r18
    39f4:	3f 93       	push	r19
    39f6:	4f 93       	push	r20
    39f8:	5f 93       	push	r21
    39fa:	6f 93       	push	r22
    39fc:	7f 93       	push	r23
    39fe:	8f 93       	push	r24
    3a00:	9f 93       	push	r25
    3a02:	af 93       	push	r26
    3a04:	bf 93       	push	r27
    3a06:	ef 93       	push	r30
    3a08:	ff 93       	push	r31
    3a0a:	80 91 bf 2b 	lds	r24, 0x2BBF
    3a0e:	90 91 c0 2b 	lds	r25, 0x2BC0
    3a12:	00 97       	sbiw	r24, 0x00	; 0
    3a14:	11 f0       	breq	.+4      	; 0x3a1a <__vector_119+0x44>
    3a16:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3a1a:	ff 91       	pop	r31
    3a1c:	ef 91       	pop	r30
    3a1e:	bf 91       	pop	r27
    3a20:	af 91       	pop	r26
    3a22:	9f 91       	pop	r25
    3a24:	8f 91       	pop	r24
    3a26:	7f 91       	pop	r23
    3a28:	6f 91       	pop	r22
    3a2a:	5f 91       	pop	r21
    3a2c:	4f 91       	pop	r20
    3a2e:	3f 91       	pop	r19
    3a30:	2f 91       	pop	r18
    3a32:	0f 90       	pop	r0
    3a34:	0b be       	out	0x3b, r0	; 59
    3a36:	0f 90       	pop	r0
    3a38:	09 be       	out	0x39, r0	; 57
    3a3a:	0f 90       	pop	r0
    3a3c:	08 be       	out	0x38, r0	; 56
    3a3e:	0f 90       	pop	r0
    3a40:	0f be       	out	0x3f, r0	; 63
    3a42:	0f 90       	pop	r0
    3a44:	1f 90       	pop	r1
    3a46:	18 95       	reti

00003a48 <__vector_61>:
SERIAL_ISR_DEF(USARTC0);
SERIAL_ISR_DEF(USARTC1);
SERIAL_ISR_DEF(USARTD0);
SERIAL_ISR_DEF(USARTD1);
SERIAL_ISR_DEF(USARTE0);
SERIAL_ISR_DEF(USARTE1);
    3a48:	1f 92       	push	r1
    3a4a:	0f 92       	push	r0
    3a4c:	0f b6       	in	r0, 0x3f	; 63
    3a4e:	0f 92       	push	r0
    3a50:	08 b6       	in	r0, 0x38	; 56
    3a52:	0f 92       	push	r0
    3a54:	09 b6       	in	r0, 0x39	; 57
    3a56:	0f 92       	push	r0
    3a58:	0b b6       	in	r0, 0x3b	; 59
    3a5a:	0f 92       	push	r0
    3a5c:	11 24       	eor	r1, r1
    3a5e:	18 be       	out	0x38, r1	; 56
    3a60:	19 be       	out	0x39, r1	; 57
    3a62:	1b be       	out	0x3b, r1	; 59
    3a64:	2f 93       	push	r18
    3a66:	3f 93       	push	r19
    3a68:	4f 93       	push	r20
    3a6a:	5f 93       	push	r21
    3a6c:	6f 93       	push	r22
    3a6e:	7f 93       	push	r23
    3a70:	8f 93       	push	r24
    3a72:	9f 93       	push	r25
    3a74:	af 93       	push	r26
    3a76:	bf 93       	push	r27
    3a78:	ef 93       	push	r30
    3a7a:	ff 93       	push	r31
    3a7c:	80 91 bd 2b 	lds	r24, 0x2BBD
    3a80:	90 91 be 2b 	lds	r25, 0x2BBE
    3a84:	00 97       	sbiw	r24, 0x00	; 0
    3a86:	11 f0       	breq	.+4      	; 0x3a8c <__vector_61+0x44>
    3a88:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3a8c:	ff 91       	pop	r31
    3a8e:	ef 91       	pop	r30
    3a90:	bf 91       	pop	r27
    3a92:	af 91       	pop	r26
    3a94:	9f 91       	pop	r25
    3a96:	8f 91       	pop	r24
    3a98:	7f 91       	pop	r23
    3a9a:	6f 91       	pop	r22
    3a9c:	5f 91       	pop	r21
    3a9e:	4f 91       	pop	r20
    3aa0:	3f 91       	pop	r19
    3aa2:	2f 91       	pop	r18
    3aa4:	0f 90       	pop	r0
    3aa6:	0b be       	out	0x3b, r0	; 59
    3aa8:	0f 90       	pop	r0
    3aaa:	09 be       	out	0x39, r0	; 57
    3aac:	0f 90       	pop	r0
    3aae:	08 be       	out	0x38, r0	; 56
    3ab0:	0f 90       	pop	r0
    3ab2:	0f be       	out	0x3f, r0	; 63
    3ab4:	0f 90       	pop	r0
    3ab6:	1f 90       	pop	r1
    3ab8:	18 95       	reti

00003aba <__vector_58>:

SERIAL_ISR_DEF(USARTC0);
SERIAL_ISR_DEF(USARTC1);
SERIAL_ISR_DEF(USARTD0);
SERIAL_ISR_DEF(USARTD1);
SERIAL_ISR_DEF(USARTE0);
    3aba:	1f 92       	push	r1
    3abc:	0f 92       	push	r0
    3abe:	0f b6       	in	r0, 0x3f	; 63
    3ac0:	0f 92       	push	r0
    3ac2:	08 b6       	in	r0, 0x38	; 56
    3ac4:	0f 92       	push	r0
    3ac6:	09 b6       	in	r0, 0x39	; 57
    3ac8:	0f 92       	push	r0
    3aca:	0b b6       	in	r0, 0x3b	; 59
    3acc:	0f 92       	push	r0
    3ace:	11 24       	eor	r1, r1
    3ad0:	18 be       	out	0x38, r1	; 56
    3ad2:	19 be       	out	0x39, r1	; 57
    3ad4:	1b be       	out	0x3b, r1	; 59
    3ad6:	2f 93       	push	r18
    3ad8:	3f 93       	push	r19
    3ada:	4f 93       	push	r20
    3adc:	5f 93       	push	r21
    3ade:	6f 93       	push	r22
    3ae0:	7f 93       	push	r23
    3ae2:	8f 93       	push	r24
    3ae4:	9f 93       	push	r25
    3ae6:	af 93       	push	r26
    3ae8:	bf 93       	push	r27
    3aea:	ef 93       	push	r30
    3aec:	ff 93       	push	r31
    3aee:	80 91 bb 2b 	lds	r24, 0x2BBB
    3af2:	90 91 bc 2b 	lds	r25, 0x2BBC
    3af6:	00 97       	sbiw	r24, 0x00	; 0
    3af8:	11 f0       	breq	.+4      	; 0x3afe <__vector_58+0x44>
    3afa:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3afe:	ff 91       	pop	r31
    3b00:	ef 91       	pop	r30
    3b02:	bf 91       	pop	r27
    3b04:	af 91       	pop	r26
    3b06:	9f 91       	pop	r25
    3b08:	8f 91       	pop	r24
    3b0a:	7f 91       	pop	r23
    3b0c:	6f 91       	pop	r22
    3b0e:	5f 91       	pop	r21
    3b10:	4f 91       	pop	r20
    3b12:	3f 91       	pop	r19
    3b14:	2f 91       	pop	r18
    3b16:	0f 90       	pop	r0
    3b18:	0b be       	out	0x3b, r0	; 59
    3b1a:	0f 90       	pop	r0
    3b1c:	09 be       	out	0x39, r0	; 57
    3b1e:	0f 90       	pop	r0
    3b20:	08 be       	out	0x38, r0	; 56
    3b22:	0f 90       	pop	r0
    3b24:	0f be       	out	0x3f, r0	; 63
    3b26:	0f 90       	pop	r0
    3b28:	1f 90       	pop	r1
    3b2a:	18 95       	reti

00003b2c <__vector_91>:
}

SERIAL_ISR_DEF(USARTC0);
SERIAL_ISR_DEF(USARTC1);
SERIAL_ISR_DEF(USARTD0);
SERIAL_ISR_DEF(USARTD1);
    3b2c:	1f 92       	push	r1
    3b2e:	0f 92       	push	r0
    3b30:	0f b6       	in	r0, 0x3f	; 63
    3b32:	0f 92       	push	r0
    3b34:	08 b6       	in	r0, 0x38	; 56
    3b36:	0f 92       	push	r0
    3b38:	09 b6       	in	r0, 0x39	; 57
    3b3a:	0f 92       	push	r0
    3b3c:	0b b6       	in	r0, 0x3b	; 59
    3b3e:	0f 92       	push	r0
    3b40:	11 24       	eor	r1, r1
    3b42:	18 be       	out	0x38, r1	; 56
    3b44:	19 be       	out	0x39, r1	; 57
    3b46:	1b be       	out	0x3b, r1	; 59
    3b48:	2f 93       	push	r18
    3b4a:	3f 93       	push	r19
    3b4c:	4f 93       	push	r20
    3b4e:	5f 93       	push	r21
    3b50:	6f 93       	push	r22
    3b52:	7f 93       	push	r23
    3b54:	8f 93       	push	r24
    3b56:	9f 93       	push	r25
    3b58:	af 93       	push	r26
    3b5a:	bf 93       	push	r27
    3b5c:	ef 93       	push	r30
    3b5e:	ff 93       	push	r31
    3b60:	80 91 b9 2b 	lds	r24, 0x2BB9
    3b64:	90 91 ba 2b 	lds	r25, 0x2BBA
    3b68:	00 97       	sbiw	r24, 0x00	; 0
    3b6a:	11 f0       	breq	.+4      	; 0x3b70 <__vector_91+0x44>
    3b6c:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3b70:	ff 91       	pop	r31
    3b72:	ef 91       	pop	r30
    3b74:	bf 91       	pop	r27
    3b76:	af 91       	pop	r26
    3b78:	9f 91       	pop	r25
    3b7a:	8f 91       	pop	r24
    3b7c:	7f 91       	pop	r23
    3b7e:	6f 91       	pop	r22
    3b80:	5f 91       	pop	r21
    3b82:	4f 91       	pop	r20
    3b84:	3f 91       	pop	r19
    3b86:	2f 91       	pop	r18
    3b88:	0f 90       	pop	r0
    3b8a:	0b be       	out	0x3b, r0	; 59
    3b8c:	0f 90       	pop	r0
    3b8e:	09 be       	out	0x39, r0	; 57
    3b90:	0f 90       	pop	r0
    3b92:	08 be       	out	0x38, r0	; 56
    3b94:	0f 90       	pop	r0
    3b96:	0f be       	out	0x3f, r0	; 63
    3b98:	0f 90       	pop	r0
    3b9a:	1f 90       	pop	r1
    3b9c:	18 95       	reti

00003b9e <__vector_88>:
    if (usart##cp) usart##cp->txc();\
}

SERIAL_ISR_DEF(USARTC0);
SERIAL_ISR_DEF(USARTC1);
SERIAL_ISR_DEF(USARTD0);
    3b9e:	1f 92       	push	r1
    3ba0:	0f 92       	push	r0
    3ba2:	0f b6       	in	r0, 0x3f	; 63
    3ba4:	0f 92       	push	r0
    3ba6:	08 b6       	in	r0, 0x38	; 56
    3ba8:	0f 92       	push	r0
    3baa:	09 b6       	in	r0, 0x39	; 57
    3bac:	0f 92       	push	r0
    3bae:	0b b6       	in	r0, 0x3b	; 59
    3bb0:	0f 92       	push	r0
    3bb2:	11 24       	eor	r1, r1
    3bb4:	18 be       	out	0x38, r1	; 56
    3bb6:	19 be       	out	0x39, r1	; 57
    3bb8:	1b be       	out	0x3b, r1	; 59
    3bba:	2f 93       	push	r18
    3bbc:	3f 93       	push	r19
    3bbe:	4f 93       	push	r20
    3bc0:	5f 93       	push	r21
    3bc2:	6f 93       	push	r22
    3bc4:	7f 93       	push	r23
    3bc6:	8f 93       	push	r24
    3bc8:	9f 93       	push	r25
    3bca:	af 93       	push	r26
    3bcc:	bf 93       	push	r27
    3bce:	ef 93       	push	r30
    3bd0:	ff 93       	push	r31
    3bd2:	80 91 b7 2b 	lds	r24, 0x2BB7
    3bd6:	90 91 b8 2b 	lds	r25, 0x2BB8
    3bda:	00 97       	sbiw	r24, 0x00	; 0
    3bdc:	11 f0       	breq	.+4      	; 0x3be2 <__vector_88+0x44>
    3bde:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3be2:	ff 91       	pop	r31
    3be4:	ef 91       	pop	r30
    3be6:	bf 91       	pop	r27
    3be8:	af 91       	pop	r26
    3bea:	9f 91       	pop	r25
    3bec:	8f 91       	pop	r24
    3bee:	7f 91       	pop	r23
    3bf0:	6f 91       	pop	r22
    3bf2:	5f 91       	pop	r21
    3bf4:	4f 91       	pop	r20
    3bf6:	3f 91       	pop	r19
    3bf8:	2f 91       	pop	r18
    3bfa:	0f 90       	pop	r0
    3bfc:	0b be       	out	0x3b, r0	; 59
    3bfe:	0f 90       	pop	r0
    3c00:	09 be       	out	0x39, r0	; 57
    3c02:	0f 90       	pop	r0
    3c04:	08 be       	out	0x38, r0	; 56
    3c06:	0f 90       	pop	r0
    3c08:	0f be       	out	0x3f, r0	; 63
    3c0a:	0f 90       	pop	r0
    3c0c:	1f 90       	pop	r1
    3c0e:	18 95       	reti

00003c10 <__vector_28>:
ISR(usart##_TXC_vect) {\
    if (usart##cp) usart##cp->txc();\
}

SERIAL_ISR_DEF(USARTC0);
SERIAL_ISR_DEF(USARTC1);
    3c10:	1f 92       	push	r1
    3c12:	0f 92       	push	r0
    3c14:	0f b6       	in	r0, 0x3f	; 63
    3c16:	0f 92       	push	r0
    3c18:	08 b6       	in	r0, 0x38	; 56
    3c1a:	0f 92       	push	r0
    3c1c:	09 b6       	in	r0, 0x39	; 57
    3c1e:	0f 92       	push	r0
    3c20:	0b b6       	in	r0, 0x3b	; 59
    3c22:	0f 92       	push	r0
    3c24:	11 24       	eor	r1, r1
    3c26:	18 be       	out	0x38, r1	; 56
    3c28:	19 be       	out	0x39, r1	; 57
    3c2a:	1b be       	out	0x3b, r1	; 59
    3c2c:	2f 93       	push	r18
    3c2e:	3f 93       	push	r19
    3c30:	4f 93       	push	r20
    3c32:	5f 93       	push	r21
    3c34:	6f 93       	push	r22
    3c36:	7f 93       	push	r23
    3c38:	8f 93       	push	r24
    3c3a:	9f 93       	push	r25
    3c3c:	af 93       	push	r26
    3c3e:	bf 93       	push	r27
    3c40:	ef 93       	push	r30
    3c42:	ff 93       	push	r31
    3c44:	80 91 b5 2b 	lds	r24, 0x2BB5
    3c48:	90 91 b6 2b 	lds	r25, 0x2BB6
    3c4c:	00 97       	sbiw	r24, 0x00	; 0
    3c4e:	11 f0       	breq	.+4      	; 0x3c54 <__vector_28+0x44>
    3c50:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3c54:	ff 91       	pop	r31
    3c56:	ef 91       	pop	r30
    3c58:	bf 91       	pop	r27
    3c5a:	af 91       	pop	r26
    3c5c:	9f 91       	pop	r25
    3c5e:	8f 91       	pop	r24
    3c60:	7f 91       	pop	r23
    3c62:	6f 91       	pop	r22
    3c64:	5f 91       	pop	r21
    3c66:	4f 91       	pop	r20
    3c68:	3f 91       	pop	r19
    3c6a:	2f 91       	pop	r18
    3c6c:	0f 90       	pop	r0
    3c6e:	0b be       	out	0x3b, r0	; 59
    3c70:	0f 90       	pop	r0
    3c72:	09 be       	out	0x39, r0	; 57
    3c74:	0f 90       	pop	r0
    3c76:	08 be       	out	0x38, r0	; 56
    3c78:	0f 90       	pop	r0
    3c7a:	0f be       	out	0x3f, r0	; 63
    3c7c:	0f 90       	pop	r0
    3c7e:	1f 90       	pop	r1
    3c80:	18 95       	reti

00003c82 <__vector_25>:
}\
ISR(usart##_TXC_vect) {\
    if (usart##cp) usart##cp->txc();\
}

SERIAL_ISR_DEF(USARTC0);
    3c82:	1f 92       	push	r1
    3c84:	0f 92       	push	r0
    3c86:	0f b6       	in	r0, 0x3f	; 63
    3c88:	0f 92       	push	r0
    3c8a:	08 b6       	in	r0, 0x38	; 56
    3c8c:	0f 92       	push	r0
    3c8e:	09 b6       	in	r0, 0x39	; 57
    3c90:	0f 92       	push	r0
    3c92:	0b b6       	in	r0, 0x3b	; 59
    3c94:	0f 92       	push	r0
    3c96:	11 24       	eor	r1, r1
    3c98:	18 be       	out	0x38, r1	; 56
    3c9a:	19 be       	out	0x39, r1	; 57
    3c9c:	1b be       	out	0x3b, r1	; 59
    3c9e:	2f 93       	push	r18
    3ca0:	3f 93       	push	r19
    3ca2:	4f 93       	push	r20
    3ca4:	5f 93       	push	r21
    3ca6:	6f 93       	push	r22
    3ca8:	7f 93       	push	r23
    3caa:	8f 93       	push	r24
    3cac:	9f 93       	push	r25
    3cae:	af 93       	push	r26
    3cb0:	bf 93       	push	r27
    3cb2:	ef 93       	push	r30
    3cb4:	ff 93       	push	r31
    3cb6:	80 91 b3 2b 	lds	r24, 0x2BB3
    3cba:	90 91 b4 2b 	lds	r25, 0x2BB4
    3cbe:	00 97       	sbiw	r24, 0x00	; 0
    3cc0:	11 f0       	breq	.+4      	; 0x3cc6 <__vector_25+0x44>
    3cc2:	0e 94 86 1c 	call	0x390c	; 0x390c <_ZN14HardwareSerial3rxcEv>
    3cc6:	ff 91       	pop	r31
    3cc8:	ef 91       	pop	r30
    3cca:	bf 91       	pop	r27
    3ccc:	af 91       	pop	r26
    3cce:	9f 91       	pop	r25
    3cd0:	8f 91       	pop	r24
    3cd2:	7f 91       	pop	r23
    3cd4:	6f 91       	pop	r22
    3cd6:	5f 91       	pop	r21
    3cd8:	4f 91       	pop	r20
    3cda:	3f 91       	pop	r19
    3cdc:	2f 91       	pop	r18
    3cde:	0f 90       	pop	r0
    3ce0:	0b be       	out	0x3b, r0	; 59
    3ce2:	0f 90       	pop	r0
    3ce4:	09 be       	out	0x39, r0	; 57
    3ce6:	0f 90       	pop	r0
    3ce8:	08 be       	out	0x38, r0	; 56
    3cea:	0f 90       	pop	r0
    3cec:	0f be       	out	0x3f, r0	; 63
    3cee:	0f 90       	pop	r0
    3cf0:	1f 90       	pop	r1
    3cf2:	18 95       	reti

00003cf4 <_ZN14HardwareSerial3dreEv>:
    store_char(c,_rx_buffer);
}

void HardwareSerial::dre()
{
}
    3cf4:	08 95       	ret

00003cf6 <_ZN14HardwareSerial3txcEv>:

void HardwareSerial::txc()
{
}
    3cf6:	08 95       	ret

00003cf8 <_ZN14HardwareSerial5beginEla>:
    _rx_buffer = 0;
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(long baud,int8_t bscale)
    3cf8:	9f 92       	push	r9
    3cfa:	af 92       	push	r10
    3cfc:	bf 92       	push	r11
    3cfe:	cf 92       	push	r12
    3d00:	df 92       	push	r13
    3d02:	ef 92       	push	r14
    3d04:	ff 92       	push	r15
    3d06:	0f 93       	push	r16
    3d08:	1f 93       	push	r17
    3d0a:	cf 93       	push	r28
    3d0c:	df 93       	push	r29
    3d0e:	ec 01       	movw	r28, r24
    3d10:	5a 01       	movw	r10, r20
    3d12:	6b 01       	movw	r12, r22
    3d14:	92 2e       	mov	r9, r18
{
    uint16_t BSEL;
    _bscale = bscale;
    3d16:	2b 87       	std	Y+11, r18	; 0x0b
    _baudrate = baud;
    3d18:	4c 87       	std	Y+12, r20	; 0x0c
    3d1a:	5d 87       	std	Y+13, r21	; 0x0d
    3d1c:	6e 87       	std	Y+14, r22	; 0x0e
    3d1e:	7f 87       	std	Y+15, r23	; 0x0f
    
    float fPER = F_CPU;
    float fBaud = baud;
    
    _port->DIRCLR = _in_bm;  // input
    3d20:	ee 81       	ldd	r30, Y+6	; 0x06
    3d22:	ff 81       	ldd	r31, Y+7	; 0x07
    3d24:	88 85       	ldd	r24, Y+8	; 0x08
    3d26:	82 83       	std	Z+2, r24	; 0x02
    _port->DIRSET = _out_bm; // output
    3d28:	ee 81       	ldd	r30, Y+6	; 0x06
    3d2a:	ff 81       	ldd	r31, Y+7	; 0x07
    3d2c:	89 85       	ldd	r24, Y+9	; 0x09
    3d2e:	81 83       	std	Z+1, r24	; 0x01
    
    // set the baud rate
    if (bscale >= 0) {
    3d30:	27 fd       	sbrc	r18, 7
    3d32:	20 c0       	rjmp	.+64     	; 0x3d74 <_ZN14HardwareSerial5beginEla+0x7c>
        BSEL = fPER/((1 << bscale) * 16 * baud) - 1;
    3d34:	60 e1       	ldi	r22, 0x10	; 16
    3d36:	70 e0       	ldi	r23, 0x00	; 0
    3d38:	02 c0       	rjmp	.+4      	; 0x3d3e <_ZN14HardwareSerial5beginEla+0x46>
    3d3a:	66 0f       	add	r22, r22
    3d3c:	77 1f       	adc	r23, r23
    3d3e:	2a 95       	dec	r18
    3d40:	e2 f7       	brpl	.-8      	; 0x3d3a <_ZN14HardwareSerial5beginEla+0x42>
    3d42:	88 27       	eor	r24, r24
    3d44:	77 fd       	sbrc	r23, 7
    3d46:	80 95       	com	r24
    3d48:	98 2f       	mov	r25, r24
    3d4a:	a6 01       	movw	r20, r12
    3d4c:	95 01       	movw	r18, r10
    3d4e:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    3d52:	0e 94 02 46 	call	0x8c04	; 0x8c04 <__floatsisf>
    3d56:	9b 01       	movw	r18, r22
    3d58:	ac 01       	movw	r20, r24
    3d5a:	60 e0       	ldi	r22, 0x00	; 0
    3d5c:	74 e2       	ldi	r23, 0x24	; 36
    3d5e:	84 ef       	ldi	r24, 0xF4	; 244
    3d60:	9b e4       	ldi	r25, 0x4B	; 75
    3d62:	0e 94 f6 44 	call	0x89ec	; 0x89ec <__divsf3>
    3d66:	20 e0       	ldi	r18, 0x00	; 0
    3d68:	30 e0       	ldi	r19, 0x00	; 0
    3d6a:	40 e8       	ldi	r20, 0x80	; 128
    3d6c:	5f e3       	ldi	r21, 0x3F	; 63
    3d6e:	0e 94 9e 43 	call	0x873c	; 0x873c <__subsf3>
    3d72:	2f c0       	rjmp	.+94     	; 0x3dd2 <_ZN14HardwareSerial5beginEla+0xda>
        //BSEL = F_CPU / 16 / baud - 1;
    } else {
        bscale = -1 * bscale;
    3d74:	91 94       	neg	r9
        BSEL = (1 << bscale) * (fPER/(16.0 * fBaud) - 1);
    3d76:	61 e0       	ldi	r22, 0x01	; 1
    3d78:	70 e0       	ldi	r23, 0x00	; 0
    3d7a:	09 2c       	mov	r0, r9
    3d7c:	02 c0       	rjmp	.+4      	; 0x3d82 <_ZN14HardwareSerial5beginEla+0x8a>
    3d7e:	66 0f       	add	r22, r22
    3d80:	77 1f       	adc	r23, r23
    3d82:	0a 94       	dec	r0
    3d84:	e2 f7       	brpl	.-8      	; 0x3d7e <_ZN14HardwareSerial5beginEla+0x86>
    3d86:	88 27       	eor	r24, r24
    3d88:	77 fd       	sbrc	r23, 7
    3d8a:	80 95       	com	r24
    3d8c:	98 2f       	mov	r25, r24
    3d8e:	0e 94 02 46 	call	0x8c04	; 0x8c04 <__floatsisf>
    3d92:	7b 01       	movw	r14, r22
    3d94:	8c 01       	movw	r16, r24
    3d96:	c6 01       	movw	r24, r12
    3d98:	b5 01       	movw	r22, r10
    3d9a:	0e 94 02 46 	call	0x8c04	; 0x8c04 <__floatsisf>
    3d9e:	20 e0       	ldi	r18, 0x00	; 0
    3da0:	30 e0       	ldi	r19, 0x00	; 0
    3da2:	40 e8       	ldi	r20, 0x80	; 128
    3da4:	51 e4       	ldi	r21, 0x41	; 65
    3da6:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__mulsf3>
    3daa:	9b 01       	movw	r18, r22
    3dac:	ac 01       	movw	r20, r24
    3dae:	60 e0       	ldi	r22, 0x00	; 0
    3db0:	74 e2       	ldi	r23, 0x24	; 36
    3db2:	84 ef       	ldi	r24, 0xF4	; 244
    3db4:	9b e4       	ldi	r25, 0x4B	; 75
    3db6:	0e 94 f6 44 	call	0x89ec	; 0x89ec <__divsf3>
    3dba:	20 e0       	ldi	r18, 0x00	; 0
    3dbc:	30 e0       	ldi	r19, 0x00	; 0
    3dbe:	40 e8       	ldi	r20, 0x80	; 128
    3dc0:	5f e3       	ldi	r21, 0x3F	; 63
    3dc2:	0e 94 9e 43 	call	0x873c	; 0x873c <__subsf3>
    3dc6:	9b 01       	movw	r18, r22
    3dc8:	ac 01       	movw	r20, r24
    3dca:	c8 01       	movw	r24, r16
    3dcc:	b7 01       	movw	r22, r14
    3dce:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__mulsf3>
    3dd2:	0e 94 26 42 	call	0x844c	; 0x844c <__fixunssfsi>
    }
    
    _usart->BAUDCTRLA = (uint8_t)BSEL;
    3dd6:	ec 81       	ldd	r30, Y+4	; 0x04
    3dd8:	fd 81       	ldd	r31, Y+5	; 0x05
    3dda:	66 83       	std	Z+6, r22	; 0x06
    _usart->BAUDCTRLB = ((bscale & 0xf) << 4) | ((BSEL & 0xf00) >> 8);
    3ddc:	ec 81       	ldd	r30, Y+4	; 0x04
    3dde:	fd 81       	ldd	r31, Y+5	; 0x05
    3de0:	60 70       	andi	r22, 0x00	; 0
    3de2:	7f 70       	andi	r23, 0x0F	; 15
    3de4:	92 94       	swap	r9
    3de6:	80 ef       	ldi	r24, 0xF0	; 240
    3de8:	98 22       	and	r9, r24
    3dea:	97 2a       	or	r9, r23
    3dec:	97 82       	std	Z+7, r9	; 0x07
    
    
    // enable Rx and Tx
    _usart->CTRLB |= USART_RXEN_bm | USART_TXEN_bm;
    3dee:	ec 81       	ldd	r30, Y+4	; 0x04
    3df0:	fd 81       	ldd	r31, Y+5	; 0x05
    3df2:	84 81       	ldd	r24, Z+4	; 0x04
    3df4:	88 61       	ori	r24, 0x18	; 24
    3df6:	84 83       	std	Z+4, r24	; 0x04
    // enable interrupt
    _usart->CTRLA = USART_RXCINTLVL_LO_gc;
    3df8:	ec 81       	ldd	r30, Y+4	; 0x04
    3dfa:	fd 81       	ldd	r31, Y+5	; 0x05
    3dfc:	80 e1       	ldi	r24, 0x10	; 16
    3dfe:	83 83       	std	Z+3, r24	; 0x03
    
    // Char size, parity and stop bits: 8N1
    _usart->CTRLC = USART_CHSIZE_8BIT_gc | USART_PMODE_DISABLED_gc;
    3e00:	ec 81       	ldd	r30, Y+4	; 0x04
    3e02:	fd 81       	ldd	r31, Y+5	; 0x05
    3e04:	83 e0       	ldi	r24, 0x03	; 3
    3e06:	85 83       	std	Z+5, r24	; 0x05
    SetPointer(_usart,this);
    3e08:	8c 81       	ldd	r24, Y+4	; 0x04
    3e0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3e0c:	be 01       	movw	r22, r28
    3e0e:	0e 94 3f 1c 	call	0x387e	; 0x387e <_ZL10SetPointerP12USART_structP14HardwareSerial>
}
    3e12:	df 91       	pop	r29
    3e14:	cf 91       	pop	r28
    3e16:	1f 91       	pop	r17
    3e18:	0f 91       	pop	r16
    3e1a:	ff 90       	pop	r15
    3e1c:	ef 90       	pop	r14
    3e1e:	df 90       	pop	r13
    3e20:	cf 90       	pop	r12
    3e22:	bf 90       	pop	r11
    3e24:	af 90       	pop	r10
    3e26:	9f 90       	pop	r9
    3e28:	08 95       	ret

00003e2a <_ZN14HardwareSerial7begin2xEla>:

void HardwareSerial::begin2x(long baud,int8_t bscale)
    3e2a:	cf 92       	push	r12
    3e2c:	df 92       	push	r13
    3e2e:	ef 92       	push	r14
    3e30:	ff 92       	push	r15
    3e32:	0f 93       	push	r16
    3e34:	1f 93       	push	r17
    3e36:	8c 01       	movw	r16, r24
    3e38:	6a 01       	movw	r12, r20
    3e3a:	7b 01       	movw	r14, r22
{
    uint16_t baud_setting;
    _bscale = bscale;
    3e3c:	dc 01       	movw	r26, r24
    3e3e:	1b 96       	adiw	r26, 0x0b	; 11
    3e40:	2c 93       	st	X, r18
    3e42:	1b 97       	sbiw	r26, 0x0b	; 11
    _baudrate = baud;
    3e44:	fc 01       	movw	r30, r24
    3e46:	44 87       	std	Z+12, r20	; 0x0c
    3e48:	55 87       	std	Z+13, r21	; 0x0d
    3e4a:	66 87       	std	Z+14, r22	; 0x0e
    3e4c:	77 87       	std	Z+15, r23	; 0x0f
    
    // TODO: Serial. Fix serial double clock.
    long fPER = F_CPU * 4;
    
    _port->DIRCLR = _in_bm;  // input
    3e4e:	06 80       	ldd	r0, Z+6	; 0x06
    3e50:	f7 81       	ldd	r31, Z+7	; 0x07
    3e52:	e0 2d       	mov	r30, r0
    3e54:	18 96       	adiw	r26, 0x08	; 8
    3e56:	8c 91       	ld	r24, X
    3e58:	18 97       	sbiw	r26, 0x08	; 8
    3e5a:	82 83       	std	Z+2, r24	; 0x02
    _port->DIRSET = _out_bm; // output
    3e5c:	16 96       	adiw	r26, 0x06	; 6
    3e5e:	ed 91       	ld	r30, X+
    3e60:	fc 91       	ld	r31, X
    3e62:	17 97       	sbiw	r26, 0x07	; 7
    3e64:	19 96       	adiw	r26, 0x09	; 9
    3e66:	8c 91       	ld	r24, X
    3e68:	19 97       	sbiw	r26, 0x09	; 9
    3e6a:	81 83       	std	Z+1, r24	; 0x01
    
    // set the baud rate using the 2X calculations
    _usart->CTRLB |= 1 << 1; // the last 1 was the _u2x value
    3e6c:	14 96       	adiw	r26, 0x04	; 4
    3e6e:	ed 91       	ld	r30, X+
    3e70:	fc 91       	ld	r31, X
    3e72:	15 97       	sbiw	r26, 0x05	; 5
    3e74:	84 81       	ldd	r24, Z+4	; 0x04
    3e76:	82 60       	ori	r24, 0x02	; 2
    3e78:	84 83       	std	Z+4, r24	; 0x04
    baud_setting = fPER / 8 / baud - 1;
    3e7a:	60 e0       	ldi	r22, 0x00	; 0
    3e7c:	74 e2       	ldi	r23, 0x24	; 36
    3e7e:	84 ef       	ldi	r24, 0xF4	; 244
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	a7 01       	movw	r20, r14
    3e84:	96 01       	movw	r18, r12
    3e86:	0e 94 96 49 	call	0x932c	; 0x932c <__divmodsi4>
    3e8a:	21 50       	subi	r18, 0x01	; 1
    3e8c:	30 40       	sbci	r19, 0x00	; 0

    _usart->BAUDCTRLA = (uint8_t)baud_setting;
    3e8e:	d8 01       	movw	r26, r16
    3e90:	14 96       	adiw	r26, 0x04	; 4
    3e92:	ed 91       	ld	r30, X+
    3e94:	fc 91       	ld	r31, X
    3e96:	15 97       	sbiw	r26, 0x05	; 5
    3e98:	26 83       	std	Z+6, r18	; 0x06
    _usart->BAUDCTRLB = baud_setting >> 8;
    3e9a:	14 96       	adiw	r26, 0x04	; 4
    3e9c:	ed 91       	ld	r30, X+
    3e9e:	fc 91       	ld	r31, X
    3ea0:	15 97       	sbiw	r26, 0x05	; 5
    3ea2:	37 83       	std	Z+7, r19	; 0x07
    
    
    // enable Rx and Tx
    _usart->CTRLB |= USART_RXEN_bm | USART_TXEN_bm;
    3ea4:	14 96       	adiw	r26, 0x04	; 4
    3ea6:	ed 91       	ld	r30, X+
    3ea8:	fc 91       	ld	r31, X
    3eaa:	15 97       	sbiw	r26, 0x05	; 5
    3eac:	84 81       	ldd	r24, Z+4	; 0x04
    3eae:	88 61       	ori	r24, 0x18	; 24
    3eb0:	84 83       	std	Z+4, r24	; 0x04
    // enable interrupt
    _usart->CTRLA = (_usart->CTRLA & ~USART_RXCINTLVL_gm) | USART_RXCINTLVL_LO_gc;
    3eb2:	14 96       	adiw	r26, 0x04	; 4
    3eb4:	ed 91       	ld	r30, X+
    3eb6:	fc 91       	ld	r31, X
    3eb8:	15 97       	sbiw	r26, 0x05	; 5
    3eba:	83 81       	ldd	r24, Z+3	; 0x03
    3ebc:	8f 7c       	andi	r24, 0xCF	; 207
    3ebe:	80 61       	ori	r24, 0x10	; 16
    3ec0:	83 83       	std	Z+3, r24	; 0x03
    
    // Char size, parity and stop bits: 8N1
    _usart->CTRLC = USART_CHSIZE_8BIT_gc | USART_PMODE_DISABLED_gc;
    3ec2:	14 96       	adiw	r26, 0x04	; 4
    3ec4:	ed 91       	ld	r30, X+
    3ec6:	fc 91       	ld	r31, X
    3ec8:	15 97       	sbiw	r26, 0x05	; 5
    3eca:	83 e0       	ldi	r24, 0x03	; 3
    3ecc:	85 83       	std	Z+5, r24	; 0x05
    SetPointer(_usart,this);
    3ece:	14 96       	adiw	r26, 0x04	; 4
    3ed0:	8d 91       	ld	r24, X+
    3ed2:	9c 91       	ld	r25, X
    3ed4:	15 97       	sbiw	r26, 0x05	; 5
    3ed6:	b8 01       	movw	r22, r16
    3ed8:	0e 94 3f 1c 	call	0x387e	; 0x387e <_ZL10SetPointerP12USART_structP14HardwareSerial>
}
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	df 90       	pop	r13
    3ee6:	cf 90       	pop	r12
    3ee8:	08 95       	ret

00003eea <_ZN14HardwareSerial3endEv>:

void HardwareSerial::end()
    3eea:	0f 93       	push	r16
    3eec:	1f 93       	push	r17
    3eee:	8c 01       	movw	r16, r24
{
    SetPointer(_usart,(HardwareSerial*)0);
    3ef0:	dc 01       	movw	r26, r24
    3ef2:	14 96       	adiw	r26, 0x04	; 4
    3ef4:	8d 91       	ld	r24, X+
    3ef6:	9c 91       	ld	r25, X
    3ef8:	15 97       	sbiw	r26, 0x05	; 5
    3efa:	60 e0       	ldi	r22, 0x00	; 0
    3efc:	70 e0       	ldi	r23, 0x00	; 0
    3efe:	0e 94 3f 1c 	call	0x387e	; 0x387e <_ZL10SetPointerP12USART_structP14HardwareSerial>
    
    // disable Rx and Tx
    _usart->CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
    3f02:	d8 01       	movw	r26, r16
    3f04:	14 96       	adiw	r26, 0x04	; 4
    3f06:	ed 91       	ld	r30, X+
    3f08:	fc 91       	ld	r31, X
    3f0a:	15 97       	sbiw	r26, 0x05	; 5
    3f0c:	84 81       	ldd	r24, Z+4	; 0x04
    3f0e:	87 7e       	andi	r24, 0xE7	; 231
    3f10:	84 83       	std	Z+4, r24	; 0x04
    // disable interrupt
    _usart->CTRLA = (_usart->CTRLA & ~USART_RXCINTLVL_gm) | USART_RXCINTLVL_LO_gc;
    3f12:	14 96       	adiw	r26, 0x04	; 4
    3f14:	ed 91       	ld	r30, X+
    3f16:	fc 91       	ld	r31, X
    3f18:	15 97       	sbiw	r26, 0x05	; 5
    3f1a:	83 81       	ldd	r24, Z+3	; 0x03
    3f1c:	8f 7c       	andi	r24, 0xCF	; 207
    3f1e:	80 61       	ori	r24, 0x10	; 16
    3f20:	83 83       	std	Z+3, r24	; 0x03
}
    3f22:	1f 91       	pop	r17
    3f24:	0f 91       	pop	r16
    3f26:	08 95       	ret

00003f28 <_ZN14HardwareSerial9availableEv>:

uint8_t HardwareSerial::available(void)
{
    return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
    3f28:	dc 01       	movw	r26, r24
    3f2a:	12 96       	adiw	r26, 0x02	; 2
    3f2c:	ed 91       	ld	r30, X+
    3f2e:	fc 91       	ld	r31, X
    3f30:	13 97       	sbiw	r26, 0x03	; 3
    3f32:	e0 58       	subi	r30, 0x80	; 128
    3f34:	ff 4f       	sbci	r31, 0xFF	; 255
    3f36:	81 91       	ld	r24, Z+
    3f38:	91 91       	ld	r25, Z+
    3f3a:	80 58       	subi	r24, 0x80	; 128
    3f3c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f3e:	20 81       	ld	r18, Z
    3f40:	31 81       	ldd	r19, Z+1	; 0x01
    3f42:	82 1b       	sub	r24, r18
    3f44:	93 0b       	sbc	r25, r19
    3f46:	60 e8       	ldi	r22, 0x80	; 128
    3f48:	70 e0       	ldi	r23, 0x00	; 0
    3f4a:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
}
    3f4e:	08 95       	ret

00003f50 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
    3f50:	cf 93       	push	r28
    3f52:	df 93       	push	r29
{
    // if the head isn't ahead of the tail, we don't have any characters
    if (_rx_buffer->head == _rx_buffer->tail) {
    3f54:	dc 01       	movw	r26, r24
    3f56:	12 96       	adiw	r26, 0x02	; 2
    3f58:	ed 91       	ld	r30, X+
    3f5a:	fc 91       	ld	r31, X
    3f5c:	13 97       	sbiw	r26, 0x03	; 3
    3f5e:	ef 01       	movw	r28, r30
    3f60:	ce 57       	subi	r28, 0x7E	; 126
    3f62:	df 4f       	sbci	r29, 0xFF	; 255
    3f64:	48 81       	ld	r20, Y
    3f66:	59 81       	ldd	r21, Y+1	; 0x01
    3f68:	e0 58       	subi	r30, 0x80	; 128
    3f6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3f6c:	80 81       	ld	r24, Z
    3f6e:	91 81       	ldd	r25, Z+1	; 0x01
    3f70:	e0 58       	subi	r30, 0x80	; 128
    3f72:	f0 40       	sbci	r31, 0x00	; 0
    3f74:	84 17       	cp	r24, r20
    3f76:	95 07       	cpc	r25, r21
    3f78:	19 f4       	brne	.+6      	; 0x3f80 <_ZN14HardwareSerial4readEv+0x30>
    3f7a:	2f ef       	ldi	r18, 0xFF	; 255
    3f7c:	3f ef       	ldi	r19, 0xFF	; 255
    3f7e:	0c c0       	rjmp	.+24     	; 0x3f98 <_ZN14HardwareSerial4readEv+0x48>
        return -1;
    } else {
        unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
    3f80:	e4 0f       	add	r30, r20
    3f82:	f5 1f       	adc	r31, r21
    3f84:	20 81       	ld	r18, Z
        _rx_buffer->tail = (_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
    3f86:	ca 01       	movw	r24, r20
    3f88:	01 96       	adiw	r24, 0x01	; 1
    3f8a:	60 e8       	ldi	r22, 0x80	; 128
    3f8c:	70 e0       	ldi	r23, 0x00	; 0
    3f8e:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    3f92:	88 83       	st	Y, r24
    3f94:	99 83       	std	Y+1, r25	; 0x01
        return c;
    3f96:	30 e0       	ldi	r19, 0x00	; 0
    }
}
    3f98:	c9 01       	movw	r24, r18
    3f9a:	df 91       	pop	r29
    3f9c:	cf 91       	pop	r28
    3f9e:	08 95       	ret

00003fa0 <_ZN14HardwareSerial5flushEv>:
    // don't reverse this or there may be problems if the RX interrupt
    // occurs after reading the value of rx_buffer_head but before writing
    // the value to rx_buffer_tail; the previous value of rx_buffer_head
    // may be written to rx_buffer_tail, making it appear as if the buffer
    // were full, not empty.
    _rx_buffer->head = _rx_buffer->tail;
    3fa0:	dc 01       	movw	r26, r24
    3fa2:	12 96       	adiw	r26, 0x02	; 2
    3fa4:	ed 91       	ld	r30, X+
    3fa6:	fc 91       	ld	r31, X
    3fa8:	13 97       	sbiw	r26, 0x03	; 3
    3faa:	ee 57       	subi	r30, 0x7E	; 126
    3fac:	ff 4f       	sbci	r31, 0xFF	; 255
    3fae:	80 81       	ld	r24, Z
    3fb0:	91 81       	ldd	r25, Z+1	; 0x01
    3fb2:	92 93       	st	-Z, r25
    3fb4:	82 93       	st	-Z, r24
}
    3fb6:	08 95       	ret

00003fb8 <_ZN14HardwareSerial5writeEh>:

void HardwareSerial::write(uint8_t c)
    3fb8:	fc 01       	movw	r30, r24
{
    if (_bEn) {
    3fba:	80 89       	ldd	r24, Z+16	; 0x10
    3fbc:	88 23       	and	r24, r24
    3fbe:	39 f0       	breq	.+14     	; 0x3fce <_ZN14HardwareSerial5writeEh+0x16>
        while ( !(_usart->STATUS & USART_DREIF_bm) );
    3fc0:	04 80       	ldd	r0, Z+4	; 0x04
    3fc2:	f5 81       	ldd	r31, Z+5	; 0x05
    3fc4:	e0 2d       	mov	r30, r0
    3fc6:	81 81       	ldd	r24, Z+1	; 0x01
    3fc8:	85 ff       	sbrs	r24, 5
    3fca:	fd cf       	rjmp	.-6      	; 0x3fc6 <_ZN14HardwareSerial5writeEh+0xe>
        _usart->DATA = c;
    3fcc:	60 83       	st	Z, r22
    3fce:	08 95       	ret

00003fd0 <_ZN14HardwareSerial6enableEb>:
    }
}

void HardwareSerial::enable(bool bEn)
{
    _bEn = bEn;
    3fd0:	fc 01       	movw	r30, r24
    3fd2:	60 8b       	std	Z+16, r22	; 0x10
}
    3fd4:	08 95       	ret

00003fd6 <_ZN14HardwareSerialD1Ev>:
    _bscale    = 0;
    _baudrate  = 9600;
    _bEn       = true;
}

HardwareSerial::~HardwareSerial()
    3fd6:	0f 93       	push	r16
    3fd8:	1f 93       	push	r17
    3fda:	8c 01       	movw	r16, r24
    3fdc:	8d e4       	ldi	r24, 0x4D	; 77
    3fde:	93 e2       	ldi	r25, 0x23	; 35
    3fe0:	f8 01       	movw	r30, r16
    3fe2:	80 83       	st	Z, r24
    3fe4:	91 83       	std	Z+1, r25	; 0x01
{
    end();
    3fe6:	c8 01       	movw	r24, r16
    3fe8:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN14HardwareSerial3endEv>
    free(_rx_buffer);
    3fec:	f8 01       	movw	r30, r16
    3fee:	82 81       	ldd	r24, Z+2	; 0x02
    3ff0:	93 81       	ldd	r25, Z+3	; 0x03
    3ff2:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    _rx_buffer = 0;
    3ff6:	f8 01       	movw	r30, r16
    3ff8:	12 82       	std	Z+2, r1	; 0x02
    3ffa:	13 82       	std	Z+3, r1	; 0x03
}
    3ffc:	1f 91       	pop	r17
    3ffe:	0f 91       	pop	r16
    4000:	08 95       	ret

00004002 <_ZN14HardwareSerialD2Ev>:
    _bscale    = 0;
    _baudrate  = 9600;
    _bEn       = true;
}

HardwareSerial::~HardwareSerial()
    4002:	0f 93       	push	r16
    4004:	1f 93       	push	r17
    4006:	8c 01       	movw	r16, r24
    4008:	8d e4       	ldi	r24, 0x4D	; 77
    400a:	93 e2       	ldi	r25, 0x23	; 35
    400c:	f8 01       	movw	r30, r16
    400e:	80 83       	st	Z, r24
    4010:	91 83       	std	Z+1, r25	; 0x01
{
    end();
    4012:	c8 01       	movw	r24, r16
    4014:	0e 94 75 1f 	call	0x3eea	; 0x3eea <_ZN14HardwareSerial3endEv>
    free(_rx_buffer);
    4018:	f8 01       	movw	r30, r16
    401a:	82 81       	ldd	r24, Z+2	; 0x02
    401c:	93 81       	ldd	r25, Z+3	; 0x03
    401e:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
    _rx_buffer = 0;
    4022:	f8 01       	movw	r30, r16
    4024:	12 82       	std	Z+2, r1	; 0x02
    4026:	13 82       	std	Z+3, r1	; 0x03
}
    4028:	1f 91       	pop	r17
    402a:	0f 91       	pop	r16
    402c:	08 95       	ret

0000402e <_ZN14HardwareSerialC1EP12USART_structP11PORT_structhh>:

HardwareSerial::HardwareSerial(
    USART_t     *usart,
    PORT_t      *port,
    uint8_t      in_bm,
    uint8_t      out_bm)
    402e:	af 92       	push	r10
    4030:	bf 92       	push	r11
    4032:	cf 92       	push	r12
    4034:	df 92       	push	r13
    4036:	ef 92       	push	r14
    4038:	ff 92       	push	r15
    403a:	0f 93       	push	r16
    403c:	1f 93       	push	r17
    403e:	7c 01       	movw	r14, r24
    4040:	6b 01       	movw	r12, r22
    4042:	5a 01       	movw	r10, r20
    4044:	12 2f       	mov	r17, r18
    4046:	8d e4       	ldi	r24, 0x4D	; 77
    4048:	93 e2       	ldi	r25, 0x23	; 35
    404a:	f7 01       	movw	r30, r14
    404c:	80 83       	st	Z, r24
    404e:	91 83       	std	Z+1, r25	; 0x01
{
    _rx_buffer = (ring_buffer*)malloc(RX_BUFFER_SIZE+2*sizeof(int));
    4050:	84 e8       	ldi	r24, 0x84	; 132
    4052:	90 e0       	ldi	r25, 0x00	; 0
    4054:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    4058:	f7 01       	movw	r30, r14
    405a:	82 83       	std	Z+2, r24	; 0x02
    405c:	93 83       	std	Z+3, r25	; 0x03
    _usart     = usart;
    405e:	c4 82       	std	Z+4, r12	; 0x04
    4060:	d5 82       	std	Z+5, r13	; 0x05
    _port      = port;
    4062:	a6 82       	std	Z+6, r10	; 0x06
    4064:	b7 82       	std	Z+7, r11	; 0x07
    _in_bm     = in_bm;
    4066:	10 87       	std	Z+8, r17	; 0x08
    _out_bm    = out_bm;
    4068:	01 87       	std	Z+9, r16	; 0x09
    _bsel      = 0;
    406a:	12 86       	std	Z+10, r1	; 0x0a
    _bscale    = 0;
    406c:	13 86       	std	Z+11, r1	; 0x0b
    _baudrate  = 9600;
    406e:	80 e8       	ldi	r24, 0x80	; 128
    4070:	95 e2       	ldi	r25, 0x25	; 37
    4072:	a0 e0       	ldi	r26, 0x00	; 0
    4074:	b0 e0       	ldi	r27, 0x00	; 0
    4076:	84 87       	std	Z+12, r24	; 0x0c
    4078:	95 87       	std	Z+13, r25	; 0x0d
    407a:	a6 87       	std	Z+14, r26	; 0x0e
    407c:	b7 87       	std	Z+15, r27	; 0x0f
    _bEn       = true;
    407e:	81 e0       	ldi	r24, 0x01	; 1
    4080:	80 8b       	std	Z+16, r24	; 0x10
}
    4082:	1f 91       	pop	r17
    4084:	0f 91       	pop	r16
    4086:	ff 90       	pop	r15
    4088:	ef 90       	pop	r14
    408a:	df 90       	pop	r13
    408c:	cf 90       	pop	r12
    408e:	bf 90       	pop	r11
    4090:	af 90       	pop	r10
    4092:	08 95       	ret

00004094 <_ZN14HardwareSerialC2EP12USART_structP11PORT_structhh>:

HardwareSerial::HardwareSerial(
    USART_t     *usart,
    PORT_t      *port,
    uint8_t      in_bm,
    uint8_t      out_bm)
    4094:	af 92       	push	r10
    4096:	bf 92       	push	r11
    4098:	cf 92       	push	r12
    409a:	df 92       	push	r13
    409c:	ef 92       	push	r14
    409e:	ff 92       	push	r15
    40a0:	0f 93       	push	r16
    40a2:	1f 93       	push	r17
    40a4:	7c 01       	movw	r14, r24
    40a6:	6b 01       	movw	r12, r22
    40a8:	5a 01       	movw	r10, r20
    40aa:	12 2f       	mov	r17, r18
    40ac:	8d e4       	ldi	r24, 0x4D	; 77
    40ae:	93 e2       	ldi	r25, 0x23	; 35
    40b0:	f7 01       	movw	r30, r14
    40b2:	80 83       	st	Z, r24
    40b4:	91 83       	std	Z+1, r25	; 0x01
{
    _rx_buffer = (ring_buffer*)malloc(RX_BUFFER_SIZE+2*sizeof(int));
    40b6:	84 e8       	ldi	r24, 0x84	; 132
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    40be:	f7 01       	movw	r30, r14
    40c0:	82 83       	std	Z+2, r24	; 0x02
    40c2:	93 83       	std	Z+3, r25	; 0x03
    _usart     = usart;
    40c4:	c4 82       	std	Z+4, r12	; 0x04
    40c6:	d5 82       	std	Z+5, r13	; 0x05
    _port      = port;
    40c8:	a6 82       	std	Z+6, r10	; 0x06
    40ca:	b7 82       	std	Z+7, r11	; 0x07
    _in_bm     = in_bm;
    40cc:	10 87       	std	Z+8, r17	; 0x08
    _out_bm    = out_bm;
    40ce:	01 87       	std	Z+9, r16	; 0x09
    _bsel      = 0;
    40d0:	12 86       	std	Z+10, r1	; 0x0a
    _bscale    = 0;
    40d2:	13 86       	std	Z+11, r1	; 0x0b
    _baudrate  = 9600;
    40d4:	80 e8       	ldi	r24, 0x80	; 128
    40d6:	95 e2       	ldi	r25, 0x25	; 37
    40d8:	a0 e0       	ldi	r26, 0x00	; 0
    40da:	b0 e0       	ldi	r27, 0x00	; 0
    40dc:	84 87       	std	Z+12, r24	; 0x0c
    40de:	95 87       	std	Z+13, r25	; 0x0d
    40e0:	a6 87       	std	Z+14, r26	; 0x0e
    40e2:	b7 87       	std	Z+15, r27	; 0x0f
    _bEn       = true;
    40e4:	81 e0       	ldi	r24, 0x01	; 1
    40e6:	80 8b       	std	Z+16, r24	; 0x10
}
    40e8:	1f 91       	pop	r17
    40ea:	0f 91       	pop	r16
    40ec:	ff 90       	pop	r15
    40ee:	ef 90       	pop	r14
    40f0:	df 90       	pop	r13
    40f2:	cf 90       	pop	r12
    40f4:	bf 90       	pop	r11
    40f6:	af 90       	pop	r10
    40f8:	08 95       	ret

000040fa <_ZN9DebugPort8SetStateEh>:
//! The masked pins may not be sequential, so we
//! iterate over the pinMask using tMask.
//! bitMask selects succesive bits in s to output
//! We drive all pins low first, then drive the new
//! state.
void DebugPort::SetState(uint8_t s)
    40fa:	fc 01       	movw	r30, r24
{
    _pPort->OUT = (_pPort->OUT & ~_pinMask) 
            | ((s << _nShift) & _pinMask);
    40fc:	a0 81       	ld	r26, Z
    40fe:	b1 81       	ldd	r27, Z+1	; 0x01
    4100:	14 96       	adiw	r26, 0x04	; 4
    4102:	3c 91       	ld	r19, X
    4104:	14 97       	sbiw	r26, 0x04	; 4
    4106:	25 81       	ldd	r18, Z+5	; 0x05
    4108:	86 2f       	mov	r24, r22
    410a:	90 e0       	ldi	r25, 0x00	; 0
    410c:	07 80       	ldd	r0, Z+7	; 0x07
    410e:	02 c0       	rjmp	.+4      	; 0x4114 <_ZN9DebugPort8SetStateEh+0x1a>
    4110:	88 0f       	add	r24, r24
    4112:	99 1f       	adc	r25, r25
    4114:	0a 94       	dec	r0
    4116:	e2 f7       	brpl	.-8      	; 0x4110 <_ZN9DebugPort8SetStateEh+0x16>
    4118:	82 23       	and	r24, r18
    411a:	20 95       	com	r18
    411c:	23 23       	and	r18, r19
    411e:	82 2b       	or	r24, r18
    4120:	14 96       	adiw	r26, 0x04	; 4
    4122:	8c 93       	st	X, r24
    _lastState = s;
    4124:	66 83       	std	Z+6, r22	; 0x06
}
    4126:	08 95       	ret

00004128 <_ZN9DebugPort7PinMaskEhh>:
    _pinMask = 0;
    _lastState = 0;
    _nShift = 0;
}

void DebugPort::PinMask(uint8_t mask, uint8_t shift)
    4128:	cf 92       	push	r12
    412a:	df 92       	push	r13
    412c:	ef 92       	push	r14
    412e:	0f 93       	push	r16
    4130:	6c 01       	movw	r12, r24
{
    _pinMask = mask;
    4132:	fc 01       	movw	r30, r24
    4134:	65 83       	std	Z+5, r22	; 0x05
    _nShift = shift;
    4136:	47 83       	std	Z+7, r20	; 0x07
    PinControl(mask,
        false, false,
        PORT_OPC_TOTEM_gc,
        PORT_ISC_BOTHEDGES_gc);
    4138:	40 e0       	ldi	r20, 0x00	; 0
    413a:	20 e0       	ldi	r18, 0x00	; 0
    413c:	00 e0       	ldi	r16, 0x00	; 0
    413e:	ee 24       	eor	r14, r14
    4140:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <_ZN4Port10PinControlEhbb13PORT_OPC_enum13PORT_ISC_enum>
    
    SetPinsAsOutput(_pinMask);
    4144:	c6 01       	movw	r24, r12
    4146:	f6 01       	movw	r30, r12
    4148:	65 81       	ldd	r22, Z+5	; 0x05
    414a:	0e 94 74 2f 	call	0x5ee8	; 0x5ee8 <_ZN4Port15SetPinsAsOutputEh>
    SetPinsLow(_pinMask);
    414e:	c6 01       	movw	r24, r12
    4150:	f6 01       	movw	r30, r12
    4152:	65 81       	ldd	r22, Z+5	; 0x05
    4154:	0e 94 80 2f 	call	0x5f00	; 0x5f00 <_ZN4Port10SetPinsLowEh>
    _lastState = 0;
    4158:	f6 01       	movw	r30, r12
    415a:	16 82       	std	Z+6, r1	; 0x06
}
    415c:	0f 91       	pop	r16
    415e:	ef 90       	pop	r14
    4160:	df 90       	pop	r13
    4162:	cf 90       	pop	r12
    4164:	08 95       	ret

00004166 <_ZN9DebugPortC1EP11PORT_struct>:

#include <avr/io.h>
#include "DebugPort.h"

DebugPort::DebugPort(PORT_t* pPort) : Port(pPort)
    4166:	0f 93       	push	r16
    4168:	1f 93       	push	r17
    416a:	8c 01       	movw	r16, r24
    416c:	0e 94 f7 2b 	call	0x57ee	; 0x57ee <_ZN4PortC2EP11PORT_struct>
{
    _pinMask = 0;
    4170:	f8 01       	movw	r30, r16
    4172:	15 82       	std	Z+5, r1	; 0x05
    _lastState = 0;
    4174:	16 82       	std	Z+6, r1	; 0x06
    _nShift = 0;
    4176:	17 82       	std	Z+7, r1	; 0x07
}
    4178:	1f 91       	pop	r17
    417a:	0f 91       	pop	r16
    417c:	08 95       	ret

0000417e <_ZN9DebugPortC2EP11PORT_struct>:

#include <avr/io.h>
#include "DebugPort.h"

DebugPort::DebugPort(PORT_t* pPort) : Port(pPort)
    417e:	0f 93       	push	r16
    4180:	1f 93       	push	r17
    4182:	8c 01       	movw	r16, r24
    4184:	0e 94 f7 2b 	call	0x57ee	; 0x57ee <_ZN4PortC2EP11PORT_struct>
{
    _pinMask = 0;
    4188:	f8 01       	movw	r30, r16
    418a:	15 82       	std	Z+5, r1	; 0x05
    _lastState = 0;
    418c:	16 82       	std	Z+6, r1	; 0x06
    _nShift = 0;
    418e:	17 82       	std	Z+7, r1	; 0x07
}
    4190:	1f 91       	pop	r17
    4192:	0f 91       	pop	r16
    4194:	08 95       	ret

00004196 <__vector_12>:
} \
ISR(periph##_TWIS_vect) {\
    if (periph##_master_cp) periph##_master_cp->slave_int();\
}

I2C_ISR_DEF(TWIC);
    4196:	1f 92       	push	r1
    4198:	0f 92       	push	r0
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	0f 92       	push	r0
    419e:	08 b6       	in	r0, 0x38	; 56
    41a0:	0f 92       	push	r0
    41a2:	11 24       	eor	r1, r1
    41a4:	18 be       	out	0x38, r1	; 56
    41a6:	0f 90       	pop	r0
    41a8:	08 be       	out	0x38, r0	; 56
    41aa:	0f 90       	pop	r0
    41ac:	0f be       	out	0x3f, r0	; 63
    41ae:	0f 90       	pop	r0
    41b0:	1f 90       	pop	r1
    41b2:	18 95       	reti

000041b4 <__vector_45>:
I2C_ISR_DEF(TWIE);
    41b4:	1f 92       	push	r1
    41b6:	0f 92       	push	r0
    41b8:	0f b6       	in	r0, 0x3f	; 63
    41ba:	0f 92       	push	r0
    41bc:	08 b6       	in	r0, 0x38	; 56
    41be:	0f 92       	push	r0
    41c0:	11 24       	eor	r1, r1
    41c2:	18 be       	out	0x38, r1	; 56
    41c4:	0f 90       	pop	r0
    41c6:	08 be       	out	0x38, r0	; 56
    41c8:	0f 90       	pop	r0
    41ca:	0f be       	out	0x3f, r0	; 63
    41cc:	0f 90       	pop	r0
    41ce:	1f 90       	pop	r1
    41d0:	18 95       	reti

000041d2 <__vector_75>:
#if defined(__AVR_ATxmega128A1__)
I2C_ISR_DEF(TWID);
    41d2:	1f 92       	push	r1
    41d4:	0f 92       	push	r0
    41d6:	0f b6       	in	r0, 0x3f	; 63
    41d8:	0f 92       	push	r0
    41da:	08 b6       	in	r0, 0x38	; 56
    41dc:	0f 92       	push	r0
    41de:	11 24       	eor	r1, r1
    41e0:	18 be       	out	0x38, r1	; 56
    41e2:	0f 90       	pop	r0
    41e4:	08 be       	out	0x38, r0	; 56
    41e6:	0f 90       	pop	r0
    41e8:	0f be       	out	0x3f, r0	; 63
    41ea:	0f 90       	pop	r0
    41ec:	1f 90       	pop	r1
    41ee:	18 95       	reti

000041f0 <__vector_106>:
I2C_ISR_DEF(TWIF);
    41f0:	1f 92       	push	r1
    41f2:	0f 92       	push	r0
    41f4:	0f b6       	in	r0, 0x3f	; 63
    41f6:	0f 92       	push	r0
    41f8:	08 b6       	in	r0, 0x38	; 56
    41fa:	0f 92       	push	r0
    41fc:	11 24       	eor	r1, r1
    41fe:	18 be       	out	0x38, r1	; 56
    4200:	0f 90       	pop	r0
    4202:	08 be       	out	0x38, r0	; 56
    4204:	0f 90       	pop	r0
    4206:	0f be       	out	0x3f, r0	; 63
    4208:	0f 90       	pop	r0
    420a:	1f 90       	pop	r1
    420c:	18 95       	reti

0000420e <_ZL13SetTWIPointerP10TWI_structP10I2C_Master>:
#endif

static void SetTWIPointer(TWI_t* ptype, I2C_Master* pm)
{
    if(ptype == &TWIC) {
    420e:	24 e0       	ldi	r18, 0x04	; 4
    4210:	80 38       	cpi	r24, 0x80	; 128
    4212:	92 07       	cpc	r25, r18
    4214:	29 f4       	brne	.+10     	; 0x4220 <_ZL13SetTWIPointerP10TWI_structP10I2C_Master+0x12>
        TWIC_master_cp = pm;
    4216:	60 93 c3 2b 	sts	0x2BC3, r22
    421a:	70 93 c4 2b 	sts	0x2BC4, r23
    421e:	08 95       	ret
#if defined (__AVR_ATxmega128A1__)
    } else if (ptype == &TWID) {
    4220:	24 e0       	ldi	r18, 0x04	; 4
    4222:	80 39       	cpi	r24, 0x90	; 144
    4224:	92 07       	cpc	r25, r18
    4226:	29 f4       	brne	.+10     	; 0x4232 <_ZL13SetTWIPointerP10TWI_structP10I2C_Master+0x24>
        TWID_master_cp = pm;
    4228:	60 93 c5 2b 	sts	0x2BC5, r22
    422c:	70 93 c6 2b 	sts	0x2BC6, r23
    4230:	08 95       	ret
    } else if (ptype ==  &TWIF) {
    4232:	24 e0       	ldi	r18, 0x04	; 4
    4234:	80 3b       	cpi	r24, 0xB0	; 176
    4236:	92 07       	cpc	r25, r18
    4238:	29 f4       	brne	.+10     	; 0x4244 <_ZL13SetTWIPointerP10TWI_structP10I2C_Master+0x36>
        TWIF_master_cp = pm;
    423a:	60 93 c7 2b 	sts	0x2BC7, r22
    423e:	70 93 c8 2b 	sts	0x2BC8, r23
    4242:	08 95       	ret
#endif
    } else if (ptype ==  &TWIE) {
    4244:	80 5a       	subi	r24, 0xA0	; 160
    4246:	94 40       	sbci	r25, 0x04	; 4
    4248:	21 f4       	brne	.+8      	; 0x4252 <_ZL13SetTWIPointerP10TWI_structP10I2C_Master+0x44>
        TWIE_master_cp = pm;
    424a:	60 93 c9 2b 	sts	0x2BC9, r22
    424e:	70 93 ca 2b 	sts	0x2BCA, r23
    4252:	08 95       	ret

00004254 <_ZN10I2C_Master8NotifyMeEP9I2CNotify>:
    SetTWIPointer(_twi,(I2C_Master*)0);
}

void I2C_Master::NotifyMe(I2CNotify* pMe)
{
    _pNotifyClient = pMe;
    4254:	fc 01       	movw	r30, r24
    4256:	61 87       	std	Z+9, r22	; 0x09
    4258:	72 87       	std	Z+10, r23	; 0x0a
}
    425a:	08 95       	ret

0000425c <_ZN10I2C_Master9CleanRegsEv>:

//! Clean up the I2C Master registers without an end/begin.
void I2C_Master::CleanRegs()
    425c:	fc 01       	movw	r30, r24
    _twi->MASTER.STATUS = 
        TWI_MASTER_RIF_bm |
        TWI_MASTER_WIF_bm |
        TWI_MASTER_ARBLOST_bm |
        TWI_MASTER_BUSERR_bm |
        TWI_MASTER_BUSSTATE_IDLE_gc;
    425e:	01 90       	ld	r0, Z+
    4260:	f0 81       	ld	r31, Z
    4262:	e0 2d       	mov	r30, r0
    4264:	8d ec       	ldi	r24, 0xCD	; 205
    4266:	84 83       	std	Z+4, r24	; 0x04
}
    4268:	08 95       	ret

0000426a <_ZN10I2C_Master8busStateEv>:
    showstate();

	return 0;
}

uint8_t I2C_Master::busState()
    426a:	fc 01       	movw	r30, r24
{
    return (_twi->MASTER.STATUS & TWI_MASTER_BUSSTATE_gm);
    426c:	01 90       	ld	r0, Z+
    426e:	f0 81       	ld	r31, Z
    4270:	e0 2d       	mov	r30, r0
    4272:	84 81       	ldd	r24, Z+4	; 0x04
}
    4274:	83 70       	andi	r24, 0x03	; 3
    4276:	08 95       	ret

00004278 <_ZN10I2C_Master8ReadDataEh>:
    _State      = sBusy;

    return eNone;
}

uint8_t I2C_Master::ReadData(uint8_t idx)
    4278:	fc 01       	movw	r30, r24
{
    if (_State == sIdle && _Result == rOk && idx < _nBytesRead) {
    427a:	85 81       	ldd	r24, Z+5	; 0x05
    427c:	88 23       	and	r24, r24
    427e:	69 f4       	brne	.+26     	; 0x429a <_ZN10I2C_Master8ReadDataEh+0x22>
    4280:	86 81       	ldd	r24, Z+6	; 0x06
    4282:	88 23       	and	r24, r24
    4284:	51 f4       	brne	.+20     	; 0x429a <_ZN10I2C_Master8ReadDataEh+0x22>
    4286:	87 85       	ldd	r24, Z+15	; 0x0f
    4288:	68 17       	cp	r22, r24
    428a:	38 f4       	brcc	.+14     	; 0x429a <_ZN10I2C_Master8ReadDataEh+0x22>
        return _ReadData[idx];
    428c:	03 88       	ldd	r0, Z+19	; 0x13
    428e:	f4 89       	ldd	r31, Z+20	; 0x14
    4290:	e0 2d       	mov	r30, r0
    4292:	e6 0f       	add	r30, r22
    4294:	f1 1d       	adc	r31, r1
    4296:	80 81       	ld	r24, Z
    4298:	08 95       	ret
    429a:	80 e0       	ldi	r24, 0x00	; 0
    }
    return 0;
}
    429c:	08 95       	ret

0000429e <_ZN10I2C_Master10nReadBytesEv>:
}

uint8_t I2C_Master::nReadBytes() 
{
    return _nBytesRead; 
}
    429e:	fc 01       	movw	r30, r24
    42a0:	87 85       	ldd	r24, Z+15	; 0x0f
    42a2:	08 95       	ret

000042a4 <_ZN10I2C_Master4busyEv>:

bool I2C_Master::busy()
    42a4:	fc 01       	movw	r30, r24
    42a6:	85 81       	ldd	r24, Z+5	; 0x05
    42a8:	81 11       	cpse	r24, r1
    42aa:	81 e0       	ldi	r24, 0x01	; 1
{
    if (_State != sIdle) return true;

    return false;
}
    42ac:	08 95       	ret

000042ae <_ZN10I2C_Master10isReservedEv>:

void* I2C_Master::isReserved()
    42ae:	fc 01       	movw	r30, r24
{
    return _pReserved;
}
    42b0:	87 81       	ldd	r24, Z+7	; 0x07
    42b2:	90 85       	ldd	r25, Z+8	; 0x08
    42b4:	08 95       	ret

000042b6 <_ZN10I2C_Master7ReserveEPv>:


bool I2C_Master::Reserve(void* pThis)
    42b6:	fc 01       	movw	r30, r24
{
    if (!_pReserved) {
    42b8:	27 81       	ldd	r18, Z+7	; 0x07
    42ba:	30 85       	ldd	r19, Z+8	; 0x08
    42bc:	21 15       	cp	r18, r1
    42be:	31 05       	cpc	r19, r1
    42c0:	21 f4       	brne	.+8      	; 0x42ca <_ZN10I2C_Master7ReserveEPv+0x14>
        _pReserved = pThis;
    42c2:	67 83       	std	Z+7, r22	; 0x07
    42c4:	70 87       	std	Z+8, r23	; 0x08
    42c6:	81 e0       	ldi	r24, 0x01	; 1
    42c8:	08 95       	ret
        return true;
    42ca:	80 e0       	ldi	r24, 0x00	; 0
    42cc:	26 17       	cp	r18, r22
    42ce:	37 07       	cpc	r19, r23
    42d0:	09 f4       	brne	.+2      	; 0x42d4 <_ZN10I2C_Master7ReserveEPv+0x1e>
    42d2:	81 e0       	ldi	r24, 0x01	; 1
        if (_pReserved == pThis) {
            return true;
        }
    }
    return false;
}
    42d4:	08 95       	ret

000042d6 <_ZN10I2C_Master5StateEv>:

I2C_Master::DriverState I2C_Master::State()
{
    return _State;
}
    42d6:	fc 01       	movw	r30, r24
    42d8:	85 81       	ldd	r24, Z+5	; 0x05
    42da:	08 95       	ret

000042dc <_ZN10I2C_Master6ResultEv>:

I2C_Master::DriverResult I2C_Master::Result()
{
    return _Result;
}
    42dc:	fc 01       	movw	r30, r24
    42de:	86 81       	ldd	r24, Z+6	; 0x06
    42e0:	08 95       	ret

000042e2 <_ZN10I2C_Master4StopEv>:

void I2C_Master::Stop()
    42e2:	fc 01       	movw	r30, r24
{
    _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    42e4:	01 90       	ld	r0, Z+
    42e6:	f0 81       	ld	r31, Z
    42e8:	e0 2d       	mov	r30, r0
    42ea:	83 e0       	ldi	r24, 0x03	; 3
    42ec:	83 83       	std	Z+3, r24	; 0x03
}
    42ee:	08 95       	ret

000042f0 <_ZN10I2C_Master14ForceStartStopEv>:

I2C_Master::ErrorType I2C_Master::ForceStartStop()
    42f0:	dc 01       	movw	r26, r24
    void NotifyMe(I2CNotify* pMe);
    
    inline bool IsIdle()
    {
        return (_twi->MASTER.STATUS & TWI_MASTER_BUSSTATE_gm) 
            == TWI_MASTER_BUSSTATE_IDLE_gc;
    42f2:	ed 91       	ld	r30, X+
    42f4:	fc 91       	ld	r31, X
    42f6:	11 97       	sbiw	r26, 0x01	; 1
    42f8:	28 ee       	ldi	r18, 0xE8	; 232
    42fa:	33 e0       	ldi	r19, 0x03	; 3
	__asm__ volatile (
		"1: dec %0" "\n\t"
		"brne 1b"
		: "=r" (__count)
		: "0" (__count)
	);
    42fc:	9a e0       	ldi	r25, 0x0A	; 10
    42fe:	84 81       	ldd	r24, Z+4	; 0x04
{
    // Wait for master to be idle.
    uint16_t waitTimeout = 1000;
    while (waitTimeout && !IsIdle()) {
    4300:	83 70       	andi	r24, 0x03	; 3
    4302:	81 30       	cpi	r24, 0x01	; 1
    4304:	09 f4       	brne	.+2      	; 0x4308 <_ZN10I2C_Master14ForceStartStopEv+0x18>
    4306:	7f c0       	rjmp	.+254    	; 0x4406 <_ZN10I2C_Master14ForceStartStopEv+0x116>
    4308:	89 2f       	mov	r24, r25
    430a:	8a 95       	dec	r24
    430c:	f1 f7       	brne	.-4      	; 0x430a <_ZN10I2C_Master14ForceStartStopEv+0x1a>
        _delay_us(1);
        --waitTimeout;
    430e:	21 50       	subi	r18, 0x01	; 1
    4310:	30 40       	sbci	r19, 0x00	; 0

I2C_Master::ErrorType I2C_Master::ForceStartStop()
{
    // Wait for master to be idle.
    uint16_t waitTimeout = 1000;
    while (waitTimeout && !IsIdle()) {
    4312:	09 f4       	brne	.+2      	; 0x4316 <_ZN10I2C_Master14ForceStartStopEv+0x26>
    4314:	76 c0       	rjmp	.+236    	; 0x4402 <_ZN10I2C_Master14ForceStartStopEv+0x112>
    4316:	f3 cf       	rjmp	.-26     	; 0x42fe <_ZN10I2C_Master14ForceStartStopEv+0xe>
    
    if (!waitTimeout) {
        return eTimeout; // Timeout.
    }
    
    uint8_t oldState = _twi->MASTER.CTRLA; 
    4318:	41 81       	ldd	r20, Z+1	; 0x01
    431a:	95 e1       	ldi	r25, 0x15	; 21
    431c:	89 2f       	mov	r24, r25
    431e:	8a 95       	dec	r24
    4320:	f1 f7       	brne	.-4      	; 0x431e <_ZN10I2C_Master14ForceStartStopEv+0x2e>
    _delay_us(2);
    _twi->MASTER.CTRLA = 0; // Turn off interrupts and disable master.
    4322:	11 82       	std	Z+1, r1	; 0x01
    
    _twiPort->DIRSET = 0x3;
    4324:	12 96       	adiw	r26, 0x02	; 2
    4326:	ed 91       	ld	r30, X+
    4328:	fc 91       	ld	r31, X
    432a:	13 97       	sbiw	r26, 0x03	; 3
    432c:	83 e0       	ldi	r24, 0x03	; 3
    432e:	81 83       	std	Z+1, r24	; 0x01
    _twiPort->OUTSET = 0x3; // Set SCL and SDA High
    4330:	12 96       	adiw	r26, 0x02	; 2
    4332:	ed 91       	ld	r30, X+
    4334:	fc 91       	ld	r31, X
    4336:	13 97       	sbiw	r26, 0x03	; 3
    4338:	85 83       	std	Z+5, r24	; 0x05
    433a:	85 e3       	ldi	r24, 0x35	; 53
    433c:	8a 95       	dec	r24
    433e:	f1 f7       	brne	.-4      	; 0x433c <_ZN10I2C_Master14ForceStartStopEv+0x4c>
    _delay_us(5);
    
    if ((_twiPort->IN & 0x1) == 0) {
    4340:	12 96       	adiw	r26, 0x02	; 2
    4342:	ed 91       	ld	r30, X+
    4344:	fc 91       	ld	r31, X
    4346:	13 97       	sbiw	r26, 0x03	; 3
    4348:	80 85       	ldd	r24, Z+8	; 0x08
    434a:	80 fd       	sbrc	r24, 0
    434c:	0a c0       	rjmp	.+20     	; 0x4362 <_ZN10I2C_Master14ForceStartStopEv+0x72>
        // SDA Line Hung low!
        _twi->MASTER.CTRLA = oldState;
    434e:	ed 91       	ld	r30, X+
    4350:	fc 91       	ld	r31, X
    4352:	11 97       	sbiw	r26, 0x01	; 1
    4354:	41 83       	std	Z+1, r20	; 0x01
        _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4356:	ed 91       	ld	r30, X+
    4358:	fc 91       	ld	r31, X
    435a:	81 e0       	ldi	r24, 0x01	; 1
    435c:	84 83       	std	Z+4, r24	; 0x04
    435e:	89 ef       	ldi	r24, 0xF9	; 249
    4360:	08 95       	ret
        return eSDAStuck;
    }
    
    if ((_twiPort->IN & 0x2) == 0) {
    4362:	80 85       	ldd	r24, Z+8	; 0x08
    4364:	81 fd       	sbrc	r24, 1
    4366:	0a c0       	rjmp	.+20     	; 0x437c <_ZN10I2C_Master14ForceStartStopEv+0x8c>
        _twi->MASTER.CTRLA = oldState;
    4368:	ed 91       	ld	r30, X+
    436a:	fc 91       	ld	r31, X
    436c:	11 97       	sbiw	r26, 0x01	; 1
    436e:	41 83       	std	Z+1, r20	; 0x01
        _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4370:	ed 91       	ld	r30, X+
    4372:	fc 91       	ld	r31, X
    4374:	81 e0       	ldi	r24, 0x01	; 1
    4376:	84 83       	std	Z+4, r24	; 0x04
    4378:	88 ef       	ldi	r24, 0xF8	; 248
    437a:	08 95       	ret
        return eSCLStuck;
    }
    
    _twiPort->OUTCLR = 0x1; // Set SDA Low 
    437c:	81 e0       	ldi	r24, 0x01	; 1
    437e:	86 83       	std	Z+6, r24	; 0x06
    4380:	89 2f       	mov	r24, r25
    4382:	8a 95       	dec	r24
    4384:	f1 f7       	brne	.-4      	; 0x4382 <_ZN10I2C_Master14ForceStartStopEv+0x92>
    _delay_us(2);
    _twiPort->OUTCLR = 0x2; // Set SCL Low
    4386:	12 96       	adiw	r26, 0x02	; 2
    4388:	ed 91       	ld	r30, X+
    438a:	fc 91       	ld	r31, X
    438c:	13 97       	sbiw	r26, 0x03	; 3
    438e:	82 e0       	ldi	r24, 0x02	; 2
    4390:	86 83       	std	Z+6, r24	; 0x06
    4392:	20 e0       	ldi	r18, 0x00	; 0
    4394:	30 e0       	ldi	r19, 0x00	; 0
    4396:	50 e2       	ldi	r21, 0x20	; 32
    
    for (int x=0;x<9;x++) {
        _delay_us(3);
        _twiPort->OUTSET = 0x2; // SCL Hi
    4398:	92 e0       	ldi	r25, 0x02	; 2
    439a:	60 e2       	ldi	r22, 0x20	; 32
    439c:	85 2f       	mov	r24, r21
    439e:	8a 95       	dec	r24
    43a0:	f1 f7       	brne	.-4      	; 0x439e <_ZN10I2C_Master14ForceStartStopEv+0xae>
    43a2:	12 96       	adiw	r26, 0x02	; 2
    43a4:	ed 91       	ld	r30, X+
    43a6:	fc 91       	ld	r31, X
    43a8:	13 97       	sbiw	r26, 0x03	; 3
    43aa:	95 83       	std	Z+5, r25	; 0x05
    43ac:	85 2f       	mov	r24, r21
    43ae:	8a 95       	dec	r24
    43b0:	f1 f7       	brne	.-4      	; 0x43ae <_ZN10I2C_Master14ForceStartStopEv+0xbe>
        _delay_us(3);
        _twiPort->OUTCLR = 0x2; // SCL Lo
    43b2:	12 96       	adiw	r26, 0x02	; 2
    43b4:	ed 91       	ld	r30, X+
    43b6:	fc 91       	ld	r31, X
    43b8:	13 97       	sbiw	r26, 0x03	; 3
    43ba:	96 83       	std	Z+6, r25	; 0x06
    
    _twiPort->OUTCLR = 0x1; // Set SDA Low 
    _delay_us(2);
    _twiPort->OUTCLR = 0x2; // Set SCL Low
    
    for (int x=0;x<9;x++) {
    43bc:	2f 5f       	subi	r18, 0xFF	; 255
    43be:	3f 4f       	sbci	r19, 0xFF	; 255
    43c0:	29 30       	cpi	r18, 0x09	; 9
    43c2:	31 05       	cpc	r19, r1
    43c4:	51 f7       	brne	.-44     	; 0x439a <_ZN10I2C_Master14ForceStartStopEv+0xaa>
    43c6:	86 2f       	mov	r24, r22
    43c8:	8a 95       	dec	r24
    43ca:	f1 f7       	brne	.-4      	; 0x43c8 <_ZN10I2C_Master14ForceStartStopEv+0xd8>
        _delay_us(3);
        _twiPort->OUTCLR = 0x2; // SCL Lo
    }
    
    _delay_us(3);
    _twiPort->OUTSET = 0x2; // SCL Hi
    43cc:	12 96       	adiw	r26, 0x02	; 2
    43ce:	ed 91       	ld	r30, X+
    43d0:	fc 91       	ld	r31, X
    43d2:	13 97       	sbiw	r26, 0x03	; 3
    43d4:	82 e0       	ldi	r24, 0x02	; 2
    43d6:	85 83       	std	Z+5, r24	; 0x05
    43d8:	86 2f       	mov	r24, r22
    43da:	8a 95       	dec	r24
    43dc:	f1 f7       	brne	.-4      	; 0x43da <_ZN10I2C_Master14ForceStartStopEv+0xea>
    _delay_us(3);
    _twiPort->OUTSET = 0x1; // Set SDA High - Stop
    43de:	12 96       	adiw	r26, 0x02	; 2
    43e0:	ed 91       	ld	r30, X+
    43e2:	fc 91       	ld	r31, X
    43e4:	13 97       	sbiw	r26, 0x03	; 3
    43e6:	81 e0       	ldi	r24, 0x01	; 1
    43e8:	85 83       	std	Z+5, r24	; 0x05
    43ea:	95 e1       	ldi	r25, 0x15	; 21
    43ec:	9a 95       	dec	r25
    43ee:	f1 f7       	brne	.-4      	; 0x43ec <_ZN10I2C_Master14ForceStartStopEv+0xfc>
    _delay_us(2);
    
    // Restore the Master to on.
    _twi->MASTER.CTRLA = oldState;
    43f0:	ed 91       	ld	r30, X+
    43f2:	fc 91       	ld	r31, X
    43f4:	11 97       	sbiw	r26, 0x01	; 1
    43f6:	41 83       	std	Z+1, r20	; 0x01
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    43f8:	ed 91       	ld	r30, X+
    43fa:	fc 91       	ld	r31, X
    43fc:	84 83       	std	Z+4, r24	; 0x04
    43fe:	80 e0       	ldi	r24, 0x00	; 0
    4400:	08 95       	ret
    return eNone;
    4402:	8a ef       	ldi	r24, 0xFA	; 250
}
    4404:	08 95       	ret
    while (waitTimeout && !IsIdle()) {
        _delay_us(1);
        --waitTimeout;
    }
    
    if (!waitTimeout) {
    4406:	23 2b       	or	r18, r19
    4408:	09 f0       	breq	.+2      	; 0x440c <_ZN10I2C_Master14ForceStartStopEv+0x11c>
    440a:	86 cf       	rjmp	.-244    	; 0x4318 <_ZN10I2C_Master14ForceStartStopEv+0x28>
    440c:	fa cf       	rjmp	.-12     	; 0x4402 <_ZN10I2C_Master14ForceStartStopEv+0x112>

0000440e <_ZN10I2C_Master9WigglePinEhhh>:
    _twi->MASTER.CTRLA = oldState;
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    return eNone;
}

I2C_Master::ErrorType I2C_Master::WigglePin(uint8_t cnt, uint8_t pinSel, uint8_t otherState)
    440e:	1f 93       	push	r17
    4410:	cf 93       	push	r28
    4412:	df 93       	push	r29
    4414:	dc 01       	movw	r26, r24
    4416:	cd 91       	ld	r28, X+
    4418:	dc 91       	ld	r29, X
    441a:	11 97       	sbiw	r26, 0x01	; 1
    441c:	e8 ee       	ldi	r30, 0xE8	; 232
    441e:	f3 e0       	ldi	r31, 0x03	; 3
    4420:	9a e0       	ldi	r25, 0x0A	; 10
    4422:	8c 81       	ldd	r24, Y+4	; 0x04
{
    // Wait for master to be idle.
    uint16_t waitTimeout = 1000;
    while (waitTimeout && !IsIdle()) {
    4424:	83 70       	andi	r24, 0x03	; 3
    4426:	81 30       	cpi	r24, 0x01	; 1
    4428:	09 f4       	brne	.+2      	; 0x442c <_ZN10I2C_Master9WigglePinEhhh+0x1e>
    442a:	73 c0       	rjmp	.+230    	; 0x4512 <_ZN10I2C_Master9WigglePinEhhh+0x104>
    442c:	89 2f       	mov	r24, r25
    442e:	8a 95       	dec	r24
    4430:	f1 f7       	brne	.-4      	; 0x442e <_ZN10I2C_Master9WigglePinEhhh+0x20>
        _delay_us(1);
        --waitTimeout;
    4432:	31 97       	sbiw	r30, 0x01	; 1

I2C_Master::ErrorType I2C_Master::WigglePin(uint8_t cnt, uint8_t pinSel, uint8_t otherState)
{
    // Wait for master to be idle.
    uint16_t waitTimeout = 1000;
    while (waitTimeout && !IsIdle()) {
    4434:	09 f4       	brne	.+2      	; 0x4438 <_ZN10I2C_Master9WigglePinEhhh+0x2a>
    4436:	68 c0       	rjmp	.+208    	; 0x4508 <_ZN10I2C_Master9WigglePinEhhh+0xfa>
    4438:	f4 cf       	rjmp	.-24     	; 0x4422 <_ZN10I2C_Master9WigglePinEhhh+0x14>
    
    if (!waitTimeout) {
        return eTimeout; // Timeout.
    }
    
    uint8_t oldState = _twi->MASTER.CTRLA; 
    443a:	59 81       	ldd	r21, Y+1	; 0x01
    _twi->MASTER.CTRLA = 0; // Turn off interrupts and disable master.
    443c:	19 82       	std	Y+1, r1	; 0x01
    
    _twiPort->OUTSET = 0x3; // Set SCL and SDA High
    443e:	12 96       	adiw	r26, 0x02	; 2
    4440:	ed 91       	ld	r30, X+
    4442:	fc 91       	ld	r31, X
    4444:	13 97       	sbiw	r26, 0x03	; 3
    4446:	83 e0       	ldi	r24, 0x03	; 3
    4448:	85 83       	std	Z+5, r24	; 0x05
    444a:	85 e3       	ldi	r24, 0x35	; 53
    444c:	8a 95       	dec	r24
    444e:	f1 f7       	brne	.-4      	; 0x444c <_ZN10I2C_Master9WigglePinEhhh+0x3e>
    _delay_us(5);
    
    if ((_twiPort->IN & 0x1) == 0) {
    4450:	12 96       	adiw	r26, 0x02	; 2
    4452:	ed 91       	ld	r30, X+
    4454:	fc 91       	ld	r31, X
    4456:	13 97       	sbiw	r26, 0x03	; 3
    4458:	80 85       	ldd	r24, Z+8	; 0x08
    445a:	80 fd       	sbrc	r24, 0
    445c:	0a c0       	rjmp	.+20     	; 0x4472 <_ZN10I2C_Master9WigglePinEhhh+0x64>
        // SDA Line Hung low!
        _twi->MASTER.CTRLA = oldState;
    445e:	ed 91       	ld	r30, X+
    4460:	fc 91       	ld	r31, X
    4462:	11 97       	sbiw	r26, 0x01	; 1
    4464:	51 83       	std	Z+1, r21	; 0x01
        _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4466:	ed 91       	ld	r30, X+
    4468:	fc 91       	ld	r31, X
    446a:	81 e0       	ldi	r24, 0x01	; 1
    446c:	84 83       	std	Z+4, r24	; 0x04
    446e:	89 ef       	ldi	r24, 0xF9	; 249
    4470:	4c c0       	rjmp	.+152    	; 0x450a <_ZN10I2C_Master9WigglePinEhhh+0xfc>
        return eSDAStuck;
    }
    
    if ((_twiPort->IN & 0x2) == 0) {
    4472:	80 85       	ldd	r24, Z+8	; 0x08
    4474:	81 fd       	sbrc	r24, 1
    4476:	0a c0       	rjmp	.+20     	; 0x448c <_ZN10I2C_Master9WigglePinEhhh+0x7e>
        _twi->MASTER.CTRLA = oldState;
    4478:	ed 91       	ld	r30, X+
    447a:	fc 91       	ld	r31, X
    447c:	11 97       	sbiw	r26, 0x01	; 1
    447e:	51 83       	std	Z+1, r21	; 0x01
        _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4480:	ed 91       	ld	r30, X+
    4482:	fc 91       	ld	r31, X
    4484:	81 e0       	ldi	r24, 0x01	; 1
    4486:	84 83       	std	Z+4, r24	; 0x04
    4488:	88 ef       	ldi	r24, 0xF8	; 248
    448a:	3f c0       	rjmp	.+126    	; 0x450a <_ZN10I2C_Master9WigglePinEhhh+0xfc>
        return eSCLStuck;
    }
    
    // Mask for the pin to set.
    uint8_t pinA = (pinSel == 1) ? 0x2 : 0x1;
    448c:	41 30       	cpi	r20, 0x01	; 1
    448e:	11 f4       	brne	.+4      	; 0x4494 <_ZN10I2C_Master9WigglePinEhhh+0x86>
    4490:	32 e0       	ldi	r19, 0x02	; 2
    4492:	02 c0       	rjmp	.+4      	; 0x4498 <_ZN10I2C_Master9WigglePinEhhh+0x8a>
    4494:	42 e0       	ldi	r20, 0x02	; 2
    4496:	31 e0       	ldi	r19, 0x01	; 1
    uint8_t pinB = (pinSel == 1) ? 0x1 : 0x2;
    
    if (otherState == 0) {
    4498:	22 23       	and	r18, r18
    449a:	21 f4       	brne	.+8      	; 0x44a4 <_ZN10I2C_Master9WigglePinEhhh+0x96>
        // Force other pin low,
        _twiPort->OUTCLR = pinB;
    449c:	46 83       	std	Z+6, r20	; 0x06
    449e:	85 e1       	ldi	r24, 0x15	; 21
    44a0:	8a 95       	dec	r24
    44a2:	f1 f7       	brne	.-4      	; 0x44a0 <_ZN10I2C_Master9WigglePinEhhh+0x92>
    44a4:	80 e0       	ldi	r24, 0x00	; 0
    44a6:	90 e0       	ldi	r25, 0x00	; 0
        _delay_us(2);
    }
    
    for (int x=0;x<cnt;x++) {
    44a8:	70 e0       	ldi	r23, 0x00	; 0
    44aa:	10 e2       	ldi	r17, 0x20	; 32
    44ac:	0d c0       	rjmp	.+26     	; 0x44c8 <_ZN10I2C_Master9WigglePinEhhh+0xba>
    44ae:	21 2f       	mov	r18, r17
    44b0:	2a 95       	dec	r18
    44b2:	f1 f7       	brne	.-4      	; 0x44b0 <_ZN10I2C_Master9WigglePinEhhh+0xa2>
        _delay_us(3);
        _twiPort->OUTSET = pinA;
    44b4:	35 83       	std	Z+5, r19	; 0x05
    44b6:	21 2f       	mov	r18, r17
    44b8:	2a 95       	dec	r18
    44ba:	f1 f7       	brne	.-4      	; 0x44b8 <_ZN10I2C_Master9WigglePinEhhh+0xaa>
        _delay_us(3);
        _twiPort->OUTCLR = pinA;
    44bc:	12 96       	adiw	r26, 0x02	; 2
    44be:	ed 91       	ld	r30, X+
    44c0:	fc 91       	ld	r31, X
    44c2:	13 97       	sbiw	r26, 0x03	; 3
    44c4:	36 83       	std	Z+6, r19	; 0x06
        // Force other pin low,
        _twiPort->OUTCLR = pinB;
        _delay_us(2);
    }
    
    for (int x=0;x<cnt;x++) {
    44c6:	01 96       	adiw	r24, 0x01	; 1
    44c8:	12 96       	adiw	r26, 0x02	; 2
    44ca:	ed 91       	ld	r30, X+
    44cc:	fc 91       	ld	r31, X
    44ce:	13 97       	sbiw	r26, 0x03	; 3
    44d0:	86 17       	cp	r24, r22
    44d2:	97 07       	cpc	r25, r23
    44d4:	64 f3       	brlt	.-40     	; 0x44ae <_ZN10I2C_Master9WigglePinEhhh+0xa0>
    44d6:	80 e2       	ldi	r24, 0x20	; 32
    44d8:	98 2f       	mov	r25, r24
    44da:	9a 95       	dec	r25
    44dc:	f1 f7       	brne	.-4      	; 0x44da <_ZN10I2C_Master9WigglePinEhhh+0xcc>
        _delay_us(3);
        _twiPort->OUTCLR = pinA;
    }
    
    _delay_us(3);
    _twiPort->OUTSET = pinA;
    44de:	35 83       	std	Z+5, r19	; 0x05
    44e0:	8a 95       	dec	r24
    44e2:	f1 f7       	brne	.-4      	; 0x44e0 <_ZN10I2C_Master9WigglePinEhhh+0xd2>
    _delay_us(3);
    _twiPort->OUTSET = pinB;
    44e4:	12 96       	adiw	r26, 0x02	; 2
    44e6:	ed 91       	ld	r30, X+
    44e8:	fc 91       	ld	r31, X
    44ea:	13 97       	sbiw	r26, 0x03	; 3
    44ec:	45 83       	std	Z+5, r20	; 0x05
    44ee:	85 e1       	ldi	r24, 0x15	; 21
    44f0:	8a 95       	dec	r24
    44f2:	f1 f7       	brne	.-4      	; 0x44f0 <_ZN10I2C_Master9WigglePinEhhh+0xe2>
    _delay_us(2);
    
    // Restore the Master to on.
    _twi->MASTER.CTRLA = oldState;
    44f4:	ed 91       	ld	r30, X+
    44f6:	fc 91       	ld	r31, X
    44f8:	11 97       	sbiw	r26, 0x01	; 1
    44fa:	51 83       	std	Z+1, r21	; 0x01
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    44fc:	ed 91       	ld	r30, X+
    44fe:	fc 91       	ld	r31, X
    4500:	81 e0       	ldi	r24, 0x01	; 1
    4502:	84 83       	std	Z+4, r24	; 0x04
    4504:	80 e0       	ldi	r24, 0x00	; 0
    4506:	01 c0       	rjmp	.+2      	; 0x450a <_ZN10I2C_Master9WigglePinEhhh+0xfc>
    return eNone;
    4508:	8a ef       	ldi	r24, 0xFA	; 250
}
    450a:	df 91       	pop	r29
    450c:	cf 91       	pop	r28
    450e:	1f 91       	pop	r17
    4510:	08 95       	ret
    while (waitTimeout && !IsIdle()) {
        _delay_us(1);
        --waitTimeout;
    }
    
    if (!waitTimeout) {
    4512:	ef 2b       	or	r30, r31
    4514:	09 f0       	breq	.+2      	; 0x4518 <_ZN10I2C_Master9WigglePinEhhh+0x10a>
    4516:	91 cf       	rjmp	.-222    	; 0x443a <_ZN10I2C_Master9WigglePinEhhh+0x2c>
    4518:	f7 cf       	rjmp	.-18     	; 0x4508 <_ZN10I2C_Master9WigglePinEhhh+0xfa>

0000451a <_ZN10I2C_Master12WriteHandlerEv>:
 the transaction. If the slave did acknowledge, then
 if there are more byts to write, send the next byte,
 otherwise, if there are bytes to read, start the read
 process with another ID write.
 **********************************/
void I2C_Master::WriteHandler()
    451a:	cf 93       	push	r28
    451c:	df 93       	push	r29
    451e:	dc 01       	movw	r26, r24
{
    if (_twi->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
    4520:	cd 91       	ld	r28, X+
    4522:	dc 91       	ld	r29, X
    4524:	11 97       	sbiw	r26, 0x01	; 1
    4526:	8c 81       	ldd	r24, Y+4	; 0x04
    4528:	84 ff       	sbrs	r24, 4
    452a:	16 c0       	rjmp	.+44     	; 0x4558 <_ZN10I2C_Master12WriteHandlerEv+0x3e>
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    452c:	83 e0       	ldi	r24, 0x03	; 3
    452e:	8b 83       	std	Y+3, r24	; 0x03
        _Result     = rNack;
    4530:	84 e0       	ldi	r24, 0x04	; 4
    4532:	16 96       	adiw	r26, 0x06	; 6
    4534:	8c 93       	st	X, r24
    4536:	16 97       	sbiw	r26, 0x06	; 6
        _State      = sIdle;
    4538:	15 96       	adiw	r26, 0x05	; 5
    453a:	1c 92       	st	X, r1
    453c:	15 97       	sbiw	r26, 0x05	; 5
        // This might be the end of the write, and no read is required
        // in which case the Slave may Nack. In this case the Nack is
        // okay.
        if (_pNotifyClient) {
    453e:	19 96       	adiw	r26, 0x09	; 9
    4540:	0d 90       	ld	r0, X+
    4542:	bc 91       	ld	r27, X
    4544:	a0 2d       	mov	r26, r0
    4546:	10 97       	sbiw	r26, 0x00	; 0
    4548:	f1 f1       	breq	.+124    	; 0x45c6 <_ZN10I2C_Master12WriteHandlerEv+0xac>
            _pNotifyClient->I2CNack();
    454a:	ed 91       	ld	r30, X+
    454c:	fc 91       	ld	r31, X
    454e:	11 97       	sbiw	r26, 0x01	; 1
    4550:	00 84       	ldd	r0, Z+8	; 0x08
    4552:	f1 85       	ldd	r31, Z+9	; 0x09
    4554:	e0 2d       	mov	r30, r0
    4556:	35 c0       	rjmp	.+106    	; 0x45c2 <_ZN10I2C_Master12WriteHandlerEv+0xa8>
        }
    } else if (_nBytesWritten < _nWriteBytes) {
    4558:	1c 96       	adiw	r26, 0x0c	; 12
    455a:	9c 91       	ld	r25, X
    455c:	1c 97       	sbiw	r26, 0x0c	; 12
    455e:	1d 96       	adiw	r26, 0x0d	; 13
    4560:	8c 91       	ld	r24, X
    4562:	1d 97       	sbiw	r26, 0x0d	; 13
    4564:	98 17       	cp	r25, r24
    4566:	60 f4       	brcc	.+24     	; 0x4580 <_ZN10I2C_Master12WriteHandlerEv+0x66>
        // More bytes to write
        uint8_t data = _WriteData[_nBytesWritten];
    4568:	50 96       	adiw	r26, 0x10	; 16
    456a:	ed 91       	ld	r30, X+
    456c:	fc 91       	ld	r31, X
    456e:	51 97       	sbiw	r26, 0x11	; 17
    4570:	e9 0f       	add	r30, r25
    4572:	f1 1d       	adc	r31, r1
    4574:	80 81       	ld	r24, Z
        ++_nBytesWritten;
    4576:	9f 5f       	subi	r25, 0xFF	; 255
    4578:	1c 96       	adiw	r26, 0x0c	; 12
    457a:	9c 93       	st	X, r25
        _twi->MASTER.DATA = data;
    457c:	8f 83       	std	Y+7, r24	; 0x07
    457e:	23 c0       	rjmp	.+70     	; 0x45c6 <_ZN10I2C_Master12WriteHandlerEv+0xac>
        //if (pdbgserial) pdbgserial->println("I_WIF - Write");
    } else if (_nBytesRead < _nReadBytes) {
    4580:	1f 96       	adiw	r26, 0x0f	; 15
    4582:	9c 91       	ld	r25, X
    4584:	1f 97       	sbiw	r26, 0x0f	; 15
    4586:	1e 96       	adiw	r26, 0x0e	; 14
    4588:	8c 91       	ld	r24, X
    458a:	1e 97       	sbiw	r26, 0x0e	; 14
    458c:	98 17       	cp	r25, r24
    458e:	28 f4       	brcc	.+10     	; 0x459a <_ZN10I2C_Master12WriteHandlerEv+0x80>
        // This will be a transition from a write to a
        // read, so we re-send the ID with the READ bit
        // set.
        _twi->MASTER.ADDR = _DeviceID | 0x1;
    4590:	1b 96       	adiw	r26, 0x0b	; 11
    4592:	8c 91       	ld	r24, X
    4594:	81 60       	ori	r24, 0x01	; 1
    4596:	8e 83       	std	Y+6, r24	; 0x06
    4598:	16 c0       	rjmp	.+44     	; 0x45c6 <_ZN10I2C_Master12WriteHandlerEv+0xac>
        //if (pdbgserial) pdbgserial->println("I_WIF - Read");
    } else {
        // The transaction is done.. close it.
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    459a:	83 e0       	ldi	r24, 0x03	; 3
    459c:	8b 83       	std	Y+3, r24	; 0x03
        _Result = rOk;
    459e:	16 96       	adiw	r26, 0x06	; 6
    45a0:	1c 92       	st	X, r1
    45a2:	16 97       	sbiw	r26, 0x06	; 6
        _State = sIdle;
    45a4:	15 96       	adiw	r26, 0x05	; 5
    45a6:	1c 92       	st	X, r1
    45a8:	15 97       	sbiw	r26, 0x05	; 5
        //if (pdbgserial) pdbgserial->println("I_WIF - Done");
        if (_pNotifyClient) {
    45aa:	19 96       	adiw	r26, 0x09	; 9
    45ac:	0d 90       	ld	r0, X+
    45ae:	bc 91       	ld	r27, X
    45b0:	a0 2d       	mov	r26, r0
    45b2:	10 97       	sbiw	r26, 0x00	; 0
    45b4:	41 f0       	breq	.+16     	; 0x45c6 <_ZN10I2C_Master12WriteHandlerEv+0xac>
            _pNotifyClient->I2CWriteDone();
    45b6:	ed 91       	ld	r30, X+
    45b8:	fc 91       	ld	r31, X
    45ba:	11 97       	sbiw	r26, 0x01	; 1
    45bc:	01 90       	ld	r0, Z+
    45be:	f0 81       	ld	r31, Z
    45c0:	e0 2d       	mov	r30, r0
    45c2:	cd 01       	movw	r24, r26
    45c4:	19 95       	eicall
    }

    // Not sure if I need to clear this or not..
    // No - all of the above cases will clear it.
    //_twi->MASTER.STATUS |= TWI_MASTER_WIF_bm;
}
    45c6:	df 91       	pop	r29
    45c8:	cf 91       	pop	r28
    45ca:	08 95       	ret

000045cc <_ZN10I2C_Master11ReadHandlerEv>:

void I2C_Master::ReadHandler()
    45cc:	dc 01       	movw	r26, r24
    associated with a particular I2C hardware resource.
    The connection is set in the constructore for I2C Master.
    Anyway, this allows each class instance to handle it's
    own interupts.
    */
    if (_nBytesRead < _rdBufferLen) {
    45ce:	1f 96       	adiw	r26, 0x0f	; 15
    45d0:	9c 91       	ld	r25, X
    45d2:	1f 97       	sbiw	r26, 0x0f	; 15
    45d4:	55 96       	adiw	r26, 0x15	; 21
    45d6:	8c 91       	ld	r24, X
    45d8:	55 97       	sbiw	r26, 0x15	; 21
    45da:	ed 91       	ld	r30, X+
    45dc:	fc 91       	ld	r31, X
    45de:	11 97       	sbiw	r26, 0x01	; 1
    45e0:	98 17       	cp	r25, r24
    45e2:	88 f5       	brcc	.+98     	; 0x4646 <_ZN10I2C_Master11ReadHandlerEv+0x7a>
        uint8_t data = _twi->MASTER.DATA;
    45e4:	87 81       	ldd	r24, Z+7	; 0x07
        _ReadData[_nBytesRead] = data;
    45e6:	53 96       	adiw	r26, 0x13	; 19
    45e8:	ed 91       	ld	r30, X+
    45ea:	fc 91       	ld	r31, X
    45ec:	54 97       	sbiw	r26, 0x14	; 20
    45ee:	e9 0f       	add	r30, r25
    45f0:	f1 1d       	adc	r31, r1
    45f2:	80 83       	st	Z, r24
        ++_nBytesRead;
    45f4:	1f 96       	adiw	r26, 0x0f	; 15
    45f6:	8c 91       	ld	r24, X
    45f8:	1f 97       	sbiw	r26, 0x0f	; 15
    45fa:	8f 5f       	subi	r24, 0xFF	; 255
    45fc:	1f 96       	adiw	r26, 0x0f	; 15
    45fe:	8c 93       	st	X, r24
    4600:	1f 97       	sbiw	r26, 0x0f	; 15

        if (_nBytesRead < _nReadBytes) {
    4602:	1e 96       	adiw	r26, 0x0e	; 14
    4604:	9c 91       	ld	r25, X
    4606:	1e 97       	sbiw	r26, 0x0e	; 14
    4608:	ed 91       	ld	r30, X+
    460a:	fc 91       	ld	r31, X
    460c:	11 97       	sbiw	r26, 0x01	; 1
    460e:	89 17       	cp	r24, r25
    4610:	18 f4       	brcc	.+6      	; 0x4618 <_ZN10I2C_Master11ReadHandlerEv+0x4c>
            _twi->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    4612:	82 e0       	ldi	r24, 0x02	; 2
    4614:	83 83       	std	Z+3, r24	; 0x03
    4616:	08 95       	ret
        } else {
            // No more bytes to read..  Nack and stop
            _twi->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
                                 TWI_MASTER_CMD_STOP_gc;
    4618:	87 e0       	ldi	r24, 0x07	; 7
    461a:	83 83       	std	Z+3, r24	; 0x03
    
            _Result     = rOk;
    461c:	16 96       	adiw	r26, 0x06	; 6
    461e:	1c 92       	st	X, r1
    4620:	16 97       	sbiw	r26, 0x06	; 6
            _State      = sIdle;
    4622:	15 96       	adiw	r26, 0x05	; 5
    4624:	1c 92       	st	X, r1
    4626:	15 97       	sbiw	r26, 0x05	; 5
            if (_pNotifyClient) {
    4628:	19 96       	adiw	r26, 0x09	; 9
    462a:	0d 90       	ld	r0, X+
    462c:	bc 91       	ld	r27, X
    462e:	a0 2d       	mov	r26, r0
    4630:	10 97       	sbiw	r26, 0x00	; 0
    4632:	01 f1       	breq	.+64     	; 0x4674 <_ZN10I2C_Master11ReadHandlerEv+0xa8>
                _pNotifyClient->I2CReadDone();
    4634:	ed 91       	ld	r30, X+
    4636:	fc 91       	ld	r31, X
    4638:	11 97       	sbiw	r26, 0x01	; 1
    463a:	02 80       	ldd	r0, Z+2	; 0x02
    463c:	f3 81       	ldd	r31, Z+3	; 0x03
    463e:	e0 2d       	mov	r30, r0
    4640:	cd 01       	movw	r24, r26
    4642:	19 95       	eicall
    4644:	08 95       	ret
            }
        }
    } else {
        // Buffer Overrun. Stop and quit with the bytes
        _twi->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
                            TWI_MASTER_CMD_STOP_gc;
    4646:	87 e0       	ldi	r24, 0x07	; 7
    4648:	83 83       	std	Z+3, r24	; 0x03
        _State  = sIdle;
    464a:	15 96       	adiw	r26, 0x05	; 5
    464c:	1c 92       	st	X, r1
    464e:	15 97       	sbiw	r26, 0x05	; 5
        _Result = rBufferOverrun;
    4650:	85 e0       	ldi	r24, 0x05	; 5
    4652:	16 96       	adiw	r26, 0x06	; 6
    4654:	8c 93       	st	X, r24
    4656:	16 97       	sbiw	r26, 0x06	; 6

        if (_pNotifyClient) {
    4658:	19 96       	adiw	r26, 0x09	; 9
    465a:	0d 90       	ld	r0, X+
    465c:	bc 91       	ld	r27, X
    465e:	a0 2d       	mov	r26, r0
    4660:	10 97       	sbiw	r26, 0x00	; 0
    4662:	41 f0       	breq	.+16     	; 0x4674 <_ZN10I2C_Master11ReadHandlerEv+0xa8>
            _pNotifyClient->I2CReadDone();
    4664:	ed 91       	ld	r30, X+
    4666:	fc 91       	ld	r31, X
    4668:	11 97       	sbiw	r26, 0x01	; 1
    466a:	02 80       	ldd	r0, Z+2	; 0x02
    466c:	f3 81       	ldd	r31, Z+3	; 0x03
    466e:	e0 2d       	mov	r30, r0
    4670:	cd 01       	movw	r24, r26
    4672:	19 95       	eicall
    4674:	08 95       	ret

00004676 <_ZN10I2C_Master10ArbHandlerEv>:
        }
    }

}

void I2C_Master::ArbHandler()
    4676:	fc 01       	movw	r30, r24
{
    _twi->MASTER.STATUS |= TWI_MASTER_ARBLOST_bm;
    4678:	a0 81       	ld	r26, Z
    467a:	b1 81       	ldd	r27, Z+1	; 0x01
    467c:	14 96       	adiw	r26, 0x04	; 4
    467e:	8c 91       	ld	r24, X
    4680:	14 97       	sbiw	r26, 0x04	; 4
    4682:	88 60       	ori	r24, 0x08	; 8
    4684:	14 96       	adiw	r26, 0x04	; 4
    4686:	8c 93       	st	X, r24
    _State  = sIdle;
    4688:	15 82       	std	Z+5, r1	; 0x05
    _Result = rArbLost;
    468a:	82 e0       	ldi	r24, 0x02	; 2
    468c:	86 83       	std	Z+6, r24	; 0x06
    if (_pNotifyClient) {
    468e:	a1 85       	ldd	r26, Z+9	; 0x09
    4690:	b2 85       	ldd	r27, Z+10	; 0x0a
    4692:	10 97       	sbiw	r26, 0x00	; 0
    4694:	41 f0       	breq	.+16     	; 0x46a6 <_ZN10I2C_Master10ArbHandlerEv+0x30>
        _pNotifyClient->I2CArbLost();
    4696:	ed 91       	ld	r30, X+
    4698:	fc 91       	ld	r31, X
    469a:	11 97       	sbiw	r26, 0x01	; 1
    469c:	06 80       	ldd	r0, Z+6	; 0x06
    469e:	f7 81       	ldd	r31, Z+7	; 0x07
    46a0:	e0 2d       	mov	r30, r0
    46a2:	cd 01       	movw	r24, r26
    46a4:	19 95       	eicall
    46a6:	08 95       	ret

000046a8 <_ZN10I2C_Master12ErrorHandlerEv>:
    }
    return;
}

void I2C_Master::ErrorHandler()
    46a8:	fc 01       	movw	r30, r24
{
    // Clear the error flag.
    _twi->MASTER.STATUS |= TWI_MASTER_BUSERR_bm;
    46aa:	a0 81       	ld	r26, Z
    46ac:	b1 81       	ldd	r27, Z+1	; 0x01
    46ae:	14 96       	adiw	r26, 0x04	; 4
    46b0:	8c 91       	ld	r24, X
    46b2:	14 97       	sbiw	r26, 0x04	; 4
    46b4:	84 60       	ori	r24, 0x04	; 4
    46b6:	14 96       	adiw	r26, 0x04	; 4
    46b8:	8c 93       	st	X, r24
    
    // Stop with a NACK. Not sure ifa NACK is needed here, but that
    // is the best solution if it happens to be needed.
    _twi->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
                                 TWI_MASTER_CMD_STOP_gc;
    46ba:	a0 81       	ld	r26, Z
    46bc:	b1 81       	ldd	r27, Z+1	; 0x01
    46be:	87 e0       	ldi	r24, 0x07	; 7
    46c0:	13 96       	adiw	r26, 0x03	; 3
    46c2:	8c 93       	st	X, r24
    _State  = sIdle;
    46c4:	15 82       	std	Z+5, r1	; 0x05
    _Result = rBussErr;
    46c6:	83 e0       	ldi	r24, 0x03	; 3
    46c8:	86 83       	std	Z+6, r24	; 0x06
    if (_pNotifyClient) {
    46ca:	a1 85       	ldd	r26, Z+9	; 0x09
    46cc:	b2 85       	ldd	r27, Z+10	; 0x0a
    46ce:	10 97       	sbiw	r26, 0x00	; 0
    46d0:	41 f0       	breq	.+16     	; 0x46e2 <_ZN10I2C_Master12ErrorHandlerEv+0x3a>
        _pNotifyClient->I2CBusError();
    46d2:	ed 91       	ld	r30, X+
    46d4:	fc 91       	ld	r31, X
    46d6:	11 97       	sbiw	r26, 0x01	; 1
    46d8:	04 80       	ldd	r0, Z+4	; 0x04
    46da:	f5 81       	ldd	r31, Z+5	; 0x05
    46dc:	e0 2d       	mov	r30, r0
    46de:	cd 01       	movw	r24, r26
    46e0:	19 95       	eicall
    46e2:	08 95       	ret

000046e4 <_ZN10I2C_Master10master_intEv>:
    _twi->MASTER.CTRLA = oldState;
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    return eNone;
}

void I2C_Master::master_int()
    46e4:	0f 93       	push	r16
    46e6:	1f 93       	push	r17
    46e8:	cf 93       	push	r28
    46ea:	df 93       	push	r29
    46ec:	ec 01       	movw	r28, r24
{
    //if (pdbgserial) pdbgserial->println("Master Interrupt.");
    uint8_t currentStatus = _twi->MASTER.STATUS;
    46ee:	e8 81       	ld	r30, Y
    46f0:	f9 81       	ldd	r31, Y+1	; 0x01
    46f2:	04 81       	ldd	r16, Z+4	; 0x04

    if (currentStatus & TWI_MASTER_BUSERR_bm) {
    46f4:	10 2f       	mov	r17, r16
    46f6:	02 ff       	sbrs	r16, 2
    46f8:	0c c0       	rjmp	.+24     	; 0x4712 <_ZN10I2C_Master10master_intEv+0x2e>
        // I have found that on some occasions the 
        // slave releases the NACK and the SDA line goes high
        // too quickly, before SCL drops. I do not know why this
        // is allowed to occur.. but I'm going to try and keep going
        // if possible.
        if (currentStatus & TWI_MASTER_WIF_bm) {
    46fa:	06 ff       	sbrs	r16, 6
    46fc:	08 c0       	rjmp	.+16     	; 0x470e <_ZN10I2C_Master10master_intEv+0x2a>
            // Clear the Bus error but retain the Bus state and
            // RXAck bits
            _twi->MASTER.STATUS = 
                TWI_MASTER_BUSERR_bm 
                | (currentStatus & (TWI_MASTER_RXACK_bm | 0x3));
    46fe:	80 2f       	mov	r24, r16
    4700:	83 71       	andi	r24, 0x13	; 19
    4702:	84 60       	ori	r24, 0x04	; 4
    4704:	84 83       	std	Z+4, r24	; 0x04
            WriteHandler();
    4706:	ce 01       	movw	r24, r28
    4708:	0e 94 8d 22 	call	0x451a	; 0x451a <_ZN10I2C_Master12WriteHandlerEv>
    470c:	02 c0       	rjmp	.+4      	; 0x4712 <_ZN10I2C_Master10master_intEv+0x2e>
        } else {
            ErrorHandler();
    470e:	0e 94 54 23 	call	0x46a8	; 0x46a8 <_ZN10I2C_Master12ErrorHandlerEv>
        }
    }

    if (currentStatus & TWI_MASTER_ARBLOST_bm) {
    4712:	13 ff       	sbrs	r17, 3
    4714:	03 c0       	rjmp	.+6      	; 0x471c <_ZN10I2C_Master10master_intEv+0x38>
        ArbHandler();
    4716:	ce 01       	movw	r24, r28
    4718:	0e 94 3b 23 	call	0x4676	; 0x4676 <_ZN10I2C_Master10ArbHandlerEv>
    }

    if (currentStatus & TWI_MASTER_WIF_bm) {
    471c:	16 ff       	sbrs	r17, 6
    471e:	03 c0       	rjmp	.+6      	; 0x4726 <_ZN10I2C_Master10master_intEv+0x42>
        WriteHandler();
    4720:	ce 01       	movw	r24, r28
    4722:	0e 94 8d 22 	call	0x451a	; 0x451a <_ZN10I2C_Master12WriteHandlerEv>
    }

    if (currentStatus & TWI_MASTER_RIF_bm) {
    4726:	07 ff       	sbrs	r16, 7
    4728:	03 c0       	rjmp	.+6      	; 0x4730 <_ZN10I2C_Master10master_intEv+0x4c>
        ReadHandler();
    472a:	ce 01       	movw	r24, r28
    472c:	0e 94 e6 22 	call	0x45cc	; 0x45cc <_ZN10I2C_Master11ReadHandlerEv>
    }
}
    4730:	df 91       	pop	r29
    4732:	cf 91       	pop	r28
    4734:	1f 91       	pop	r17
    4736:	0f 91       	pop	r16
    4738:	08 95       	ret

0000473a <__vector_107>:

I2C_ISR_DEF(TWIC);
I2C_ISR_DEF(TWIE);
#if defined(__AVR_ATxmega128A1__)
I2C_ISR_DEF(TWID);
I2C_ISR_DEF(TWIF);
    473a:	1f 92       	push	r1
    473c:	0f 92       	push	r0
    473e:	0f b6       	in	r0, 0x3f	; 63
    4740:	0f 92       	push	r0
    4742:	08 b6       	in	r0, 0x38	; 56
    4744:	0f 92       	push	r0
    4746:	09 b6       	in	r0, 0x39	; 57
    4748:	0f 92       	push	r0
    474a:	0b b6       	in	r0, 0x3b	; 59
    474c:	0f 92       	push	r0
    474e:	11 24       	eor	r1, r1
    4750:	18 be       	out	0x38, r1	; 56
    4752:	19 be       	out	0x39, r1	; 57
    4754:	1b be       	out	0x3b, r1	; 59
    4756:	2f 93       	push	r18
    4758:	3f 93       	push	r19
    475a:	4f 93       	push	r20
    475c:	5f 93       	push	r21
    475e:	6f 93       	push	r22
    4760:	7f 93       	push	r23
    4762:	8f 93       	push	r24
    4764:	9f 93       	push	r25
    4766:	af 93       	push	r26
    4768:	bf 93       	push	r27
    476a:	ef 93       	push	r30
    476c:	ff 93       	push	r31
    476e:	80 91 c7 2b 	lds	r24, 0x2BC7
    4772:	90 91 c8 2b 	lds	r25, 0x2BC8
    4776:	00 97       	sbiw	r24, 0x00	; 0
    4778:	11 f0       	breq	.+4      	; 0x477e <__vector_107+0x44>
    477a:	0e 94 72 23 	call	0x46e4	; 0x46e4 <_ZN10I2C_Master10master_intEv>
    477e:	ff 91       	pop	r31
    4780:	ef 91       	pop	r30
    4782:	bf 91       	pop	r27
    4784:	af 91       	pop	r26
    4786:	9f 91       	pop	r25
    4788:	8f 91       	pop	r24
    478a:	7f 91       	pop	r23
    478c:	6f 91       	pop	r22
    478e:	5f 91       	pop	r21
    4790:	4f 91       	pop	r20
    4792:	3f 91       	pop	r19
    4794:	2f 91       	pop	r18
    4796:	0f 90       	pop	r0
    4798:	0b be       	out	0x3b, r0	; 59
    479a:	0f 90       	pop	r0
    479c:	09 be       	out	0x39, r0	; 57
    479e:	0f 90       	pop	r0
    47a0:	08 be       	out	0x38, r0	; 56
    47a2:	0f 90       	pop	r0
    47a4:	0f be       	out	0x3f, r0	; 63
    47a6:	0f 90       	pop	r0
    47a8:	1f 90       	pop	r1
    47aa:	18 95       	reti

000047ac <__vector_76>:
}

I2C_ISR_DEF(TWIC);
I2C_ISR_DEF(TWIE);
#if defined(__AVR_ATxmega128A1__)
I2C_ISR_DEF(TWID);
    47ac:	1f 92       	push	r1
    47ae:	0f 92       	push	r0
    47b0:	0f b6       	in	r0, 0x3f	; 63
    47b2:	0f 92       	push	r0
    47b4:	08 b6       	in	r0, 0x38	; 56
    47b6:	0f 92       	push	r0
    47b8:	09 b6       	in	r0, 0x39	; 57
    47ba:	0f 92       	push	r0
    47bc:	0b b6       	in	r0, 0x3b	; 59
    47be:	0f 92       	push	r0
    47c0:	11 24       	eor	r1, r1
    47c2:	18 be       	out	0x38, r1	; 56
    47c4:	19 be       	out	0x39, r1	; 57
    47c6:	1b be       	out	0x3b, r1	; 59
    47c8:	2f 93       	push	r18
    47ca:	3f 93       	push	r19
    47cc:	4f 93       	push	r20
    47ce:	5f 93       	push	r21
    47d0:	6f 93       	push	r22
    47d2:	7f 93       	push	r23
    47d4:	8f 93       	push	r24
    47d6:	9f 93       	push	r25
    47d8:	af 93       	push	r26
    47da:	bf 93       	push	r27
    47dc:	ef 93       	push	r30
    47de:	ff 93       	push	r31
    47e0:	80 91 c5 2b 	lds	r24, 0x2BC5
    47e4:	90 91 c6 2b 	lds	r25, 0x2BC6
    47e8:	00 97       	sbiw	r24, 0x00	; 0
    47ea:	11 f0       	breq	.+4      	; 0x47f0 <__vector_76+0x44>
    47ec:	0e 94 72 23 	call	0x46e4	; 0x46e4 <_ZN10I2C_Master10master_intEv>
    47f0:	ff 91       	pop	r31
    47f2:	ef 91       	pop	r30
    47f4:	bf 91       	pop	r27
    47f6:	af 91       	pop	r26
    47f8:	9f 91       	pop	r25
    47fa:	8f 91       	pop	r24
    47fc:	7f 91       	pop	r23
    47fe:	6f 91       	pop	r22
    4800:	5f 91       	pop	r21
    4802:	4f 91       	pop	r20
    4804:	3f 91       	pop	r19
    4806:	2f 91       	pop	r18
    4808:	0f 90       	pop	r0
    480a:	0b be       	out	0x3b, r0	; 59
    480c:	0f 90       	pop	r0
    480e:	09 be       	out	0x39, r0	; 57
    4810:	0f 90       	pop	r0
    4812:	08 be       	out	0x38, r0	; 56
    4814:	0f 90       	pop	r0
    4816:	0f be       	out	0x3f, r0	; 63
    4818:	0f 90       	pop	r0
    481a:	1f 90       	pop	r1
    481c:	18 95       	reti

0000481e <__vector_46>:
ISR(periph##_TWIS_vect) {\
    if (periph##_master_cp) periph##_master_cp->slave_int();\
}

I2C_ISR_DEF(TWIC);
I2C_ISR_DEF(TWIE);
    481e:	1f 92       	push	r1
    4820:	0f 92       	push	r0
    4822:	0f b6       	in	r0, 0x3f	; 63
    4824:	0f 92       	push	r0
    4826:	08 b6       	in	r0, 0x38	; 56
    4828:	0f 92       	push	r0
    482a:	09 b6       	in	r0, 0x39	; 57
    482c:	0f 92       	push	r0
    482e:	0b b6       	in	r0, 0x3b	; 59
    4830:	0f 92       	push	r0
    4832:	11 24       	eor	r1, r1
    4834:	18 be       	out	0x38, r1	; 56
    4836:	19 be       	out	0x39, r1	; 57
    4838:	1b be       	out	0x3b, r1	; 59
    483a:	2f 93       	push	r18
    483c:	3f 93       	push	r19
    483e:	4f 93       	push	r20
    4840:	5f 93       	push	r21
    4842:	6f 93       	push	r22
    4844:	7f 93       	push	r23
    4846:	8f 93       	push	r24
    4848:	9f 93       	push	r25
    484a:	af 93       	push	r26
    484c:	bf 93       	push	r27
    484e:	ef 93       	push	r30
    4850:	ff 93       	push	r31
    4852:	80 91 c9 2b 	lds	r24, 0x2BC9
    4856:	90 91 ca 2b 	lds	r25, 0x2BCA
    485a:	00 97       	sbiw	r24, 0x00	; 0
    485c:	11 f0       	breq	.+4      	; 0x4862 <__vector_46+0x44>
    485e:	0e 94 72 23 	call	0x46e4	; 0x46e4 <_ZN10I2C_Master10master_intEv>
    4862:	ff 91       	pop	r31
    4864:	ef 91       	pop	r30
    4866:	bf 91       	pop	r27
    4868:	af 91       	pop	r26
    486a:	9f 91       	pop	r25
    486c:	8f 91       	pop	r24
    486e:	7f 91       	pop	r23
    4870:	6f 91       	pop	r22
    4872:	5f 91       	pop	r21
    4874:	4f 91       	pop	r20
    4876:	3f 91       	pop	r19
    4878:	2f 91       	pop	r18
    487a:	0f 90       	pop	r0
    487c:	0b be       	out	0x3b, r0	; 59
    487e:	0f 90       	pop	r0
    4880:	09 be       	out	0x39, r0	; 57
    4882:	0f 90       	pop	r0
    4884:	08 be       	out	0x38, r0	; 56
    4886:	0f 90       	pop	r0
    4888:	0f be       	out	0x3f, r0	; 63
    488a:	0f 90       	pop	r0
    488c:	1f 90       	pop	r1
    488e:	18 95       	reti

00004890 <__vector_13>:
} \
ISR(periph##_TWIS_vect) {\
    if (periph##_master_cp) periph##_master_cp->slave_int();\
}

I2C_ISR_DEF(TWIC);
    4890:	1f 92       	push	r1
    4892:	0f 92       	push	r0
    4894:	0f b6       	in	r0, 0x3f	; 63
    4896:	0f 92       	push	r0
    4898:	08 b6       	in	r0, 0x38	; 56
    489a:	0f 92       	push	r0
    489c:	09 b6       	in	r0, 0x39	; 57
    489e:	0f 92       	push	r0
    48a0:	0b b6       	in	r0, 0x3b	; 59
    48a2:	0f 92       	push	r0
    48a4:	11 24       	eor	r1, r1
    48a6:	18 be       	out	0x38, r1	; 56
    48a8:	19 be       	out	0x39, r1	; 57
    48aa:	1b be       	out	0x3b, r1	; 59
    48ac:	2f 93       	push	r18
    48ae:	3f 93       	push	r19
    48b0:	4f 93       	push	r20
    48b2:	5f 93       	push	r21
    48b4:	6f 93       	push	r22
    48b6:	7f 93       	push	r23
    48b8:	8f 93       	push	r24
    48ba:	9f 93       	push	r25
    48bc:	af 93       	push	r26
    48be:	bf 93       	push	r27
    48c0:	ef 93       	push	r30
    48c2:	ff 93       	push	r31
    48c4:	80 91 c3 2b 	lds	r24, 0x2BC3
    48c8:	90 91 c4 2b 	lds	r25, 0x2BC4
    48cc:	00 97       	sbiw	r24, 0x00	; 0
    48ce:	11 f0       	breq	.+4      	; 0x48d4 <__vector_13+0x44>
    48d0:	0e 94 72 23 	call	0x46e4	; 0x46e4 <_ZN10I2C_Master10master_intEv>
    48d4:	ff 91       	pop	r31
    48d6:	ef 91       	pop	r30
    48d8:	bf 91       	pop	r27
    48da:	af 91       	pop	r26
    48dc:	9f 91       	pop	r25
    48de:	8f 91       	pop	r24
    48e0:	7f 91       	pop	r23
    48e2:	6f 91       	pop	r22
    48e4:	5f 91       	pop	r21
    48e6:	4f 91       	pop	r20
    48e8:	3f 91       	pop	r19
    48ea:	2f 91       	pop	r18
    48ec:	0f 90       	pop	r0
    48ee:	0b be       	out	0x3b, r0	; 59
    48f0:	0f 90       	pop	r0
    48f2:	09 be       	out	0x39, r0	; 57
    48f4:	0f 90       	pop	r0
    48f6:	08 be       	out	0x38, r0	; 56
    48f8:	0f 90       	pop	r0
    48fa:	0f be       	out	0x3f, r0	; 63
    48fc:	0f 90       	pop	r0
    48fe:	1f 90       	pop	r1
    4900:	18 95       	reti

00004902 <_ZN10I2C_Master9slave_intEv>:
}

void I2C_Master::slave_int()
{
    // Not Implemented..
}
    4902:	08 95       	ret

00004904 <_ZN10I2C_Master8dumpregsEv>:
            if (pdbgserial) pdbgserial->println("BusState -> Busy.");
            break;
    }
}

void I2C_Master::dumpregs()
    4904:	ef 92       	push	r14
    4906:	ff 92       	push	r15
    4908:	0f 93       	push	r16
    490a:	1f 93       	push	r17
    490c:	df 93       	push	r29
    490e:	cf 93       	push	r28
    4910:	cd b7       	in	r28, 0x3d	; 61
    4912:	de b7       	in	r29, 0x3e	; 62
    4914:	c0 58       	subi	r28, 0x80	; 128
    4916:	d0 40       	sbci	r29, 0x00	; 0
    4918:	cd bf       	out	0x3d, r28	; 61
    491a:	de bf       	out	0x3e, r29	; 62
    491c:	8c 01       	movw	r16, r24
{
    char    buffer[128];

    sprintf(buffer,"CTRLA:0x%x",_twi->MASTER.CTRLA);
    491e:	dc 01       	movw	r26, r24
    4920:	ed 91       	ld	r30, X+
    4922:	fc 91       	ld	r31, X
    4924:	21 81       	ldd	r18, Z+1	; 0x01
    4926:	00 d0       	rcall	.+0      	; 0x4928 <_ZN10I2C_Master8dumpregsEv+0x24>
    4928:	00 d0       	rcall	.+0      	; 0x492a <_ZN10I2C_Master8dumpregsEv+0x26>
    492a:	ed b7       	in	r30, 0x3d	; 61
    492c:	fe b7       	in	r31, 0x3e	; 62
    492e:	31 96       	adiw	r30, 0x01	; 1
    4930:	7e 01       	movw	r14, r28
    4932:	08 94       	sec
    4934:	e1 1c       	adc	r14, r1
    4936:	f1 1c       	adc	r15, r1
    4938:	ad b7       	in	r26, 0x3d	; 61
    493a:	be b7       	in	r27, 0x3e	; 62
    493c:	11 96       	adiw	r26, 0x01	; 1
    493e:	ed 92       	st	X+, r14
    4940:	fc 92       	st	X, r15
    4942:	12 97       	sbiw	r26, 0x02	; 2
    4944:	83 e5       	ldi	r24, 0x53	; 83
    4946:	93 e2       	ldi	r25, 0x23	; 35
    4948:	82 83       	std	Z+2, r24	; 0x02
    494a:	93 83       	std	Z+3, r25	; 0x03
    494c:	24 83       	std	Z+4, r18	; 0x04
    494e:	15 82       	std	Z+5, r1	; 0x05
    4950:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    4954:	80 91 2a 26 	lds	r24, 0x262A
    4958:	90 91 2b 26 	lds	r25, 0x262B
    495c:	2d b7       	in	r18, 0x3d	; 61
    495e:	3e b7       	in	r19, 0x3e	; 62
    4960:	2a 5f       	subi	r18, 0xFA	; 250
    4962:	3f 4f       	sbci	r19, 0xFF	; 255
    4964:	2d bf       	out	0x3d, r18	; 61
    4966:	3e bf       	out	0x3e, r19	; 62
    4968:	00 97       	sbiw	r24, 0x00	; 0
    496a:	19 f0       	breq	.+6      	; 0x4972 <_ZN10I2C_Master8dumpregsEv+0x6e>
    496c:	b7 01       	movw	r22, r14
    496e:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    sprintf(buffer,"CTRLB:0x%x",_twi->MASTER.CTRLB);
    4972:	d8 01       	movw	r26, r16
    4974:	ed 91       	ld	r30, X+
    4976:	fc 91       	ld	r31, X
    4978:	22 81       	ldd	r18, Z+2	; 0x02
    497a:	00 d0       	rcall	.+0      	; 0x497c <_ZN10I2C_Master8dumpregsEv+0x78>
    497c:	00 d0       	rcall	.+0      	; 0x497e <_ZN10I2C_Master8dumpregsEv+0x7a>
    497e:	ed b7       	in	r30, 0x3d	; 61
    4980:	fe b7       	in	r31, 0x3e	; 62
    4982:	31 96       	adiw	r30, 0x01	; 1
    4984:	7e 01       	movw	r14, r28
    4986:	08 94       	sec
    4988:	e1 1c       	adc	r14, r1
    498a:	f1 1c       	adc	r15, r1
    498c:	ad b7       	in	r26, 0x3d	; 61
    498e:	be b7       	in	r27, 0x3e	; 62
    4990:	11 96       	adiw	r26, 0x01	; 1
    4992:	ed 92       	st	X+, r14
    4994:	fc 92       	st	X, r15
    4996:	12 97       	sbiw	r26, 0x02	; 2
    4998:	8e e5       	ldi	r24, 0x5E	; 94
    499a:	93 e2       	ldi	r25, 0x23	; 35
    499c:	82 83       	std	Z+2, r24	; 0x02
    499e:	93 83       	std	Z+3, r25	; 0x03
    49a0:	24 83       	std	Z+4, r18	; 0x04
    49a2:	15 82       	std	Z+5, r1	; 0x05
    49a4:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    49a8:	80 91 2a 26 	lds	r24, 0x262A
    49ac:	90 91 2b 26 	lds	r25, 0x262B
    49b0:	2d b7       	in	r18, 0x3d	; 61
    49b2:	3e b7       	in	r19, 0x3e	; 62
    49b4:	2a 5f       	subi	r18, 0xFA	; 250
    49b6:	3f 4f       	sbci	r19, 0xFF	; 255
    49b8:	2d bf       	out	0x3d, r18	; 61
    49ba:	3e bf       	out	0x3e, r19	; 62
    49bc:	00 97       	sbiw	r24, 0x00	; 0
    49be:	19 f0       	breq	.+6      	; 0x49c6 <_ZN10I2C_Master8dumpregsEv+0xc2>
    49c0:	b7 01       	movw	r22, r14
    49c2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    sprintf(buffer,"CTRLC:0x%x",_twi->MASTER.CTRLC);
    49c6:	d8 01       	movw	r26, r16
    49c8:	ed 91       	ld	r30, X+
    49ca:	fc 91       	ld	r31, X
    49cc:	23 81       	ldd	r18, Z+3	; 0x03
    49ce:	00 d0       	rcall	.+0      	; 0x49d0 <_ZN10I2C_Master8dumpregsEv+0xcc>
    49d0:	00 d0       	rcall	.+0      	; 0x49d2 <_ZN10I2C_Master8dumpregsEv+0xce>
    49d2:	ed b7       	in	r30, 0x3d	; 61
    49d4:	fe b7       	in	r31, 0x3e	; 62
    49d6:	31 96       	adiw	r30, 0x01	; 1
    49d8:	7e 01       	movw	r14, r28
    49da:	08 94       	sec
    49dc:	e1 1c       	adc	r14, r1
    49de:	f1 1c       	adc	r15, r1
    49e0:	ad b7       	in	r26, 0x3d	; 61
    49e2:	be b7       	in	r27, 0x3e	; 62
    49e4:	11 96       	adiw	r26, 0x01	; 1
    49e6:	ed 92       	st	X+, r14
    49e8:	fc 92       	st	X, r15
    49ea:	12 97       	sbiw	r26, 0x02	; 2
    49ec:	89 e6       	ldi	r24, 0x69	; 105
    49ee:	93 e2       	ldi	r25, 0x23	; 35
    49f0:	82 83       	std	Z+2, r24	; 0x02
    49f2:	93 83       	std	Z+3, r25	; 0x03
    49f4:	24 83       	std	Z+4, r18	; 0x04
    49f6:	15 82       	std	Z+5, r1	; 0x05
    49f8:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    49fc:	80 91 2a 26 	lds	r24, 0x262A
    4a00:	90 91 2b 26 	lds	r25, 0x262B
    4a04:	2d b7       	in	r18, 0x3d	; 61
    4a06:	3e b7       	in	r19, 0x3e	; 62
    4a08:	2a 5f       	subi	r18, 0xFA	; 250
    4a0a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a0c:	2d bf       	out	0x3d, r18	; 61
    4a0e:	3e bf       	out	0x3e, r19	; 62
    4a10:	00 97       	sbiw	r24, 0x00	; 0
    4a12:	19 f0       	breq	.+6      	; 0x4a1a <_ZN10I2C_Master8dumpregsEv+0x116>
    4a14:	b7 01       	movw	r22, r14
    4a16:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    sprintf(buffer,"BAUD:0x%x",_twi->MASTER.BAUD);
    4a1a:	d8 01       	movw	r26, r16
    4a1c:	ed 91       	ld	r30, X+
    4a1e:	fc 91       	ld	r31, X
    4a20:	25 81       	ldd	r18, Z+5	; 0x05
    4a22:	00 d0       	rcall	.+0      	; 0x4a24 <_ZN10I2C_Master8dumpregsEv+0x120>
    4a24:	00 d0       	rcall	.+0      	; 0x4a26 <_ZN10I2C_Master8dumpregsEv+0x122>
    4a26:	ed b7       	in	r30, 0x3d	; 61
    4a28:	fe b7       	in	r31, 0x3e	; 62
    4a2a:	31 96       	adiw	r30, 0x01	; 1
    4a2c:	7e 01       	movw	r14, r28
    4a2e:	08 94       	sec
    4a30:	e1 1c       	adc	r14, r1
    4a32:	f1 1c       	adc	r15, r1
    4a34:	ad b7       	in	r26, 0x3d	; 61
    4a36:	be b7       	in	r27, 0x3e	; 62
    4a38:	11 96       	adiw	r26, 0x01	; 1
    4a3a:	ed 92       	st	X+, r14
    4a3c:	fc 92       	st	X, r15
    4a3e:	12 97       	sbiw	r26, 0x02	; 2
    4a40:	84 e7       	ldi	r24, 0x74	; 116
    4a42:	93 e2       	ldi	r25, 0x23	; 35
    4a44:	82 83       	std	Z+2, r24	; 0x02
    4a46:	93 83       	std	Z+3, r25	; 0x03
    4a48:	24 83       	std	Z+4, r18	; 0x04
    4a4a:	15 82       	std	Z+5, r1	; 0x05
    4a4c:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    4a50:	80 91 2a 26 	lds	r24, 0x262A
    4a54:	90 91 2b 26 	lds	r25, 0x262B
    4a58:	2d b7       	in	r18, 0x3d	; 61
    4a5a:	3e b7       	in	r19, 0x3e	; 62
    4a5c:	2a 5f       	subi	r18, 0xFA	; 250
    4a5e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a60:	2d bf       	out	0x3d, r18	; 61
    4a62:	3e bf       	out	0x3e, r19	; 62
    4a64:	00 97       	sbiw	r24, 0x00	; 0
    4a66:	19 f0       	breq	.+6      	; 0x4a6e <_ZN10I2C_Master8dumpregsEv+0x16a>
    4a68:	b7 01       	movw	r22, r14
    4a6a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    sprintf(buffer,"STATUS:0x%x",_twi->MASTER.STATUS);
    4a6e:	d8 01       	movw	r26, r16
    4a70:	ed 91       	ld	r30, X+
    4a72:	fc 91       	ld	r31, X
    4a74:	24 81       	ldd	r18, Z+4	; 0x04
    4a76:	00 d0       	rcall	.+0      	; 0x4a78 <_ZN10I2C_Master8dumpregsEv+0x174>
    4a78:	00 d0       	rcall	.+0      	; 0x4a7a <_ZN10I2C_Master8dumpregsEv+0x176>
    4a7a:	ed b7       	in	r30, 0x3d	; 61
    4a7c:	fe b7       	in	r31, 0x3e	; 62
    4a7e:	31 96       	adiw	r30, 0x01	; 1
    4a80:	7e 01       	movw	r14, r28
    4a82:	08 94       	sec
    4a84:	e1 1c       	adc	r14, r1
    4a86:	f1 1c       	adc	r15, r1
    4a88:	ad b7       	in	r26, 0x3d	; 61
    4a8a:	be b7       	in	r27, 0x3e	; 62
    4a8c:	11 96       	adiw	r26, 0x01	; 1
    4a8e:	ed 92       	st	X+, r14
    4a90:	fc 92       	st	X, r15
    4a92:	12 97       	sbiw	r26, 0x02	; 2
    4a94:	8e e7       	ldi	r24, 0x7E	; 126
    4a96:	93 e2       	ldi	r25, 0x23	; 35
    4a98:	82 83       	std	Z+2, r24	; 0x02
    4a9a:	93 83       	std	Z+3, r25	; 0x03
    4a9c:	24 83       	std	Z+4, r18	; 0x04
    4a9e:	15 82       	std	Z+5, r1	; 0x05
    4aa0:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    4aa4:	80 91 2a 26 	lds	r24, 0x262A
    4aa8:	90 91 2b 26 	lds	r25, 0x262B
    4aac:	2d b7       	in	r18, 0x3d	; 61
    4aae:	3e b7       	in	r19, 0x3e	; 62
    4ab0:	2a 5f       	subi	r18, 0xFA	; 250
    4ab2:	3f 4f       	sbci	r19, 0xFF	; 255
    4ab4:	2d bf       	out	0x3d, r18	; 61
    4ab6:	3e bf       	out	0x3e, r19	; 62
    4ab8:	00 97       	sbiw	r24, 0x00	; 0
    4aba:	19 f0       	breq	.+6      	; 0x4ac2 <_ZN10I2C_Master8dumpregsEv+0x1be>
    4abc:	b7 01       	movw	r22, r14
    4abe:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>

    sprintf(buffer,"SLAVE.CTRLA:0x%x",_twi->SLAVE.CTRLA);
    4ac2:	d8 01       	movw	r26, r16
    4ac4:	ed 91       	ld	r30, X+
    4ac6:	fc 91       	ld	r31, X
    4ac8:	20 85       	ldd	r18, Z+8	; 0x08
    4aca:	00 d0       	rcall	.+0      	; 0x4acc <_ZN10I2C_Master8dumpregsEv+0x1c8>
    4acc:	00 d0       	rcall	.+0      	; 0x4ace <_ZN10I2C_Master8dumpregsEv+0x1ca>
    4ace:	ed b7       	in	r30, 0x3d	; 61
    4ad0:	fe b7       	in	r31, 0x3e	; 62
    4ad2:	31 96       	adiw	r30, 0x01	; 1
    4ad4:	8e 01       	movw	r16, r28
    4ad6:	0f 5f       	subi	r16, 0xFF	; 255
    4ad8:	1f 4f       	sbci	r17, 0xFF	; 255
    4ada:	ad b7       	in	r26, 0x3d	; 61
    4adc:	be b7       	in	r27, 0x3e	; 62
    4ade:	11 96       	adiw	r26, 0x01	; 1
    4ae0:	0d 93       	st	X+, r16
    4ae2:	1c 93       	st	X, r17
    4ae4:	12 97       	sbiw	r26, 0x02	; 2
    4ae6:	8a e8       	ldi	r24, 0x8A	; 138
    4ae8:	93 e2       	ldi	r25, 0x23	; 35
    4aea:	82 83       	std	Z+2, r24	; 0x02
    4aec:	93 83       	std	Z+3, r25	; 0x03
    4aee:	24 83       	std	Z+4, r18	; 0x04
    4af0:	15 82       	std	Z+5, r1	; 0x05
    4af2:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    4af6:	80 91 2a 26 	lds	r24, 0x262A
    4afa:	90 91 2b 26 	lds	r25, 0x262B
    4afe:	2d b7       	in	r18, 0x3d	; 61
    4b00:	3e b7       	in	r19, 0x3e	; 62
    4b02:	2a 5f       	subi	r18, 0xFA	; 250
    4b04:	3f 4f       	sbci	r19, 0xFF	; 255
    4b06:	2d bf       	out	0x3d, r18	; 61
    4b08:	3e bf       	out	0x3e, r19	; 62
    4b0a:	00 97       	sbiw	r24, 0x00	; 0
    4b0c:	19 f0       	breq	.+6      	; 0x4b14 <_ZN10I2C_Master8dumpregsEv+0x210>
    4b0e:	b8 01       	movw	r22, r16
    4b10:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
}
    4b14:	c0 58       	subi	r28, 0x80	; 128
    4b16:	df 4f       	sbci	r29, 0xFF	; 255
    4b18:	cd bf       	out	0x3d, r28	; 61
    4b1a:	de bf       	out	0x3e, r29	; 62
    4b1c:	cf 91       	pop	r28
    4b1e:	df 91       	pop	r29
    4b20:	1f 91       	pop	r17
    4b22:	0f 91       	pop	r16
    4b24:	ff 90       	pop	r15
    4b26:	ef 90       	pop	r14
    4b28:	08 95       	ret

00004b2a <_ZN10I2C_Master9showstateEv>:
void I2C_Master::slave_int()
{
    // Not Implemented..
}

void I2C_Master::showstate()
    4b2a:	fc 01       	movw	r30, r24
	return 0;
}

uint8_t I2C_Master::busState()
{
    return (_twi->MASTER.STATUS & TWI_MASTER_BUSSTATE_gm);
    4b2c:	01 90       	ld	r0, Z+
    4b2e:	f0 81       	ld	r31, Z
    4b30:	e0 2d       	mov	r30, r0
    4b32:	84 81       	ldd	r24, Z+4	; 0x04
    // Not Implemented..
}

void I2C_Master::showstate()
{
    switch(busState()) {
    4b34:	83 70       	andi	r24, 0x03	; 3
    4b36:	81 30       	cpi	r24, 0x01	; 1
    4b38:	81 f0       	breq	.+32     	; 0x4b5a <_ZN10I2C_Master9showstateEv+0x30>
    4b3a:	81 30       	cpi	r24, 0x01	; 1
    4b3c:	28 f0       	brcs	.+10     	; 0x4b48 <_ZN10I2C_Master9showstateEv+0x1e>
    4b3e:	82 30       	cpi	r24, 0x02	; 2
    4b40:	a9 f0       	breq	.+42     	; 0x4b6c <_ZN10I2C_Master9showstateEv+0x42>
    4b42:	83 30       	cpi	r24, 0x03	; 3
    4b44:	41 f5       	brne	.+80     	; 0x4b96 <_ZN10I2C_Master9showstateEv+0x6c>
    4b46:	1d c0       	rjmp	.+58     	; 0x4b82 <_ZN10I2C_Master9showstateEv+0x58>
        case TWI_MASTER_BUSSTATE_UNKNOWN_gc:
            if (pdbgserial) pdbgserial->println("BusState -> Unknown.");
    4b48:	80 91 2a 26 	lds	r24, 0x262A
    4b4c:	90 91 2b 26 	lds	r25, 0x262B
    4b50:	00 97       	sbiw	r24, 0x00	; 0
    4b52:	09 f1       	breq	.+66     	; 0x4b96 <_ZN10I2C_Master9showstateEv+0x6c>
    4b54:	6b e9       	ldi	r22, 0x9B	; 155
    4b56:	73 e2       	ldi	r23, 0x23	; 35
    4b58:	11 c0       	rjmp	.+34     	; 0x4b7c <_ZN10I2C_Master9showstateEv+0x52>
            break;
        case TWI_MASTER_BUSSTATE_IDLE_gc:
            if (pdbgserial) pdbgserial->println("BusState -> Idle.");
    4b5a:	80 91 2a 26 	lds	r24, 0x262A
    4b5e:	90 91 2b 26 	lds	r25, 0x262B
    4b62:	00 97       	sbiw	r24, 0x00	; 0
    4b64:	c1 f0       	breq	.+48     	; 0x4b96 <_ZN10I2C_Master9showstateEv+0x6c>
    4b66:	60 eb       	ldi	r22, 0xB0	; 176
    4b68:	73 e2       	ldi	r23, 0x23	; 35
    4b6a:	08 c0       	rjmp	.+16     	; 0x4b7c <_ZN10I2C_Master9showstateEv+0x52>
            break;
        case TWI_MASTER_BUSSTATE_OWNER_gc:
            if (pdbgserial) pdbgserial->println("BusState -> Owner.");
    4b6c:	80 91 2a 26 	lds	r24, 0x262A
    4b70:	90 91 2b 26 	lds	r25, 0x262B
    4b74:	00 97       	sbiw	r24, 0x00	; 0
    4b76:	79 f0       	breq	.+30     	; 0x4b96 <_ZN10I2C_Master9showstateEv+0x6c>
    4b78:	62 ec       	ldi	r22, 0xC2	; 194
    4b7a:	73 e2       	ldi	r23, 0x23	; 35
    4b7c:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    4b80:	08 95       	ret
            break;
        case TWI_MASTER_BUSSTATE_BUSY_gc:
            if (pdbgserial) pdbgserial->println("BusState -> Busy.");
    4b82:	80 91 2a 26 	lds	r24, 0x262A
    4b86:	90 91 2b 26 	lds	r25, 0x262B
    4b8a:	00 97       	sbiw	r24, 0x00	; 0
    4b8c:	21 f0       	breq	.+8      	; 0x4b96 <_ZN10I2C_Master9showstateEv+0x6c>
    4b8e:	65 ed       	ldi	r22, 0xD5	; 213
    4b90:	73 e2       	ldi	r23, 0x23	; 35
    4b92:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    4b96:	08 95       	ret

00004b98 <_ZN10I2C_Master7testackEh>:
        _State = sIdle;
        if (pdbgserial) pdbgserial->println("Reset after error.");
    }
}

int I2C_Master::testack(uint8_t ID)
    4b98:	cf 92       	push	r12
    4b9a:	df 92       	push	r13
    4b9c:	ff 92       	push	r15
    4b9e:	0f 93       	push	r16
    4ba0:	1f 93       	push	r17
    4ba2:	df 93       	push	r29
    4ba4:	cf 93       	push	r28
    4ba6:	cd b7       	in	r28, 0x3d	; 61
    4ba8:	de b7       	in	r29, 0x3e	; 62
    4baa:	c0 58       	subi	r28, 0x80	; 128
    4bac:	d0 40       	sbci	r29, 0x00	; 0
    4bae:	cd bf       	out	0x3d, r28	; 61
    4bb0:	de bf       	out	0x3e, r29	; 62
    4bb2:	8c 01       	movw	r16, r24
    4bb4:	f6 2e       	mov	r15, r22
{
    char buffer[128];

    sprintf(buffer,"Testing TWI:ID = %d",ID);
    4bb6:	00 d0       	rcall	.+0      	; 0x4bb8 <_ZN10I2C_Master7testackEh+0x20>
    4bb8:	00 d0       	rcall	.+0      	; 0x4bba <_ZN10I2C_Master7testackEh+0x22>
    4bba:	ed b7       	in	r30, 0x3d	; 61
    4bbc:	fe b7       	in	r31, 0x3e	; 62
    4bbe:	31 96       	adiw	r30, 0x01	; 1
    4bc0:	6e 01       	movw	r12, r28
    4bc2:	08 94       	sec
    4bc4:	c1 1c       	adc	r12, r1
    4bc6:	d1 1c       	adc	r13, r1
    4bc8:	ad b7       	in	r26, 0x3d	; 61
    4bca:	be b7       	in	r27, 0x3e	; 62
    4bcc:	11 96       	adiw	r26, 0x01	; 1
    4bce:	cd 92       	st	X+, r12
    4bd0:	dc 92       	st	X, r13
    4bd2:	12 97       	sbiw	r26, 0x02	; 2
    4bd4:	87 ee       	ldi	r24, 0xE7	; 231
    4bd6:	93 e2       	ldi	r25, 0x23	; 35
    4bd8:	82 83       	std	Z+2, r24	; 0x02
    4bda:	93 83       	std	Z+3, r25	; 0x03
    4bdc:	64 83       	std	Z+4, r22	; 0x04
    4bde:	15 82       	std	Z+5, r1	; 0x05
    4be0:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    4be4:	80 91 2a 26 	lds	r24, 0x262A
    4be8:	90 91 2b 26 	lds	r25, 0x262B
    4bec:	ed b7       	in	r30, 0x3d	; 61
    4bee:	fe b7       	in	r31, 0x3e	; 62
    4bf0:	36 96       	adiw	r30, 0x06	; 6
    4bf2:	ed bf       	out	0x3d, r30	; 61
    4bf4:	fe bf       	out	0x3e, r31	; 62
    4bf6:	00 97       	sbiw	r24, 0x00	; 0
    4bf8:	19 f0       	breq	.+6      	; 0x4c00 <_ZN10I2C_Master7testackEh+0x68>
    4bfa:	b6 01       	movw	r22, r12
    4bfc:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>

    _twi->MASTER.CTRLA &= ~TWI_MASTER_ENABLE_bm;
    4c00:	d8 01       	movw	r26, r16
    4c02:	ed 91       	ld	r30, X+
    4c04:	fc 91       	ld	r31, X
    4c06:	11 97       	sbiw	r26, 0x01	; 1
    4c08:	81 81       	ldd	r24, Z+1	; 0x01
    4c0a:	87 7f       	andi	r24, 0xF7	; 247
    4c0c:	81 83       	std	Z+1, r24	; 0x01
    _twi->MASTER.BAUD = 35;
    4c0e:	ed 91       	ld	r30, X+
    4c10:	fc 91       	ld	r31, X
    4c12:	11 97       	sbiw	r26, 0x01	; 1
    4c14:	83 e2       	ldi	r24, 0x23	; 35
    4c16:	85 83       	std	Z+5, r24	; 0x05
    _twi->MASTER.CTRLA |= TWI_MASTER_ENABLE_bm;
    4c18:	ed 91       	ld	r30, X+
    4c1a:	fc 91       	ld	r31, X
    4c1c:	11 97       	sbiw	r26, 0x01	; 1
    4c1e:	81 81       	ldd	r24, Z+1	; 0x01
    4c20:	88 60       	ori	r24, 0x08	; 8
    4c22:	81 83       	std	Z+1, r24	; 0x01

    // Clear any current interrupts
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4c24:	ed 91       	ld	r30, X+
    4c26:	fc 91       	ld	r31, X
    4c28:	81 e0       	ldi	r24, 0x01	; 1
    4c2a:	84 83       	std	Z+4, r24	; 0x04
    showstate();
    4c2c:	c8 01       	movw	r24, r16
    4c2e:	0e 94 95 25 	call	0x4b2a	; 0x4b2a <_ZN10I2C_Master9showstateEv>

    dumpregs();
    4c32:	c8 01       	movw	r24, r16
    4c34:	0e 94 82 24 	call	0x4904	; 0x4904 <_ZN10I2C_Master8dumpregsEv>

    uint8_t addr = ID & ~0x1; // Write
    4c38:	be ef       	ldi	r27, 0xFE	; 254
    4c3a:	fb 22       	and	r15, r27
    _twi->MASTER.ADDR = addr;
    4c3c:	d8 01       	movw	r26, r16
    4c3e:	ed 91       	ld	r30, X+
    4c40:	fc 91       	ld	r31, X
    4c42:	f6 82       	std	Z+6, r15	; 0x06
    4c44:	95 e0       	ldi	r25, 0x05	; 5
    4c46:	f9 2e       	mov	r15, r25
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    4c48:	80 e2       	ldi	r24, 0x20	; 32
    4c4a:	c8 2e       	mov	r12, r24
    4c4c:	83 e0       	ldi	r24, 0x03	; 3
    4c4e:	d8 2e       	mov	r13, r24
    4c50:	0d c0       	rjmp	.+26     	; 0x4c6c <_ZN10I2C_Master7testackEh+0xd4>

    uint8_t to = 5;
    while (--to && _State != sIdle) {
    4c52:	84 e6       	ldi	r24, 0x64	; 100
    4c54:	90 e0       	ldi	r25, 0x00	; 0
    4c56:	f6 01       	movw	r30, r12
    4c58:	31 97       	sbiw	r30, 0x01	; 1
    4c5a:	f1 f7       	brne	.-4      	; 0x4c58 <_ZN10I2C_Master7testackEh+0xc0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c5c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c5e:	d9 f7       	brne	.-10     	; 0x4c56 <_ZN10I2C_Master7testackEh+0xbe>
        _delay_ms(10);
        showstate();
    4c60:	c8 01       	movw	r24, r16
    4c62:	0e 94 95 25 	call	0x4b2a	; 0x4b2a <_ZN10I2C_Master9showstateEv>
        dumpregs();
    4c66:	c8 01       	movw	r24, r16
    4c68:	0e 94 82 24 	call	0x4904	; 0x4904 <_ZN10I2C_Master8dumpregsEv>

    uint8_t addr = ID & ~0x1; // Write
    _twi->MASTER.ADDR = addr;

    uint8_t to = 5;
    while (--to && _State != sIdle) {
    4c6c:	fa 94       	dec	r15
    4c6e:	29 f0       	breq	.+10     	; 0x4c7a <_ZN10I2C_Master7testackEh+0xe2>
    4c70:	f8 01       	movw	r30, r16
    4c72:	85 81       	ldd	r24, Z+5	; 0x05
    4c74:	88 23       	and	r24, r24
    4c76:	e1 f0       	breq	.+56     	; 0x4cb0 <_ZN10I2C_Master7testackEh+0x118>
    4c78:	ec cf       	rjmp	.-40     	; 0x4c52 <_ZN10I2C_Master7testackEh+0xba>
        dumpregs();
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
        showstate();
        dumpregs();
    } else {
        if (pdbgserial) pdbgserial->println("Timeout..");
    4c7a:	80 91 2a 26 	lds	r24, 0x262A
    4c7e:	90 91 2b 26 	lds	r25, 0x262B
    4c82:	00 97       	sbiw	r24, 0x00	; 0
    4c84:	21 f0       	breq	.+8      	; 0x4c8e <_ZN10I2C_Master7testackEh+0xf6>
    4c86:	6b ef       	ldi	r22, 0xFB	; 251
    4c88:	73 e2       	ldi	r23, 0x23	; 35
    4c8a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    }
    showstate();
    4c8e:	c8 01       	movw	r24, r16
    4c90:	0e 94 95 25 	call	0x4b2a	; 0x4b2a <_ZN10I2C_Master9showstateEv>

	return 0;
}
    4c94:	80 e0       	ldi	r24, 0x00	; 0
    4c96:	90 e0       	ldi	r25, 0x00	; 0
    4c98:	c0 58       	subi	r28, 0x80	; 128
    4c9a:	df 4f       	sbci	r29, 0xFF	; 255
    4c9c:	cd bf       	out	0x3d, r28	; 61
    4c9e:	de bf       	out	0x3e, r29	; 62
    4ca0:	cf 91       	pop	r28
    4ca2:	df 91       	pop	r29
    4ca4:	1f 91       	pop	r17
    4ca6:	0f 91       	pop	r16
    4ca8:	ff 90       	pop	r15
    4caa:	df 90       	pop	r13
    4cac:	cf 90       	pop	r12
    4cae:	08 95       	ret
        _delay_ms(10);
        showstate();
        dumpregs();
    }
    if (to) {
        showstate();
    4cb0:	c8 01       	movw	r24, r16
    4cb2:	0e 94 95 25 	call	0x4b2a	; 0x4b2a <_ZN10I2C_Master9showstateEv>
        dumpregs();
    4cb6:	c8 01       	movw	r24, r16
    4cb8:	0e 94 82 24 	call	0x4904	; 0x4904 <_ZN10I2C_Master8dumpregsEv>
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    4cbc:	d8 01       	movw	r26, r16
    4cbe:	ed 91       	ld	r30, X+
    4cc0:	fc 91       	ld	r31, X
    4cc2:	83 e0       	ldi	r24, 0x03	; 3
    4cc4:	83 83       	std	Z+3, r24	; 0x03
        showstate();
    4cc6:	c8 01       	movw	r24, r16
    4cc8:	0e 94 95 25 	call	0x4b2a	; 0x4b2a <_ZN10I2C_Master9showstateEv>
        dumpregs();
    4ccc:	c8 01       	movw	r24, r16
    4cce:	0e 94 82 24 	call	0x4904	; 0x4904 <_ZN10I2C_Master8dumpregsEv>
    4cd2:	dd cf       	rjmp	.-70     	; 0x4c8e <_ZN10I2C_Master7testackEh+0xf6>

00004cd4 <_ZN10I2C_Master4loopEv>:
    _twi->MASTER.CTRLA = 0; // Disable everything.
    _bEnabled = false;
    if (pdbgserial) pdbgserial->println("I2C Master end called.");
}

void I2C_Master::loop()
    4cd4:	fc 01       	movw	r30, r24
{
    if (_State == sError) {
    4cd6:	85 81       	ldd	r24, Z+5	; 0x05
    4cd8:	82 30       	cpi	r24, 0x02	; 2
    4cda:	59 f4       	brne	.+22     	; 0x4cf2 <_ZN10I2C_Master4loopEv+0x1e>
        _State = sIdle;
    4cdc:	15 82       	std	Z+5, r1	; 0x05
        if (pdbgserial) pdbgserial->println("Reset after error.");
    4cde:	80 91 2a 26 	lds	r24, 0x262A
    4ce2:	90 91 2b 26 	lds	r25, 0x262B
    4ce6:	00 97       	sbiw	r24, 0x00	; 0
    4ce8:	21 f0       	breq	.+8      	; 0x4cf2 <_ZN10I2C_Master4loopEv+0x1e>
    4cea:	65 e0       	ldi	r22, 0x05	; 5
    4cec:	74 e2       	ldi	r23, 0x24	; 36
    4cee:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    4cf2:	08 95       	ret

00004cf4 <_ZN10I2C_Master3endEv>:
    _State      = sIdle;
    _Result     = rOk;
    if (pdbgserial) pdbgserial->println("I2C Master begin called.");
}

void I2C_Master::end()
    4cf4:	dc 01       	movw	r26, r24
{
    _twi->MASTER.CTRLA = 0; // Disable everything.
    4cf6:	ed 91       	ld	r30, X+
    4cf8:	fc 91       	ld	r31, X
    4cfa:	11 97       	sbiw	r26, 0x01	; 1
    4cfc:	11 82       	std	Z+1, r1	; 0x01
    _bEnabled = false;
    4cfe:	14 96       	adiw	r26, 0x04	; 4
    4d00:	1c 92       	st	X, r1
    if (pdbgserial) pdbgserial->println("I2C Master end called.");
    4d02:	80 91 2a 26 	lds	r24, 0x262A
    4d06:	90 91 2b 26 	lds	r25, 0x262B
    4d0a:	00 97       	sbiw	r24, 0x00	; 0
    4d0c:	21 f0       	breq	.+8      	; 0x4d16 <_ZN10I2C_Master3endEv+0x22>
    4d0e:	68 e1       	ldi	r22, 0x18	; 24
    4d10:	74 e2       	ldi	r23, 0x24	; 36
    4d12:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    4d16:	08 95       	ret

00004d18 <_ZN10I2C_MasterD1Ev>:

    SetTWIPointer(_twi,this);
    if (pdbgserial) pdbgserial->println("I2C Master Constructor.");
}

I2C_Master::~I2C_Master()
    4d18:	0f 93       	push	r16
    4d1a:	1f 93       	push	r17
    4d1c:	8c 01       	movw	r16, r24
{
    end();
    4d1e:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <_ZN10I2C_Master3endEv>

    SetTWIPointer(_twi,(I2C_Master*)0);
    4d22:	f8 01       	movw	r30, r16
    4d24:	80 81       	ld	r24, Z
    4d26:	91 81       	ldd	r25, Z+1	; 0x01
    4d28:	60 e0       	ldi	r22, 0x00	; 0
    4d2a:	70 e0       	ldi	r23, 0x00	; 0
    4d2c:	0e 94 07 21 	call	0x420e	; 0x420e <_ZL13SetTWIPointerP10TWI_structP10I2C_Master>
}
    4d30:	1f 91       	pop	r17
    4d32:	0f 91       	pop	r16
    4d34:	08 95       	ret

00004d36 <_ZN10I2C_MasterD2Ev>:

    SetTWIPointer(_twi,this);
    if (pdbgserial) pdbgserial->println("I2C Master Constructor.");
}

I2C_Master::~I2C_Master()
    4d36:	0f 93       	push	r16
    4d38:	1f 93       	push	r17
    4d3a:	8c 01       	movw	r16, r24
{
    end();
    4d3c:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <_ZN10I2C_Master3endEv>

    SetTWIPointer(_twi,(I2C_Master*)0);
    4d40:	f8 01       	movw	r30, r16
    4d42:	80 81       	ld	r24, Z
    4d44:	91 81       	ldd	r25, Z+1	; 0x01
    4d46:	60 e0       	ldi	r22, 0x00	; 0
    4d48:	70 e0       	ldi	r23, 0x00	; 0
    4d4a:	0e 94 07 21 	call	0x420e	; 0x420e <_ZL13SetTWIPointerP10TWI_structP10I2C_Master>
}
    4d4e:	1f 91       	pop	r17
    4d50:	0f 91       	pop	r16
    4d52:	08 95       	ret

00004d54 <_ZN10I2C_Master5beginEm>:
        TWI_MASTER_ARBLOST_bm |
        TWI_MASTER_BUSERR_bm |
        TWI_MASTER_BUSSTATE_IDLE_gc;
}

void I2C_Master::begin(uint32_t freq)
    4d54:	ff 92       	push	r15
    4d56:	0f 93       	push	r16
    4d58:	1f 93       	push	r17
    4d5a:	8c 01       	movw	r16, r24
    4d5c:	9a 01       	movw	r18, r20
    4d5e:	ab 01       	movw	r20, r22
{
    // Things to do:
    // Check the bus state. If the state is Unknown, then issue a stop to get the
    // state to Idle.

    _twi->CTRL = 0; // Set to normal TWI, turn off SDA Hold
    4d60:	dc 01       	movw	r26, r24
    4d62:	ed 91       	ld	r30, X+
    4d64:	fc 91       	ld	r31, X
    4d66:	11 97       	sbiw	r26, 0x01	; 1
    4d68:	10 82       	st	Z, r1

    // Clear any current interrupts
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4d6a:	ed 91       	ld	r30, X+
    4d6c:	fc 91       	ld	r31, X
    4d6e:	ff 24       	eor	r15, r15
    4d70:	f3 94       	inc	r15
    4d72:	f4 82       	std	Z+4, r15	; 0x04

    // Baud calculations..
    uint8_t baud;
    //float float_freq = freq;
    baud = (F_CPU/(2*freq)) - 5;
    4d74:	22 0f       	add	r18, r18
    4d76:	33 1f       	adc	r19, r19
    4d78:	44 1f       	adc	r20, r20
    4d7a:	55 1f       	adc	r21, r21
    4d7c:	60 e0       	ldi	r22, 0x00	; 0
    4d7e:	78 e4       	ldi	r23, 0x48	; 72
    4d80:	88 ee       	ldi	r24, 0xE8	; 232
    4d82:	91 e0       	ldi	r25, 0x01	; 1
    4d84:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    4d88:	25 50       	subi	r18, 0x05	; 5
    _twi->MASTER.BAUD = baud; // Set Baud Rate
    4d8a:	d8 01       	movw	r26, r16
    4d8c:	ed 91       	ld	r30, X+
    4d8e:	fc 91       	ld	r31, X
    4d90:	11 97       	sbiw	r26, 0x01	; 1
    4d92:	25 83       	std	Z+5, r18	; 0x05
    
    // I had this set to zero timeout.. which I think was bad. I would occasionally
    // get ARB Lost and this would never reset. Maybe this will help.
    _twi->MASTER.CTRLB = TWI_MASTER_TIMEOUT_200US_gc;
    4d94:	ed 91       	ld	r30, X+
    4d96:	fc 91       	ld	r31, X
    4d98:	11 97       	sbiw	r26, 0x01	; 1
    4d9a:	8c e0       	ldi	r24, 0x0C	; 12
    4d9c:	82 83       	std	Z+2, r24	; 0x02
    // Set the interrupt level and enable the master.
    _twi->MASTER.CTRLA =
          TWI_MASTER_INTLVL_LO_gc
        | TWI_MASTER_ENABLE_bm
        | TWI_MASTER_RIEN_bm
        | TWI_MASTER_WIEN_bm;
    4d9e:	ed 91       	ld	r30, X+
    4da0:	fc 91       	ld	r31, X
    4da2:	11 97       	sbiw	r26, 0x01	; 1
    4da4:	88 e7       	ldi	r24, 0x78	; 120
    4da6:	81 83       	std	Z+1, r24	; 0x01

    // Force bus state to Idle.
    _twi->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
    4da8:	ed 91       	ld	r30, X+
    4daa:	fc 91       	ld	r31, X
    4dac:	11 97       	sbiw	r26, 0x01	; 1
    4dae:	f4 82       	std	Z+4, r15	; 0x04

    _bEnabled   = true;
    4db0:	14 96       	adiw	r26, 0x04	; 4
    4db2:	fc 92       	st	X, r15
    4db4:	14 97       	sbiw	r26, 0x04	; 4
    _State      = sIdle;
    4db6:	15 96       	adiw	r26, 0x05	; 5
    4db8:	1c 92       	st	X, r1
    4dba:	15 97       	sbiw	r26, 0x05	; 5
    _Result     = rOk;
    4dbc:	16 96       	adiw	r26, 0x06	; 6
    4dbe:	1c 92       	st	X, r1
    if (pdbgserial) pdbgserial->println("I2C Master begin called.");
    4dc0:	80 91 2a 26 	lds	r24, 0x262A
    4dc4:	90 91 2b 26 	lds	r25, 0x262B
    4dc8:	00 97       	sbiw	r24, 0x00	; 0
    4dca:	21 f0       	breq	.+8      	; 0x4dd4 <_ZN10I2C_Master5beginEm+0x80>
    4dcc:	6f e2       	ldi	r22, 0x2F	; 47
    4dce:	74 e2       	ldi	r23, 0x24	; 36
    4dd0:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
}
    4dd4:	1f 91       	pop	r17
    4dd6:	0f 91       	pop	r16
    4dd8:	ff 90       	pop	r15
    4dda:	08 95       	ret

00004ddc <_ZN10I2C_MasterC1EP10TWI_struct>:
    } else if (ptype ==  &TWIE) {
        TWIE_master_cp = pm;
    }
}

I2C_Master::I2C_Master(TWI_t* twi)
    4ddc:	dc 01       	movw	r26, r24
{
    _twi        = twi;
    4dde:	6d 93       	st	X+, r22
    4de0:	7c 93       	st	X, r23
    4de2:	11 97       	sbiw	r26, 0x01	; 1
    _bEnabled   = false;
    4de4:	14 96       	adiw	r26, 0x04	; 4
    4de6:	1c 92       	st	X, r1
    4de8:	14 97       	sbiw	r26, 0x04	; 4
    _State      = sIdle;
    4dea:	15 96       	adiw	r26, 0x05	; 5
    4dec:	1c 92       	st	X, r1
    4dee:	15 97       	sbiw	r26, 0x05	; 5
    _Result     = rOk;
    4df0:	16 96       	adiw	r26, 0x06	; 6
    4df2:	1c 92       	st	X, r1
    4df4:	16 97       	sbiw	r26, 0x06	; 6

    _WriteData      = 0;
    4df6:	50 96       	adiw	r26, 0x10	; 16
    4df8:	1d 92       	st	X+, r1
    4dfa:	1c 92       	st	X, r1
    4dfc:	51 97       	sbiw	r26, 0x11	; 17
    _ReadData       = 0;
    4dfe:	53 96       	adiw	r26, 0x13	; 19
    4e00:	1d 92       	st	X+, r1
    4e02:	1c 92       	st	X, r1
    4e04:	54 97       	sbiw	r26, 0x14	; 20
    _wrBufferLen    = 0;
    4e06:	52 96       	adiw	r26, 0x12	; 18
    4e08:	1c 92       	st	X, r1
    4e0a:	52 97       	sbiw	r26, 0x12	; 18
    _rdBufferLen    = 0;
    4e0c:	55 96       	adiw	r26, 0x15	; 21
    4e0e:	1c 92       	st	X, r1
    4e10:	55 97       	sbiw	r26, 0x15	; 21
    _DeviceID       = 0;
    4e12:	1b 96       	adiw	r26, 0x0b	; 11
    4e14:	1c 92       	st	X, r1
    4e16:	1b 97       	sbiw	r26, 0x0b	; 11
    _nBytesWritten  = 0;
    4e18:	1c 96       	adiw	r26, 0x0c	; 12
    4e1a:	1c 92       	st	X, r1
    4e1c:	1c 97       	sbiw	r26, 0x0c	; 12
    _nWriteBytes    = 0;
    4e1e:	1d 96       	adiw	r26, 0x0d	; 13
    4e20:	1c 92       	st	X, r1
    4e22:	1d 97       	sbiw	r26, 0x0d	; 13
    _nReadBytes     = 0;
    4e24:	1e 96       	adiw	r26, 0x0e	; 14
    4e26:	1c 92       	st	X, r1
    4e28:	1e 97       	sbiw	r26, 0x0e	; 14
    _nBytesRead     = 0;
    4e2a:	1f 96       	adiw	r26, 0x0f	; 15
    4e2c:	1c 92       	st	X, r1
    4e2e:	1f 97       	sbiw	r26, 0x0f	; 15
    _pReserved      = 0;
    4e30:	17 96       	adiw	r26, 0x07	; 7
    4e32:	1d 92       	st	X+, r1
    4e34:	1c 92       	st	X, r1
    4e36:	18 97       	sbiw	r26, 0x08	; 8
    _pNotifyClient  = 0;
    4e38:	19 96       	adiw	r26, 0x09	; 9
    4e3a:	1d 92       	st	X+, r1
    4e3c:	1c 92       	st	X, r1
    4e3e:	1a 97       	sbiw	r26, 0x0a	; 10

    _ScanComplete = 0;
    4e40:	a9 56       	subi	r26, 0x69	; 105
    4e42:	bf 4f       	sbci	r27, 0xFF	; 255
    4e44:	1c 92       	st	X, r1
    4e46:	a7 59       	subi	r26, 0x97	; 151
    4e48:	b0 40       	sbci	r27, 0x00	; 0
    
    //! Set the port so we can force some stop conditions.
#if defined(__AVR_ATxmega128A1__)
    if (twi == &TWIC) {
    4e4a:	84 e0       	ldi	r24, 0x04	; 4
    4e4c:	60 38       	cpi	r22, 0x80	; 128
    4e4e:	78 07       	cpc	r23, r24
    4e50:	19 f4       	brne	.+6      	; 0x4e58 <_ZN10I2C_MasterC1EP10TWI_struct+0x7c>
        _twiPort = &PORTC;
    4e52:	80 e4       	ldi	r24, 0x40	; 64
    4e54:	96 e0       	ldi	r25, 0x06	; 6
    4e56:	0f c0       	rjmp	.+30     	; 0x4e76 <_ZN10I2C_MasterC1EP10TWI_struct+0x9a>
    } else if (twi == &TWID) {
    4e58:	84 e0       	ldi	r24, 0x04	; 4
    4e5a:	60 39       	cpi	r22, 0x90	; 144
    4e5c:	78 07       	cpc	r23, r24
    4e5e:	19 f4       	brne	.+6      	; 0x4e66 <_ZN10I2C_MasterC1EP10TWI_struct+0x8a>
        _twiPort = &PORTD;
    4e60:	80 e6       	ldi	r24, 0x60	; 96
    4e62:	96 e0       	ldi	r25, 0x06	; 6
    4e64:	08 c0       	rjmp	.+16     	; 0x4e76 <_ZN10I2C_MasterC1EP10TWI_struct+0x9a>
    } else if (twi == &TWIE) {
    4e66:	60 5a       	subi	r22, 0xA0	; 160
    4e68:	74 40       	sbci	r23, 0x04	; 4
    4e6a:	19 f4       	brne	.+6      	; 0x4e72 <_ZN10I2C_MasterC1EP10TWI_struct+0x96>
        _twiPort = &PORTE;
    4e6c:	80 e8       	ldi	r24, 0x80	; 128
    4e6e:	96 e0       	ldi	r25, 0x06	; 6
    4e70:	02 c0       	rjmp	.+4      	; 0x4e76 <_ZN10I2C_MasterC1EP10TWI_struct+0x9a>
    } else {
        _twiPort = &PORTF;
    4e72:	80 ea       	ldi	r24, 0xA0	; 160
    4e74:	96 e0       	ldi	r25, 0x06	; 6
    4e76:	12 96       	adiw	r26, 0x02	; 2
    4e78:	8d 93       	st	X+, r24
    4e7a:	9c 93       	st	X, r25
    4e7c:	13 97       	sbiw	r26, 0x03	; 3
    } else {
        _twiPort = &PORTE;
    }
#endif
    
    PORTCFG.MPCMASK = 0x3;
    4e7e:	93 e0       	ldi	r25, 0x03	; 3
    4e80:	90 93 b0 00 	sts	0x00B0, r25
    _twiPort->PIN0CTRL =  
            PORT_OPC_WIREDANDPULL_gc 
          | PORT_ISC_BOTHEDGES_gc;
    4e84:	12 96       	adiw	r26, 0x02	; 2
    4e86:	ed 91       	ld	r30, X+
    4e88:	fc 91       	ld	r31, X
    4e8a:	13 97       	sbiw	r26, 0x03	; 3
    4e8c:	88 e3       	ldi	r24, 0x38	; 56
    4e8e:	80 8b       	std	Z+16, r24	; 0x10
    _twiPort->DIRSET = 0x3;
    4e90:	12 96       	adiw	r26, 0x02	; 2
    4e92:	ed 91       	ld	r30, X+
    4e94:	fc 91       	ld	r31, X
    4e96:	13 97       	sbiw	r26, 0x03	; 3
    4e98:	91 83       	std	Z+1, r25	; 0x01
    _twiPort->OUTSET = 0x3; // Set both high, let float.
    4e9a:	12 96       	adiw	r26, 0x02	; 2
    4e9c:	ed 91       	ld	r30, X+
    4e9e:	fc 91       	ld	r31, X
    4ea0:	13 97       	sbiw	r26, 0x03	; 3
    4ea2:	95 83       	std	Z+5, r25	; 0x05

    SetTWIPointer(_twi,this);
    4ea4:	8d 91       	ld	r24, X+
    4ea6:	9c 91       	ld	r25, X
    4ea8:	11 97       	sbiw	r26, 0x01	; 1
    4eaa:	bd 01       	movw	r22, r26
    4eac:	0e 94 07 21 	call	0x420e	; 0x420e <_ZL13SetTWIPointerP10TWI_structP10I2C_Master>
    if (pdbgserial) pdbgserial->println("I2C Master Constructor.");
    4eb0:	80 91 2a 26 	lds	r24, 0x262A
    4eb4:	90 91 2b 26 	lds	r25, 0x262B
    4eb8:	00 97       	sbiw	r24, 0x00	; 0
    4eba:	21 f0       	breq	.+8      	; 0x4ec4 <_ZN10I2C_MasterC1EP10TWI_struct+0xe8>
    4ebc:	68 e4       	ldi	r22, 0x48	; 72
    4ebe:	74 e2       	ldi	r23, 0x24	; 36
    4ec0:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    4ec4:	08 95       	ret

00004ec6 <_ZN10I2C_MasterC2EP10TWI_struct>:
    } else if (ptype ==  &TWIE) {
        TWIE_master_cp = pm;
    }
}

I2C_Master::I2C_Master(TWI_t* twi)
    4ec6:	dc 01       	movw	r26, r24
{
    _twi        = twi;
    4ec8:	6d 93       	st	X+, r22
    4eca:	7c 93       	st	X, r23
    4ecc:	11 97       	sbiw	r26, 0x01	; 1
    _bEnabled   = false;
    4ece:	14 96       	adiw	r26, 0x04	; 4
    4ed0:	1c 92       	st	X, r1
    4ed2:	14 97       	sbiw	r26, 0x04	; 4
    _State      = sIdle;
    4ed4:	15 96       	adiw	r26, 0x05	; 5
    4ed6:	1c 92       	st	X, r1
    4ed8:	15 97       	sbiw	r26, 0x05	; 5
    _Result     = rOk;
    4eda:	16 96       	adiw	r26, 0x06	; 6
    4edc:	1c 92       	st	X, r1
    4ede:	16 97       	sbiw	r26, 0x06	; 6

    _WriteData      = 0;
    4ee0:	50 96       	adiw	r26, 0x10	; 16
    4ee2:	1d 92       	st	X+, r1
    4ee4:	1c 92       	st	X, r1
    4ee6:	51 97       	sbiw	r26, 0x11	; 17
    _ReadData       = 0;
    4ee8:	53 96       	adiw	r26, 0x13	; 19
    4eea:	1d 92       	st	X+, r1
    4eec:	1c 92       	st	X, r1
    4eee:	54 97       	sbiw	r26, 0x14	; 20
    _wrBufferLen    = 0;
    4ef0:	52 96       	adiw	r26, 0x12	; 18
    4ef2:	1c 92       	st	X, r1
    4ef4:	52 97       	sbiw	r26, 0x12	; 18
    _rdBufferLen    = 0;
    4ef6:	55 96       	adiw	r26, 0x15	; 21
    4ef8:	1c 92       	st	X, r1
    4efa:	55 97       	sbiw	r26, 0x15	; 21
    _DeviceID       = 0;
    4efc:	1b 96       	adiw	r26, 0x0b	; 11
    4efe:	1c 92       	st	X, r1
    4f00:	1b 97       	sbiw	r26, 0x0b	; 11
    _nBytesWritten  = 0;
    4f02:	1c 96       	adiw	r26, 0x0c	; 12
    4f04:	1c 92       	st	X, r1
    4f06:	1c 97       	sbiw	r26, 0x0c	; 12
    _nWriteBytes    = 0;
    4f08:	1d 96       	adiw	r26, 0x0d	; 13
    4f0a:	1c 92       	st	X, r1
    4f0c:	1d 97       	sbiw	r26, 0x0d	; 13
    _nReadBytes     = 0;
    4f0e:	1e 96       	adiw	r26, 0x0e	; 14
    4f10:	1c 92       	st	X, r1
    4f12:	1e 97       	sbiw	r26, 0x0e	; 14
    _nBytesRead     = 0;
    4f14:	1f 96       	adiw	r26, 0x0f	; 15
    4f16:	1c 92       	st	X, r1
    4f18:	1f 97       	sbiw	r26, 0x0f	; 15
    _pReserved      = 0;
    4f1a:	17 96       	adiw	r26, 0x07	; 7
    4f1c:	1d 92       	st	X+, r1
    4f1e:	1c 92       	st	X, r1
    4f20:	18 97       	sbiw	r26, 0x08	; 8
    _pNotifyClient  = 0;
    4f22:	19 96       	adiw	r26, 0x09	; 9
    4f24:	1d 92       	st	X+, r1
    4f26:	1c 92       	st	X, r1
    4f28:	1a 97       	sbiw	r26, 0x0a	; 10

    _ScanComplete = 0;
    4f2a:	a9 56       	subi	r26, 0x69	; 105
    4f2c:	bf 4f       	sbci	r27, 0xFF	; 255
    4f2e:	1c 92       	st	X, r1
    4f30:	a7 59       	subi	r26, 0x97	; 151
    4f32:	b0 40       	sbci	r27, 0x00	; 0
    
    //! Set the port so we can force some stop conditions.
#if defined(__AVR_ATxmega128A1__)
    if (twi == &TWIC) {
    4f34:	84 e0       	ldi	r24, 0x04	; 4
    4f36:	60 38       	cpi	r22, 0x80	; 128
    4f38:	78 07       	cpc	r23, r24
    4f3a:	19 f4       	brne	.+6      	; 0x4f42 <_ZN10I2C_MasterC2EP10TWI_struct+0x7c>
        _twiPort = &PORTC;
    4f3c:	80 e4       	ldi	r24, 0x40	; 64
    4f3e:	96 e0       	ldi	r25, 0x06	; 6
    4f40:	0f c0       	rjmp	.+30     	; 0x4f60 <_ZN10I2C_MasterC2EP10TWI_struct+0x9a>
    } else if (twi == &TWID) {
    4f42:	84 e0       	ldi	r24, 0x04	; 4
    4f44:	60 39       	cpi	r22, 0x90	; 144
    4f46:	78 07       	cpc	r23, r24
    4f48:	19 f4       	brne	.+6      	; 0x4f50 <_ZN10I2C_MasterC2EP10TWI_struct+0x8a>
        _twiPort = &PORTD;
    4f4a:	80 e6       	ldi	r24, 0x60	; 96
    4f4c:	96 e0       	ldi	r25, 0x06	; 6
    4f4e:	08 c0       	rjmp	.+16     	; 0x4f60 <_ZN10I2C_MasterC2EP10TWI_struct+0x9a>
    } else if (twi == &TWIE) {
    4f50:	60 5a       	subi	r22, 0xA0	; 160
    4f52:	74 40       	sbci	r23, 0x04	; 4
    4f54:	19 f4       	brne	.+6      	; 0x4f5c <_ZN10I2C_MasterC2EP10TWI_struct+0x96>
        _twiPort = &PORTE;
    4f56:	80 e8       	ldi	r24, 0x80	; 128
    4f58:	96 e0       	ldi	r25, 0x06	; 6
    4f5a:	02 c0       	rjmp	.+4      	; 0x4f60 <_ZN10I2C_MasterC2EP10TWI_struct+0x9a>
    } else {
        _twiPort = &PORTF;
    4f5c:	80 ea       	ldi	r24, 0xA0	; 160
    4f5e:	96 e0       	ldi	r25, 0x06	; 6
    4f60:	12 96       	adiw	r26, 0x02	; 2
    4f62:	8d 93       	st	X+, r24
    4f64:	9c 93       	st	X, r25
    4f66:	13 97       	sbiw	r26, 0x03	; 3
    } else {
        _twiPort = &PORTE;
    }
#endif
    
    PORTCFG.MPCMASK = 0x3;
    4f68:	83 e0       	ldi	r24, 0x03	; 3
    4f6a:	80 93 b0 00 	sts	0x00B0, r24
    _twiPort->PIN0CTRL =  
            PORT_OPC_WIREDANDPULL_gc 
          | PORT_ISC_BOTHEDGES_gc;
    4f6e:	12 96       	adiw	r26, 0x02	; 2
    4f70:	ed 91       	ld	r30, X+
    4f72:	fc 91       	ld	r31, X
    4f74:	13 97       	sbiw	r26, 0x03	; 3
    4f76:	98 e3       	ldi	r25, 0x38	; 56
    4f78:	90 8b       	std	Z+16, r25	; 0x10
    _twiPort->DIRSET = 0x3;
    4f7a:	81 83       	std	Z+1, r24	; 0x01
    _twiPort->OUTSET = 0x3; // Set both high, let float.
    4f7c:	85 83       	std	Z+5, r24	; 0x05

    SetTWIPointer(_twi,this);
    4f7e:	8d 91       	ld	r24, X+
    4f80:	9c 91       	ld	r25, X
    4f82:	11 97       	sbiw	r26, 0x01	; 1
    4f84:	bd 01       	movw	r22, r26
    4f86:	0e 94 07 21 	call	0x420e	; 0x420e <_ZL13SetTWIPointerP10TWI_structP10I2C_Master>
    if (pdbgserial) pdbgserial->println("I2C Master Constructor.");
    4f8a:	80 91 2a 26 	lds	r24, 0x262A
    4f8e:	90 91 2b 26 	lds	r25, 0x262B
    4f92:	00 97       	sbiw	r24, 0x00	; 0
    4f94:	21 f0       	breq	.+8      	; 0x4f9e <_ZN10I2C_MasterC2EP10TWI_struct+0xd8>
    4f96:	68 e4       	ldi	r22, 0x48	; 72
    4f98:	74 e2       	ldi	r23, 0x24	; 36
    4f9a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
    4f9e:	08 95       	ret

00004fa0 <_ZN10I2C_Master8ReadDataEPhh>:
        return _ReadData[idx];
    }
    return 0;
}

uint8_t I2C_Master::ReadData(uint8_t* pData, uint8_t maxcnt)
    4fa0:	1f 93       	push	r17
    4fa2:	fc 01       	movw	r30, r24
    4fa4:	26 2f       	mov	r18, r22
    4fa6:	97 2f       	mov	r25, r23
{
    if (_State == sIdle && _Result == rOk) {
    4fa8:	85 81       	ldd	r24, Z+5	; 0x05
    4faa:	88 23       	and	r24, r24
    4fac:	81 f4       	brne	.+32     	; 0x4fce <_ZN10I2C_Master8ReadDataEPhh+0x2e>
    4fae:	86 81       	ldd	r24, Z+6	; 0x06
    4fb0:	88 23       	and	r24, r24
    4fb2:	69 f4       	brne	.+26     	; 0x4fce <_ZN10I2C_Master8ReadDataEPhh+0x2e>
    4fb4:	87 85       	ldd	r24, Z+15	; 0x0f
    4fb6:	14 2f       	mov	r17, r20
    4fb8:	84 17       	cp	r24, r20
    4fba:	08 f4       	brcc	.+2      	; 0x4fbe <_ZN10I2C_Master8ReadDataEPhh+0x1e>
    4fbc:	18 2f       	mov	r17, r24
        uint8_t nCopy = maxcnt <= _nBytesRead ?
            maxcnt : _nBytesRead;
        memcpy(pData,_ReadData,nCopy);
    4fbe:	63 89       	ldd	r22, Z+19	; 0x13
    4fc0:	74 89       	ldd	r23, Z+20	; 0x14
    4fc2:	82 2f       	mov	r24, r18
    4fc4:	41 2f       	mov	r20, r17
    4fc6:	50 e0       	ldi	r21, 0x00	; 0
    4fc8:	0e 94 37 4b 	call	0x966e	; 0x966e <memcpy>
    4fcc:	01 c0       	rjmp	.+2      	; 0x4fd0 <_ZN10I2C_Master8ReadDataEPhh+0x30>
        return nCopy;
    4fce:	10 e0       	ldi	r17, 0x00	; 0
    }
    return 0;
}
    4fd0:	81 2f       	mov	r24, r17
    4fd2:	1f 91       	pop	r17
    4fd4:	08 95       	ret

00004fd6 <_ZN10I2C_Master9WriteReadEhPhhh>:
}

I2C_Master::ErrorType I2C_Master::WriteRead(  uint8_t ID,
                            uint8_t* wrData,
                            uint8_t nWriteBytes,
                            uint8_t nReadBytes)
    4fd6:	df 92       	push	r13
    4fd8:	ef 92       	push	r14
    4fda:	ff 92       	push	r15
    4fdc:	0f 93       	push	r16
    4fde:	1f 93       	push	r17
    4fe0:	cf 93       	push	r28
    4fe2:	df 93       	push	r29
    4fe4:	ec 01       	movw	r28, r24
    4fe6:	16 2f       	mov	r17, r22
    4fe8:	e4 2e       	mov	r14, r20
    4fea:	d5 2e       	mov	r13, r21
    4fec:	f2 2e       	mov	r15, r18
{
    if (_bEnabled == false) return eDisabled;
    4fee:	8c 81       	ldd	r24, Y+4	; 0x04
    4ff0:	88 23       	and	r24, r24
    4ff2:	11 f4       	brne	.+4      	; 0x4ff8 <_ZN10I2C_Master9WriteReadEhPhhh+0x22>
    4ff4:	8f ef       	ldi	r24, 0xFF	; 255
    4ff6:	42 c0       	rjmp	.+132    	; 0x507c <_ZN10I2C_Master9WriteReadEhPhhh+0xa6>
    return _nBytesRead; 
}

bool I2C_Master::busy()
{
    if (_State != sIdle) return true;
    4ff8:	8d 81       	ldd	r24, Y+5	; 0x05
    4ffa:	88 23       	and	r24, r24
    4ffc:	09 f4       	brne	.+2      	; 0x5000 <_ZN10I2C_Master9WriteReadEhPhhh+0x2a>
    4ffe:	46 c0       	rjmp	.+140    	; 0x508c <_ZN10I2C_Master9WriteReadEhPhhh+0xb6>
    5000:	8e ef       	ldi	r24, 0xFE	; 254
    5002:	3c c0       	rjmp	.+120    	; 0x507c <_ZN10I2C_Master9WriteReadEhPhhh+0xa6>
{
    if (_bEnabled == false) return eDisabled;
    if (busy()) return eBusy;

    if (nWriteBytes > _wrBufferLen) {
        free(_WriteData);
    5004:	88 89       	ldd	r24, Y+16	; 0x10
    5006:	99 89       	ldd	r25, Y+17	; 0x11
    5008:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
        _WriteData = (uint8_t*)malloc(nWriteBytes+1);
    500c:	8f 2d       	mov	r24, r15
    500e:	90 e0       	ldi	r25, 0x00	; 0
    5010:	01 96       	adiw	r24, 0x01	; 1
    5012:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    5016:	88 8b       	std	Y+16, r24	; 0x10
    5018:	99 8b       	std	Y+17, r25	; 0x11
        _wrBufferLen = nWriteBytes;
    501a:	fa 8a       	std	Y+18, r15	; 0x12
        //if (pdbgserial) pdbgserial->println("Allocated write buffer.");
    }
    memcpy(_WriteData,wrData,nWriteBytes);
    501c:	88 89       	ldd	r24, Y+16	; 0x10
    501e:	99 89       	ldd	r25, Y+17	; 0x11
    5020:	6e 2d       	mov	r22, r14
    5022:	7d 2d       	mov	r23, r13
    5024:	4f 2d       	mov	r20, r15
    5026:	50 e0       	ldi	r21, 0x00	; 0
    5028:	0e 94 37 4b 	call	0x966e	; 0x966e <memcpy>
    _nBytesWritten  = 0;
    502c:	1c 86       	std	Y+12, r1	; 0x0c
    _nWriteBytes    = nWriteBytes;
    502e:	fd 86       	std	Y+13, r15	; 0x0d

    if (nReadBytes > _rdBufferLen) {
    5030:	8d 89       	ldd	r24, Y+21	; 0x15
    5032:	80 17       	cp	r24, r16
    5034:	60 f4       	brcc	.+24     	; 0x504e <_ZN10I2C_Master9WriteReadEhPhhh+0x78>
        free(_ReadData);
    5036:	8b 89       	ldd	r24, Y+19	; 0x13
    5038:	9c 89       	ldd	r25, Y+20	; 0x14
    503a:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
        _ReadData = (uint8_t*)malloc(nReadBytes+1);
    503e:	80 2f       	mov	r24, r16
    5040:	90 e0       	ldi	r25, 0x00	; 0
    5042:	01 96       	adiw	r24, 0x01	; 1
    5044:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    5048:	8b 8b       	std	Y+19, r24	; 0x13
    504a:	9c 8b       	std	Y+20, r25	; 0x14
        _rdBufferLen = nReadBytes;
    504c:	0d 8b       	std	Y+21, r16	; 0x15
        //if (pdbgserial) pdbgserial->println("Allocated read buffer.");
    }
    _nBytesRead     = 0;
    504e:	1f 86       	std	Y+15, r1	; 0x0f
    _nReadBytes     = nReadBytes;
    5050:	0e 87       	std	Y+14, r16	; 0x0e

    _Result     = rUnknown;
    5052:	86 e0       	ldi	r24, 0x06	; 6
    5054:	8e 83       	std	Y+6, r24	; 0x06

    _DeviceID   = ID;
    5056:	1b 87       	std	Y+11, r17	; 0x0b

    if (_nWriteBytes > 0) {
    5058:	8d 85       	ldd	r24, Y+13	; 0x0d
    505a:	88 23       	and	r24, r24
    505c:	21 f0       	breq	.+8      	; 0x5066 <_ZN10I2C_Master9WriteReadEhPhhh+0x90>
        // Start the write transaction..
        uint8_t addr = _DeviceID & ~0x1; // Write
    505e:	1e 7f       	andi	r17, 0xFE	; 254
        _twi->MASTER.ADDR = addr;
    5060:	e8 81       	ld	r30, Y
    5062:	f9 81       	ldd	r31, Y+1	; 0x01
    5064:	07 c0       	rjmp	.+14     	; 0x5074 <_ZN10I2C_Master9WriteReadEhPhhh+0x9e>
    5066:	e8 81       	ld	r30, Y
    5068:	f9 81       	ldd	r31, Y+1	; 0x01
    } else if (_nReadBytes) {
    506a:	00 23       	and	r16, r16
    506c:	11 f0       	breq	.+4      	; 0x5072 <_ZN10I2C_Master9WriteReadEhPhhh+0x9c>
        uint8_t addr = _DeviceID | 0x1; // Read
    506e:	11 60       	ori	r17, 0x01	; 1
    5070:	01 c0       	rjmp	.+2      	; 0x5074 <_ZN10I2C_Master9WriteReadEhPhhh+0x9e>
        _twi->MASTER.ADDR = addr;
    } else {
        // Nothing to write, but we are pinging the ID
        uint8_t addr = _DeviceID & ~0x1; // Write
    5072:	1e 7f       	andi	r17, 0xFE	; 254
        _twi->MASTER.ADDR = addr;
    5074:	16 83       	std	Z+6, r17	; 0x06
    }
    _State      = sBusy;
    5076:	81 e0       	ldi	r24, 0x01	; 1
    5078:	8d 83       	std	Y+5, r24	; 0x05
    507a:	80 e0       	ldi	r24, 0x00	; 0

    return eNone;
}
    507c:	df 91       	pop	r29
    507e:	cf 91       	pop	r28
    5080:	1f 91       	pop	r17
    5082:	0f 91       	pop	r16
    5084:	ff 90       	pop	r15
    5086:	ef 90       	pop	r14
    5088:	df 90       	pop	r13
    508a:	08 95       	ret
                            uint8_t nReadBytes)
{
    if (_bEnabled == false) return eDisabled;
    if (busy()) return eBusy;

    if (nWriteBytes > _wrBufferLen) {
    508c:	8a 89       	ldd	r24, Y+18	; 0x12
    508e:	82 17       	cp	r24, r18
    5090:	28 f6       	brcc	.-118    	; 0x501c <_ZN10I2C_Master9WriteReadEhPhhh+0x46>
    5092:	b8 cf       	rjmp	.-144    	; 0x5004 <_ZN10I2C_Master9WriteReadEhPhhh+0x2e>

00005094 <_ZN10I2C_Master13WriteReadSyncEhPhhh>:
}

I2C_Master::ErrorType I2C_Master::WriteReadSync(  uint8_t ID,
                            uint8_t* wrData,
                            uint8_t nWriteBytes,
                            uint8_t nReadBytes)
    5094:	0f 93       	push	r16
    5096:	cf 93       	push	r28
    5098:	df 93       	push	r29
    509a:	ec 01       	movw	r28, r24
{
    //if (pdbgserial) pdbgserial->println("Start=========== Sending Async Version.");
    //sprintf(buffer,"nWriteBytes:%d nReadBytes:%d\n",nWriteBytes, nReadBytes);
    //if (pdbgserial) pdbgserial->print(buffer);
    ErrorType retc = WriteRead(ID, wrData, nWriteBytes, nReadBytes);
    509c:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <_ZN10I2C_Master9WriteReadEhPhhh>
    50a0:	38 2f       	mov	r19, r24

    if (retc != eNone) return retc;
    50a2:	88 23       	and	r24, r24
    50a4:	21 f5       	brne	.+72     	; 0x50ee <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x5a>
    50a6:	24 e6       	ldi	r18, 0x64	; 100
    50a8:	40 e2       	ldi	r20, 0x20	; 32
    50aa:	53 e0       	ldi	r21, 0x03	; 3

    uint8_t timeout = 100;
    while (--timeout && _State != sIdle) {
    50ac:	21 50       	subi	r18, 0x01	; 1
    50ae:	39 f0       	breq	.+14     	; 0x50be <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x2a>
    50b0:	8d 81       	ldd	r24, Y+5	; 0x05
    50b2:	88 23       	and	r24, r24
    50b4:	09 f1       	breq	.+66     	; 0x50f8 <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x64>
    50b6:	ca 01       	movw	r24, r20
    50b8:	01 97       	sbiw	r24, 0x01	; 1
    50ba:	f1 f7       	brne	.-4      	; 0x50b8 <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x24>
    50bc:	f7 cf       	rjmp	.-18     	; 0x50ac <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x18>
        _delay_us(100); // Busy Wait..
    }

    // If a timeout occured, close the transaction and return an error.
    if (timeout == 0) {
        if (pdbgserial) pdbgserial->println("Wait Timeout.");
    50be:	80 91 2a 26 	lds	r24, 0x262A
    50c2:	90 91 2b 26 	lds	r25, 0x262B
    50c6:	00 97       	sbiw	r24, 0x00	; 0
    50c8:	21 f0       	breq	.+8      	; 0x50d2 <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x3e>
    50ca:	60 e6       	ldi	r22, 0x60	; 96
    50cc:	74 e2       	ldi	r23, 0x24	; 36
    50ce:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
        _Result = rTimeout;
    50d2:	87 e0       	ldi	r24, 0x07	; 7
    50d4:	8e 83       	std	Y+6, r24	; 0x06
        _State  = sIdle;
    50d6:	1d 82       	std	Y+5, r1	; 0x05
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    50d8:	e8 81       	ld	r30, Y
    50da:	f9 81       	ldd	r31, Y+1	; 0x01
    50dc:	83 e0       	ldi	r24, 0x03	; 3
    50de:	83 83       	std	Z+3, r24	; 0x03
    50e0:	3a ef       	ldi	r19, 0xFA	; 250
    50e2:	05 c0       	rjmp	.+10     	; 0x50ee <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x5a>
        return  eTimeout;
    }

    // The transaction completed, but was it right?
    if (_Result != rOk) {
        if (_Result == rNack) {
    50e4:	84 30       	cpi	r24, 0x04	; 4
    50e6:	11 f0       	breq	.+4      	; 0x50ec <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x58>
    50e8:	37 ef       	ldi	r19, 0xF7	; 247
    50ea:	01 c0       	rjmp	.+2      	; 0x50ee <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x5a>
    50ec:	3d ef       	ldi	r19, 0xFD	; 253
            retc = eUnknown;
        }
    }
    
    return retc;
}
    50ee:	83 2f       	mov	r24, r19
    50f0:	df 91       	pop	r29
    50f2:	cf 91       	pop	r28
    50f4:	0f 91       	pop	r16
    50f6:	08 95       	ret
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
        return  eTimeout;
    }

    // The transaction completed, but was it right?
    if (_Result != rOk) {
    50f8:	8e 81       	ldd	r24, Y+6	; 0x06
    50fa:	88 23       	and	r24, r24
    50fc:	99 f7       	brne	.-26     	; 0x50e4 <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x50>
    50fe:	f7 cf       	rjmp	.-18     	; 0x50ee <_ZN10I2C_Master13WriteReadSyncEhPhhh+0x5a>

00005100 <_ZN10I2C_Master8ReadSyncEhh>:
I2C_Master::ErrorType I2C_Master::Read(uint8_t ID, uint8_t nRdBytes)
{
    return WriteRead(ID, 0, 0, nRdBytes);
}

I2C_Master::ErrorType I2C_Master::ReadSync(uint8_t ID, uint8_t nRdBytes)
    5100:	0f 93       	push	r16
    5102:	04 2f       	mov	r16, r20
{
    return WriteReadSync(ID, 0, 0, nRdBytes);
    5104:	40 e0       	ldi	r20, 0x00	; 0
    5106:	50 e0       	ldi	r21, 0x00	; 0
    5108:	20 e0       	ldi	r18, 0x00	; 0
    510a:	0e 94 4a 28 	call	0x5094	; 0x5094 <_ZN10I2C_Master13WriteReadSyncEhPhhh>
}
    510e:	0f 91       	pop	r16
    5110:	08 95       	ret

00005112 <_ZN10I2C_Master9WriteSyncEhPhh>:
I2C_Master::ErrorType I2C_Master::Write(uint8_t ID, uint8_t* pData, uint8_t nWrBytes)
{
    return WriteRead(ID, pData, nWrBytes, 0);
}

I2C_Master::ErrorType I2C_Master::WriteSync(uint8_t ID, uint8_t* pData, uint8_t nWrBytes)
    5112:	0f 93       	push	r16
{
    return WriteReadSync(ID, pData, nWrBytes, 0);
    5114:	00 e0       	ldi	r16, 0x00	; 0
    5116:	0e 94 4a 28 	call	0x5094	; 0x5094 <_ZN10I2C_Master13WriteReadSyncEhPhhh>
}
    511a:	0f 91       	pop	r16
    511c:	08 95       	ret

0000511e <_ZN10I2C_Master4ReadEhh>:

I2C_Master::ErrorType I2C_Master::Read(uint8_t ID, uint8_t nRdBytes)
    511e:	0f 93       	push	r16
    5120:	04 2f       	mov	r16, r20
{
    return WriteRead(ID, 0, 0, nRdBytes);
    5122:	40 e0       	ldi	r20, 0x00	; 0
    5124:	50 e0       	ldi	r21, 0x00	; 0
    5126:	20 e0       	ldi	r18, 0x00	; 0
    5128:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <_ZN10I2C_Master9WriteReadEhPhhh>
}
    512c:	0f 91       	pop	r16
    512e:	08 95       	ret

00005130 <_ZN10I2C_Master5WriteEhPhh>:
}

// Copy the bytes to be sent into the send buffer, then
// start sending a byte at a time. The interrupt will
// be used to make this call asynchronous.
I2C_Master::ErrorType I2C_Master::Write(uint8_t ID, uint8_t* pData, uint8_t nWrBytes)
    5130:	0f 93       	push	r16
{
    return WriteRead(ID, pData, nWrBytes, 0);
    5132:	00 e0       	ldi	r16, 0x00	; 0
    5134:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <_ZN10I2C_Master9WriteReadEhPhhh>
}
    5138:	0f 91       	pop	r16
    513a:	08 95       	ret

0000513c <_ZN10I2C_Master7CheckIDEh>:
uint8_t I2C_Master::busState()
{
    return (_twi->MASTER.STATUS & TWI_MASTER_BUSSTATE_gm);
}

I2C_Master::ErrorType I2C_Master::CheckID(uint8_t ID)
    513c:	df 92       	push	r13
    513e:	ef 92       	push	r14
    5140:	ff 92       	push	r15
    5142:	0f 93       	push	r16
    5144:	1f 93       	push	r17
    5146:	df 93       	push	r29
    5148:	cf 93       	push	r28
    514a:	cd b7       	in	r28, 0x3d	; 61
    514c:	de b7       	in	r29, 0x3e	; 62
    514e:	c0 58       	subi	r28, 0x80	; 128
    5150:	d0 40       	sbci	r29, 0x00	; 0
    5152:	cd bf       	out	0x3d, r28	; 61
    5154:	de bf       	out	0x3e, r29	; 62
    5156:	8c 01       	movw	r16, r24
    5158:	d6 2e       	mov	r13, r22
{
    char buffer[128];
    sprintf(buffer,"Check id 0x%x",ID);
    515a:	00 d0       	rcall	.+0      	; 0x515c <_ZN10I2C_Master7CheckIDEh+0x20>
    515c:	00 d0       	rcall	.+0      	; 0x515e <_ZN10I2C_Master7CheckIDEh+0x22>
    515e:	ed b7       	in	r30, 0x3d	; 61
    5160:	fe b7       	in	r31, 0x3e	; 62
    5162:	31 96       	adiw	r30, 0x01	; 1
    5164:	7e 01       	movw	r14, r28
    5166:	08 94       	sec
    5168:	e1 1c       	adc	r14, r1
    516a:	f1 1c       	adc	r15, r1
    516c:	ad b7       	in	r26, 0x3d	; 61
    516e:	be b7       	in	r27, 0x3e	; 62
    5170:	11 96       	adiw	r26, 0x01	; 1
    5172:	ed 92       	st	X+, r14
    5174:	fc 92       	st	X, r15
    5176:	12 97       	sbiw	r26, 0x02	; 2
    5178:	8e e6       	ldi	r24, 0x6E	; 110
    517a:	94 e2       	ldi	r25, 0x24	; 36
    517c:	82 83       	std	Z+2, r24	; 0x02
    517e:	93 83       	std	Z+3, r25	; 0x03
    5180:	64 83       	std	Z+4, r22	; 0x04
    5182:	15 82       	std	Z+5, r1	; 0x05
    5184:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    if (pdbgserial) pdbgserial->println(buffer);
    5188:	80 91 2a 26 	lds	r24, 0x262A
    518c:	90 91 2b 26 	lds	r25, 0x262B
    5190:	ed b7       	in	r30, 0x3d	; 61
    5192:	fe b7       	in	r31, 0x3e	; 62
    5194:	36 96       	adiw	r30, 0x06	; 6
    5196:	ed bf       	out	0x3d, r30	; 61
    5198:	fe bf       	out	0x3e, r31	; 62
    519a:	00 97       	sbiw	r24, 0x00	; 0
    519c:	19 f0       	breq	.+6      	; 0x51a4 <_ZN10I2C_Master7CheckIDEh+0x68>
    519e:	b7 01       	movw	r22, r14
    51a0:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>

    //showstate();

    ErrorType retc;
    if ((retc = Write(ID,0,0)) < 0) {
    51a4:	c8 01       	movw	r24, r16
    51a6:	6d 2d       	mov	r22, r13
    51a8:	40 e0       	ldi	r20, 0x00	; 0
    51aa:	50 e0       	ldi	r21, 0x00	; 0
    51ac:	20 e0       	ldi	r18, 0x00	; 0
    51ae:	0e 94 98 28 	call	0x5130	; 0x5130 <_ZN10I2C_Master5WriteEhPhh>
    51b2:	87 fd       	sbrc	r24, 7
    51b4:	28 c0       	rjmp	.+80     	; 0x5206 <_ZN10I2C_Master7CheckIDEh+0xca>
    51b6:	24 e6       	ldi	r18, 0x64	; 100
    51b8:	40 e2       	ldi	r20, 0x20	; 32
    51ba:	53 e0       	ldi	r21, 0x03	; 3
    }

    //showstate();

    uint8_t timeout = 100;
    while (--timeout && _State != sIdle) {
    51bc:	21 50       	subi	r18, 0x01	; 1
    51be:	49 f0       	breq	.+18     	; 0x51d2 <_ZN10I2C_Master7CheckIDEh+0x96>
    51c0:	d8 01       	movw	r26, r16
    51c2:	15 96       	adiw	r26, 0x05	; 5
    51c4:	8c 91       	ld	r24, X
    51c6:	88 23       	and	r24, r24
    51c8:	51 f1       	breq	.+84     	; 0x521e <_ZN10I2C_Master7CheckIDEh+0xe2>
    51ca:	ca 01       	movw	r24, r20
    51cc:	01 97       	sbiw	r24, 0x01	; 1
    51ce:	f1 f7       	brne	.-4      	; 0x51cc <_ZN10I2C_Master7CheckIDEh+0x90>
    51d0:	f5 cf       	rjmp	.-22     	; 0x51bc <_ZN10I2C_Master7CheckIDEh+0x80>
    }

    //showstate();

    if (timeout == 0) {
        if (pdbgserial) pdbgserial->println("Timeout waiting for completion of command.");
    51d2:	80 91 2a 26 	lds	r24, 0x262A
    51d6:	90 91 2b 26 	lds	r25, 0x262B
    51da:	00 97       	sbiw	r24, 0x00	; 0
    51dc:	21 f0       	breq	.+8      	; 0x51e6 <_ZN10I2C_Master7CheckIDEh+0xaa>
    51de:	6c e7       	ldi	r22, 0x7C	; 124
    51e0:	74 e2       	ldi	r23, 0x24	; 36
    51e2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <_ZN5Print7printlnEPKc>
        _Result = rTimeout;
    51e6:	87 e0       	ldi	r24, 0x07	; 7
    51e8:	f8 01       	movw	r30, r16
    51ea:	86 83       	std	Z+6, r24	; 0x06
        _State  = sIdle;
    51ec:	15 82       	std	Z+5, r1	; 0x05
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    51ee:	01 90       	ld	r0, Z+
    51f0:	f0 81       	ld	r31, Z
    51f2:	e0 2d       	mov	r30, r0
    51f4:	83 e0       	ldi	r24, 0x03	; 3
    51f6:	83 83       	std	Z+3, r24	; 0x03
    51f8:	8a ef       	ldi	r24, 0xFA	; 250
    51fa:	05 c0       	rjmp	.+10     	; 0x5206 <_ZN10I2C_Master7CheckIDEh+0xca>
        return  eTimeout;
    } else {
        if (_Result == rOk) {
            return eNone;
        } else if (_Result == rNack) {
    51fc:	84 30       	cpi	r24, 0x04	; 4
    51fe:	11 f0       	breq	.+4      	; 0x5204 <_ZN10I2C_Master7CheckIDEh+0xc8>
    5200:	87 ef       	ldi	r24, 0xF7	; 247
    5202:	01 c0       	rjmp	.+2      	; 0x5206 <_ZN10I2C_Master7CheckIDEh+0xca>
    5204:	8d ef       	ldi	r24, 0xFD	; 253
            return eNack;
        }
    }
    return eUnknown;
}
    5206:	c0 58       	subi	r28, 0x80	; 128
    5208:	df 4f       	sbci	r29, 0xFF	; 255
    520a:	cd bf       	out	0x3d, r28	; 61
    520c:	de bf       	out	0x3e, r29	; 62
    520e:	cf 91       	pop	r28
    5210:	df 91       	pop	r29
    5212:	1f 91       	pop	r17
    5214:	0f 91       	pop	r16
    5216:	ff 90       	pop	r15
    5218:	ef 90       	pop	r14
    521a:	df 90       	pop	r13
    521c:	08 95       	ret
        _Result = rTimeout;
        _State  = sIdle;
        _twi->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
        return  eTimeout;
    } else {
        if (_Result == rOk) {
    521e:	d8 01       	movw	r26, r16
    5220:	16 96       	adiw	r26, 0x06	; 6
    5222:	8c 91       	ld	r24, X
    5224:	88 23       	and	r24, r24
    5226:	79 f3       	breq	.-34     	; 0x5206 <_ZN10I2C_Master7CheckIDEh+0xca>
    5228:	e9 cf       	rjmp	.-46     	; 0x51fc <_ZN10I2C_Master7CheckIDEh+0xc0>

0000522a <_ZdaPv>:
    return malloc(size);
}

void operator delete[](void * ptr)
{
    free(ptr);
    522a:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
} 
    522e:	08 95       	ret

00005230 <_ZdlPv>:
  return malloc(size);
}

void operator delete(void * ptr)
{
  free(ptr);
    5230:	0e 94 95 4a 	call	0x952a	; 0x952a <free>
} 
    5234:	08 95       	ret

00005236 <_Znaj>:

void * operator new[](size_t size)
{
    return malloc(size);
    5236:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
}
    523a:	08 95       	ret

0000523c <_Znwj>:
#include "newdel.h"

void * operator new(size_t size)
{
  return malloc(size);
    523c:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
}
    5240:	08 95       	ret

00005242 <_ZN5Print5writeEPKc>:
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
void Print::write(const char *str)
    5242:	0f 93       	push	r16
    5244:	1f 93       	push	r17
    5246:	cf 93       	push	r28
    5248:	df 93       	push	r29
    524a:	8c 01       	movw	r16, r24
    524c:	eb 01       	movw	r28, r22
    524e:	09 c0       	rjmp	.+18     	; 0x5262 <_ZN5Print5writeEPKc+0x20>
{
  while (*str)
    write(*str++);
    5250:	21 96       	adiw	r28, 0x01	; 1
    5252:	d8 01       	movw	r26, r16
    5254:	ed 91       	ld	r30, X+
    5256:	fc 91       	ld	r31, X
    5258:	01 90       	ld	r0, Z+
    525a:	f0 81       	ld	r31, Z
    525c:	e0 2d       	mov	r30, r0
    525e:	c8 01       	movw	r24, r16
    5260:	19 95       	eicall
// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
void Print::write(const char *str)
{
  while (*str)
    5262:	68 81       	ld	r22, Y
    5264:	66 23       	and	r22, r22
    5266:	a1 f7       	brne	.-24     	; 0x5250 <_ZN5Print5writeEPKc+0xe>
    write(*str++);
}
    5268:	df 91       	pop	r29
    526a:	cf 91       	pop	r28
    526c:	1f 91       	pop	r17
    526e:	0f 91       	pop	r16
    5270:	08 95       	ret

00005272 <_ZN5Print5writeEPKhj>:

/* default implementation: may be overridden */
void Print::write(const uint8_t *buffer, size_t size)
    5272:	ef 92       	push	r14
    5274:	ff 92       	push	r15
    5276:	0f 93       	push	r16
    5278:	1f 93       	push	r17
    527a:	cf 93       	push	r28
    527c:	df 93       	push	r29
    527e:	8c 01       	movw	r16, r24
    5280:	7b 01       	movw	r14, r22
    5282:	ea 01       	movw	r28, r20
    5284:	0c c0       	rjmp	.+24     	; 0x529e <_ZN5Print5writeEPKhj+0x2c>
{
  while (size--)
    write(*buffer++);
    5286:	d7 01       	movw	r26, r14
    5288:	6d 91       	ld	r22, X+
    528a:	7d 01       	movw	r14, r26
    528c:	d8 01       	movw	r26, r16
    528e:	ed 91       	ld	r30, X+
    5290:	fc 91       	ld	r31, X
    5292:	01 90       	ld	r0, Z+
    5294:	f0 81       	ld	r31, Z
    5296:	e0 2d       	mov	r30, r0
    5298:	c8 01       	movw	r24, r16
    529a:	19 95       	eicall
    529c:	21 97       	sbiw	r28, 0x01	; 1
}

/* default implementation: may be overridden */
void Print::write(const uint8_t *buffer, size_t size)
{
  while (size--)
    529e:	20 97       	sbiw	r28, 0x00	; 0
    52a0:	91 f7       	brne	.-28     	; 0x5286 <_ZN5Print5writeEPKhj+0x14>
    write(*buffer++);
}
    52a2:	df 91       	pop	r29
    52a4:	cf 91       	pop	r28
    52a6:	1f 91       	pop	r17
    52a8:	0f 91       	pop	r16
    52aa:	ff 90       	pop	r15
    52ac:	ef 90       	pop	r14
    52ae:	08 95       	ret

000052b0 <_ZN5Print5printEPKc>:

void Print::print(const char str[])
    52b0:	dc 01       	movw	r26, r24
{
  write(str);
    52b2:	ed 91       	ld	r30, X+
    52b4:	fc 91       	ld	r31, X
    52b6:	02 80       	ldd	r0, Z+2	; 0x02
    52b8:	f3 81       	ldd	r31, Z+3	; 0x03
    52ba:	e0 2d       	mov	r30, r0
    52bc:	19 95       	eicall
}
    52be:	08 95       	ret

000052c0 <_ZN5Print11printNumberEmh>:
  println();
}

// Private Methods /////////////////////////////////////////////////////////////

void Print::printNumber(unsigned long n, uint8_t base)
    52c0:	2f 92       	push	r2
    52c2:	3f 92       	push	r3
    52c4:	4f 92       	push	r4
    52c6:	5f 92       	push	r5
    52c8:	6f 92       	push	r6
    52ca:	7f 92       	push	r7
    52cc:	8f 92       	push	r8
    52ce:	9f 92       	push	r9
    52d0:	af 92       	push	r10
    52d2:	bf 92       	push	r11
    52d4:	cf 92       	push	r12
    52d6:	df 92       	push	r13
    52d8:	ef 92       	push	r14
    52da:	ff 92       	push	r15
    52dc:	0f 93       	push	r16
    52de:	1f 93       	push	r17
    52e0:	df 93       	push	r29
    52e2:	cf 93       	push	r28
    52e4:	cd b7       	in	r28, 0x3d	; 61
    52e6:	de b7       	in	r29, 0x3e	; 62
    52e8:	a0 97       	sbiw	r28, 0x20	; 32
    52ea:	cd bf       	out	0x3d, r28	; 61
    52ec:	de bf       	out	0x3e, r29	; 62
    52ee:	1c 01       	movw	r2, r24
    52f0:	6a 01       	movw	r12, r20
    52f2:	7b 01       	movw	r14, r22
{
  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
  unsigned long i = 0;

  if (n == 0) {
    52f4:	41 15       	cp	r20, r1
    52f6:	51 05       	cpc	r21, r1
    52f8:	61 05       	cpc	r22, r1
    52fa:	71 05       	cpc	r23, r1
    52fc:	49 f4       	brne	.+18     	; 0x5310 <_ZN5Print11printNumberEmh+0x50>
  write(str);
}

void Print::print(char c, int base)
{
  print((long) c, base);
    52fe:	40 e3       	ldi	r20, 0x30	; 48
    5300:	50 e0       	ldi	r21, 0x00	; 0
    5302:	60 e0       	ldi	r22, 0x00	; 0
    5304:	70 e0       	ldi	r23, 0x00	; 0
    5306:	20 e0       	ldi	r18, 0x00	; 0
    5308:	30 e0       	ldi	r19, 0x00	; 0
    530a:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
    530e:	54 c0       	rjmp	.+168    	; 0x53b8 <_ZN5Print11printNumberEmh+0xf8>
  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
  unsigned long i = 0;

  if (n == 0) {
    print('0');
    return;
    5310:	88 24       	eor	r8, r8
    5312:	99 24       	eor	r9, r9
    5314:	54 01       	movw	r10, r8
  } 

  while (n > 0) {
    buf[i++] = n % base;
    5316:	42 2e       	mov	r4, r18
    5318:	55 24       	eor	r5, r5
    531a:	66 24       	eor	r6, r6
    531c:	77 24       	eor	r7, r7
    531e:	01 e0       	ldi	r16, 0x01	; 1
    5320:	10 e0       	ldi	r17, 0x00	; 0
    5322:	0c 0f       	add	r16, r28
    5324:	1d 1f       	adc	r17, r29
    5326:	08 0d       	add	r16, r8
    5328:	19 1d       	adc	r17, r9
    532a:	c7 01       	movw	r24, r14
    532c:	b6 01       	movw	r22, r12
    532e:	a3 01       	movw	r20, r6
    5330:	92 01       	movw	r18, r4
    5332:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    5336:	f8 01       	movw	r30, r16
    5338:	60 83       	st	Z, r22
    533a:	08 94       	sec
    533c:	81 1c       	adc	r8, r1
    533e:	91 1c       	adc	r9, r1
    5340:	a1 1c       	adc	r10, r1
    5342:	b1 1c       	adc	r11, r1
    n /= base;
    5344:	c7 01       	movw	r24, r14
    5346:	b6 01       	movw	r22, r12
    5348:	a3 01       	movw	r20, r6
    534a:	92 01       	movw	r18, r4
    534c:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    5350:	c9 01       	movw	r24, r18
    5352:	da 01       	movw	r26, r20
    5354:	6c 01       	movw	r12, r24
    5356:	7d 01       	movw	r14, r26
  if (n == 0) {
    print('0');
    return;
  } 

  while (n > 0) {
    5358:	c1 14       	cp	r12, r1
    535a:	d1 04       	cpc	r13, r1
    535c:	e1 04       	cpc	r14, r1
    535e:	f1 04       	cpc	r15, r1
    5360:	f1 f6       	brne	.-68     	; 0x531e <_ZN5Print11printNumberEmh+0x5e>
    5362:	81 e0       	ldi	r24, 0x01	; 1
    5364:	e8 2e       	mov	r14, r24
    5366:	f1 2c       	mov	r15, r1
    5368:	ec 0e       	add	r14, r28
    536a:	fd 1e       	adc	r15, r29
    536c:	e8 0c       	add	r14, r8
    536e:	f9 1c       	adc	r15, r9
    buf[i++] = n % base;
    n /= base;
  }

  for (; i > 0; i--)
    5370:	3e 01       	movw	r6, r28
    5372:	08 94       	sec
    5374:	61 1c       	adc	r6, r1
    5376:	71 1c       	adc	r7, r1
    print((char) (buf[i - 1] < 10 ?
      '0' + buf[i - 1] :
      'A' + buf[i - 1] - 10));
    5378:	d5 01       	movw	r26, r10
    537a:	c4 01       	movw	r24, r8
    537c:	01 97       	sbiw	r24, 0x01	; 1
    537e:	a1 09       	sbc	r26, r1
    5380:	b1 09       	sbc	r27, r1
    5382:	6c 01       	movw	r12, r24
    5384:	c8 18       	sub	r12, r8
    5386:	d9 08       	sbc	r13, r9
    5388:	14 c0       	rjmp	.+40     	; 0x53b2 <_ZN5Print11printNumberEmh+0xf2>
    538a:	f6 01       	movw	r30, r12
    538c:	ee 0d       	add	r30, r14
    538e:	ff 1d       	adc	r31, r15
    5390:	40 81       	ld	r20, Z
    5392:	4a 30       	cpi	r20, 0x0A	; 10
    5394:	10 f4       	brcc	.+4      	; 0x539a <_ZN5Print11printNumberEmh+0xda>
    5396:	40 5d       	subi	r20, 0xD0	; 208
    5398:	01 c0       	rjmp	.+2      	; 0x539c <_ZN5Print11printNumberEmh+0xdc>
    539a:	49 5c       	subi	r20, 0xC9	; 201
  write(str);
}

void Print::print(char c, int base)
{
  print((long) c, base);
    539c:	50 e0       	ldi	r21, 0x00	; 0
    539e:	60 e0       	ldi	r22, 0x00	; 0
    53a0:	70 e0       	ldi	r23, 0x00	; 0
    53a2:	c1 01       	movw	r24, r2
    53a4:	20 e0       	ldi	r18, 0x00	; 0
    53a6:	30 e0       	ldi	r19, 0x00	; 0
    53a8:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
    53ac:	08 94       	sec
    53ae:	e1 08       	sbc	r14, r1
    53b0:	f1 08       	sbc	r15, r1
  while (n > 0) {
    buf[i++] = n % base;
    n /= base;
  }

  for (; i > 0; i--)
    53b2:	6e 14       	cp	r6, r14
    53b4:	7f 04       	cpc	r7, r15
    53b6:	49 f7       	brne	.-46     	; 0x538a <_ZN5Print11printNumberEmh+0xca>
    print((char) (buf[i - 1] < 10 ?
      '0' + buf[i - 1] :
      'A' + buf[i - 1] - 10));
}
    53b8:	a0 96       	adiw	r28, 0x20	; 32
    53ba:	cd bf       	out	0x3d, r28	; 61
    53bc:	de bf       	out	0x3e, r29	; 62
    53be:	cf 91       	pop	r28
    53c0:	df 91       	pop	r29
    53c2:	1f 91       	pop	r17
    53c4:	0f 91       	pop	r16
    53c6:	ff 90       	pop	r15
    53c8:	ef 90       	pop	r14
    53ca:	df 90       	pop	r13
    53cc:	cf 90       	pop	r12
    53ce:	bf 90       	pop	r11
    53d0:	af 90       	pop	r10
    53d2:	9f 90       	pop	r9
    53d4:	8f 90       	pop	r8
    53d6:	7f 90       	pop	r7
    53d8:	6f 90       	pop	r6
    53da:	5f 90       	pop	r5
    53dc:	4f 90       	pop	r4
    53de:	3f 90       	pop	r3
    53e0:	2f 90       	pop	r2
    53e2:	08 95       	ret

000053e4 <_ZN5Print5printEmi>:
  } else {
    printNumber(n, base);
  }
}

void Print::print(unsigned long n, int base)
    53e4:	dc 01       	movw	r26, r24
{
  if (base == 0) write(n);
    53e6:	21 15       	cp	r18, r1
    53e8:	31 05       	cpc	r19, r1
    53ea:	41 f4       	brne	.+16     	; 0x53fc <_ZN5Print5printEmi+0x18>
    53ec:	ed 91       	ld	r30, X+
    53ee:	fc 91       	ld	r31, X
    53f0:	01 90       	ld	r0, Z+
    53f2:	f0 81       	ld	r31, Z
    53f4:	e0 2d       	mov	r30, r0
    53f6:	64 2f       	mov	r22, r20
    53f8:	19 95       	eicall
    53fa:	08 95       	ret
  else printNumber(n, base);
    53fc:	0e 94 60 29 	call	0x52c0	; 0x52c0 <_ZN5Print11printNumberEmh>
    5400:	08 95       	ret

00005402 <_ZN5Print5printEji>:
void Print::print(int n, int base)
{
  print((long) n, base);
}

void Print::print(unsigned int n, int base)
    5402:	ef 92       	push	r14
    5404:	ff 92       	push	r15
    5406:	0f 93       	push	r16
    5408:	1f 93       	push	r17
    540a:	9a 01       	movw	r18, r20
{
  print((unsigned long) n, base);
    540c:	7b 01       	movw	r14, r22
    540e:	00 e0       	ldi	r16, 0x00	; 0
    5410:	10 e0       	ldi	r17, 0x00	; 0
    5412:	b8 01       	movw	r22, r16
    5414:	a7 01       	movw	r20, r14
    5416:	0e 94 f2 29 	call	0x53e4	; 0x53e4 <_ZN5Print5printEmi>
}
    541a:	1f 91       	pop	r17
    541c:	0f 91       	pop	r16
    541e:	ff 90       	pop	r15
    5420:	ef 90       	pop	r14
    5422:	08 95       	ret

00005424 <_ZN5Print5printEhi>:
void Print::print(char c, int base)
{
  print((long) c, base);
}

void Print::print(unsigned char b, int base)
    5424:	ef 92       	push	r14
    5426:	ff 92       	push	r15
    5428:	0f 93       	push	r16
    542a:	1f 93       	push	r17
    542c:	9a 01       	movw	r18, r20
{
  print((unsigned long) b, base);
    542e:	e6 2e       	mov	r14, r22
    5430:	ff 24       	eor	r15, r15
    5432:	00 e0       	ldi	r16, 0x00	; 0
    5434:	10 e0       	ldi	r17, 0x00	; 0
    5436:	b8 01       	movw	r22, r16
    5438:	a7 01       	movw	r20, r14
    543a:	0e 94 f2 29 	call	0x53e4	; 0x53e4 <_ZN5Print5printEmi>
}
    543e:	1f 91       	pop	r17
    5440:	0f 91       	pop	r16
    5442:	ff 90       	pop	r15
    5444:	ef 90       	pop	r14
    5446:	08 95       	ret

00005448 <_ZN5Print5printEli>:
void Print::print(unsigned int n, int base)
{
  print((unsigned long) n, base);
}

void Print::print(long n, int base)
    5448:	ef 92       	push	r14
    544a:	ff 92       	push	r15
    544c:	0f 93       	push	r16
    544e:	1f 93       	push	r17
    5450:	cf 93       	push	r28
    5452:	df 93       	push	r29
    5454:	ec 01       	movw	r28, r24
    5456:	7a 01       	movw	r14, r20
    5458:	8b 01       	movw	r16, r22
{
  if (base == 0) {
    545a:	21 15       	cp	r18, r1
    545c:	31 05       	cpc	r19, r1
    545e:	41 f4       	brne	.+16     	; 0x5470 <_ZN5Print5printEli+0x28>
    write(n);
    5460:	e8 81       	ld	r30, Y
    5462:	f9 81       	ldd	r31, Y+1	; 0x01
    5464:	01 90       	ld	r0, Z+
    5466:	f0 81       	ld	r31, Z
    5468:	e0 2d       	mov	r30, r0
    546a:	64 2f       	mov	r22, r20
    546c:	19 95       	eicall
    546e:	1b c0       	rjmp	.+54     	; 0x54a6 <_ZN5Print5printEli+0x5e>
  } else if (base == 10) {
    5470:	2a 30       	cpi	r18, 0x0A	; 10
    5472:	31 05       	cpc	r19, r1
    5474:	b1 f4       	brne	.+44     	; 0x54a2 <_ZN5Print5printEli+0x5a>
    if (n < 0) {
    5476:	77 ff       	sbrs	r23, 7
    5478:	10 c0       	rjmp	.+32     	; 0x549a <_ZN5Print5printEli+0x52>
  write(str);
}

void Print::print(char c, int base)
{
  print((long) c, base);
    547a:	4d e2       	ldi	r20, 0x2D	; 45
    547c:	50 e0       	ldi	r21, 0x00	; 0
    547e:	60 e0       	ldi	r22, 0x00	; 0
    5480:	70 e0       	ldi	r23, 0x00	; 0
    5482:	20 e0       	ldi	r18, 0x00	; 0
    5484:	30 e0       	ldi	r19, 0x00	; 0
    5486:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
  if (base == 0) {
    write(n);
  } else if (base == 10) {
    if (n < 0) {
      print('-');
      n = -n;
    548a:	10 95       	com	r17
    548c:	00 95       	com	r16
    548e:	f0 94       	com	r15
    5490:	e0 94       	com	r14
    5492:	e1 1c       	adc	r14, r1
    5494:	f1 1c       	adc	r15, r1
    5496:	01 1d       	adc	r16, r1
    5498:	11 1d       	adc	r17, r1
    }
    printNumber(n, 10);
    549a:	ce 01       	movw	r24, r28
    549c:	b8 01       	movw	r22, r16
    549e:	a7 01       	movw	r20, r14
    54a0:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    printNumber(n, base);
    54a2:	0e 94 60 29 	call	0x52c0	; 0x52c0 <_ZN5Print11printNumberEmh>
  }
}
    54a6:	df 91       	pop	r29
    54a8:	cf 91       	pop	r28
    54aa:	1f 91       	pop	r17
    54ac:	0f 91       	pop	r16
    54ae:	ff 90       	pop	r15
    54b0:	ef 90       	pop	r14
    54b2:	08 95       	ret

000054b4 <_ZN5Print5printEii>:
void Print::print(unsigned char b, int base)
{
  print((unsigned long) b, base);
}

void Print::print(int n, int base)
    54b4:	ef 92       	push	r14
    54b6:	ff 92       	push	r15
    54b8:	0f 93       	push	r16
    54ba:	1f 93       	push	r17
    54bc:	7b 01       	movw	r14, r22
    54be:	9a 01       	movw	r18, r20
{
  print((long) n, base);
    54c0:	00 27       	eor	r16, r16
    54c2:	f7 fc       	sbrc	r15, 7
    54c4:	00 95       	com	r16
    54c6:	10 2f       	mov	r17, r16
    54c8:	b8 01       	movw	r22, r16
    54ca:	a7 01       	movw	r20, r14
    54cc:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
}
    54d0:	1f 91       	pop	r17
    54d2:	0f 91       	pop	r16
    54d4:	ff 90       	pop	r15
    54d6:	ef 90       	pop	r14
    54d8:	08 95       	ret

000054da <_ZN5Print5printEci>:
void Print::print(const char str[])
{
  write(str);
}

void Print::print(char c, int base)
    54da:	ef 92       	push	r14
    54dc:	ff 92       	push	r15
    54de:	0f 93       	push	r16
    54e0:	1f 93       	push	r17
    54e2:	9a 01       	movw	r18, r20
{
  print((long) c, base);
    54e4:	e6 2e       	mov	r14, r22
    54e6:	ff 24       	eor	r15, r15
    54e8:	00 e0       	ldi	r16, 0x00	; 0
    54ea:	10 e0       	ldi	r17, 0x00	; 0
    54ec:	b8 01       	movw	r22, r16
    54ee:	a7 01       	movw	r20, r14
    54f0:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
}
    54f4:	1f 91       	pop	r17
    54f6:	0f 91       	pop	r16
    54f8:	ff 90       	pop	r15
    54fa:	ef 90       	pop	r14
    54fc:	08 95       	ret

000054fe <_ZN5Print7printlnEv>:
void Print::print(double n, int digits)
{
  printFloat(n, digits);
}

void Print::println(void)
    54fe:	0f 93       	push	r16
    5500:	1f 93       	push	r17
    5502:	8c 01       	movw	r16, r24
  write(str);
}

void Print::print(char c, int base)
{
  print((long) c, base);
    5504:	4d e0       	ldi	r20, 0x0D	; 13
    5506:	50 e0       	ldi	r21, 0x00	; 0
    5508:	60 e0       	ldi	r22, 0x00	; 0
    550a:	70 e0       	ldi	r23, 0x00	; 0
    550c:	20 e0       	ldi	r18, 0x00	; 0
    550e:	30 e0       	ldi	r19, 0x00	; 0
    5510:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>

void Print::println(void)
{
  print('\r');
  print('\n');  
}
    5514:	c8 01       	movw	r24, r16
    5516:	4a e0       	ldi	r20, 0x0A	; 10
    5518:	50 e0       	ldi	r21, 0x00	; 0
    551a:	60 e0       	ldi	r22, 0x00	; 0
    551c:	70 e0       	ldi	r23, 0x00	; 0
    551e:	20 e0       	ldi	r18, 0x00	; 0
    5520:	30 e0       	ldi	r19, 0x00	; 0
    5522:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
    5526:	1f 91       	pop	r17
    5528:	0f 91       	pop	r16
    552a:	08 95       	ret

0000552c <_ZN5Print7printlnEmi>:
{
  print(n, base);
  println();
}

void Print::println(unsigned long n, int base)
    552c:	0f 93       	push	r16
    552e:	1f 93       	push	r17
    5530:	8c 01       	movw	r16, r24
{
  print(n, base);
    5532:	0e 94 f2 29 	call	0x53e4	; 0x53e4 <_ZN5Print5printEmi>
  println();
    5536:	c8 01       	movw	r24, r16
    5538:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    553c:	1f 91       	pop	r17
    553e:	0f 91       	pop	r16
    5540:	08 95       	ret

00005542 <_ZN5Print7printlnEji>:
{
  print(n, base);
  println();
}

void Print::println(unsigned int n, int base)
    5542:	cf 92       	push	r12
    5544:	df 92       	push	r13
    5546:	ef 92       	push	r14
    5548:	ff 92       	push	r15
    554a:	0f 93       	push	r16
    554c:	1f 93       	push	r17
    554e:	8c 01       	movw	r16, r24
    5550:	9a 01       	movw	r18, r20
  print((long) n, base);
}

void Print::print(unsigned int n, int base)
{
  print((unsigned long) n, base);
    5552:	6b 01       	movw	r12, r22
    5554:	ee 24       	eor	r14, r14
    5556:	ff 24       	eor	r15, r15
    5558:	b7 01       	movw	r22, r14
    555a:	a6 01       	movw	r20, r12
    555c:	0e 94 f2 29 	call	0x53e4	; 0x53e4 <_ZN5Print5printEmi>
}

void Print::println(unsigned int n, int base)
{
  print(n, base);
  println();
    5560:	c8 01       	movw	r24, r16
    5562:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    5566:	1f 91       	pop	r17
    5568:	0f 91       	pop	r16
    556a:	ff 90       	pop	r15
    556c:	ef 90       	pop	r14
    556e:	df 90       	pop	r13
    5570:	cf 90       	pop	r12
    5572:	08 95       	ret

00005574 <_ZN5Print7printlnEhi>:
{
  print(c, base);
  println();
}

void Print::println(unsigned char b, int base)
    5574:	cf 92       	push	r12
    5576:	df 92       	push	r13
    5578:	ef 92       	push	r14
    557a:	ff 92       	push	r15
    557c:	0f 93       	push	r16
    557e:	1f 93       	push	r17
    5580:	8c 01       	movw	r16, r24
    5582:	9a 01       	movw	r18, r20
  print((long) c, base);
}

void Print::print(unsigned char b, int base)
{
  print((unsigned long) b, base);
    5584:	c6 2e       	mov	r12, r22
    5586:	dd 24       	eor	r13, r13
    5588:	ee 24       	eor	r14, r14
    558a:	ff 24       	eor	r15, r15
    558c:	b7 01       	movw	r22, r14
    558e:	a6 01       	movw	r20, r12
    5590:	0e 94 f2 29 	call	0x53e4	; 0x53e4 <_ZN5Print5printEmi>
}

void Print::println(unsigned char b, int base)
{
  print(b, base);
  println();
    5594:	c8 01       	movw	r24, r16
    5596:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    559a:	1f 91       	pop	r17
    559c:	0f 91       	pop	r16
    559e:	ff 90       	pop	r15
    55a0:	ef 90       	pop	r14
    55a2:	df 90       	pop	r13
    55a4:	cf 90       	pop	r12
    55a6:	08 95       	ret

000055a8 <_ZN5Print7printlnEPKc>:
{
  print('\r');
  print('\n');  
}

void Print::println(const char c[])
    55a8:	0f 93       	push	r16
    55aa:	1f 93       	push	r17
    55ac:	8c 01       	movw	r16, r24
{
  print(c);
    55ae:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
  println();
    55b2:	c8 01       	movw	r24, r16
    55b4:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    55b8:	1f 91       	pop	r17
    55ba:	0f 91       	pop	r16
    55bc:	08 95       	ret

000055be <_ZN5Print7printlnEli>:
{
  print(n, base);
  println();
}

void Print::println(long n, int base)
    55be:	0f 93       	push	r16
    55c0:	1f 93       	push	r17
    55c2:	8c 01       	movw	r16, r24
{
  print(n, base);
    55c4:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
  println();
    55c8:	c8 01       	movw	r24, r16
    55ca:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    55ce:	1f 91       	pop	r17
    55d0:	0f 91       	pop	r16
    55d2:	08 95       	ret

000055d4 <_ZN5Print7printlnEii>:
{
  print(b, base);
  println();
}

void Print::println(int n, int base)
    55d4:	cf 92       	push	r12
    55d6:	df 92       	push	r13
    55d8:	ef 92       	push	r14
    55da:	ff 92       	push	r15
    55dc:	0f 93       	push	r16
    55de:	1f 93       	push	r17
    55e0:	8c 01       	movw	r16, r24
    55e2:	6b 01       	movw	r12, r22
    55e4:	9a 01       	movw	r18, r20
  print((unsigned long) b, base);
}

void Print::print(int n, int base)
{
  print((long) n, base);
    55e6:	ee 24       	eor	r14, r14
    55e8:	d7 fc       	sbrc	r13, 7
    55ea:	e0 94       	com	r14
    55ec:	fe 2c       	mov	r15, r14
    55ee:	b7 01       	movw	r22, r14
    55f0:	a6 01       	movw	r20, r12
    55f2:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
}

void Print::println(int n, int base)
{
  print(n, base);
  println();
    55f6:	c8 01       	movw	r24, r16
    55f8:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    55fc:	1f 91       	pop	r17
    55fe:	0f 91       	pop	r16
    5600:	ff 90       	pop	r15
    5602:	ef 90       	pop	r14
    5604:	df 90       	pop	r13
    5606:	cf 90       	pop	r12
    5608:	08 95       	ret

0000560a <_ZN5Print7printlnEci>:
{
  print(c);
  println();
}

void Print::println(char c, int base)
    560a:	cf 92       	push	r12
    560c:	df 92       	push	r13
    560e:	ef 92       	push	r14
    5610:	ff 92       	push	r15
    5612:	0f 93       	push	r16
    5614:	1f 93       	push	r17
    5616:	8c 01       	movw	r16, r24
    5618:	9a 01       	movw	r18, r20
  write(str);
}

void Print::print(char c, int base)
{
  print((long) c, base);
    561a:	c6 2e       	mov	r12, r22
    561c:	dd 24       	eor	r13, r13
    561e:	ee 24       	eor	r14, r14
    5620:	ff 24       	eor	r15, r15
    5622:	b7 01       	movw	r22, r14
    5624:	a6 01       	movw	r20, r12
    5626:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
}

void Print::println(char c, int base)
{
  print(c, base);
  println();
    562a:	c8 01       	movw	r24, r16
    562c:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    5630:	1f 91       	pop	r17
    5632:	0f 91       	pop	r16
    5634:	ff 90       	pop	r15
    5636:	ef 90       	pop	r14
    5638:	df 90       	pop	r13
    563a:	cf 90       	pop	r12
    563c:	08 95       	ret

0000563e <_ZN5Print10printFloatEdh>:
    print((char) (buf[i - 1] < 10 ?
      '0' + buf[i - 1] :
      'A' + buf[i - 1] - 10));
}

void Print::printFloat(double number, uint8_t digits) 
    563e:	9f 92       	push	r9
    5640:	af 92       	push	r10
    5642:	bf 92       	push	r11
    5644:	cf 92       	push	r12
    5646:	df 92       	push	r13
    5648:	ef 92       	push	r14
    564a:	ff 92       	push	r15
    564c:	0f 93       	push	r16
    564e:	1f 93       	push	r17
    5650:	cf 93       	push	r28
    5652:	df 93       	push	r29
    5654:	ec 01       	movw	r28, r24
    5656:	7a 01       	movw	r14, r20
    5658:	8b 01       	movw	r16, r22
    565a:	92 2e       	mov	r9, r18
{ 
  // Handle negative numbers
  if (number < 0.0)
    565c:	cb 01       	movw	r24, r22
    565e:	ba 01       	movw	r22, r20
    5660:	20 e0       	ldi	r18, 0x00	; 0
    5662:	30 e0       	ldi	r19, 0x00	; 0
    5664:	40 e0       	ldi	r20, 0x00	; 0
    5666:	50 e0       	ldi	r21, 0x00	; 0
    5668:	0e 94 d2 45 	call	0x8ba4	; 0x8ba4 <__ltsf2>
    566c:	88 23       	and	r24, r24
    566e:	6c f4       	brge	.+26     	; 0x568a <_ZN5Print10printFloatEdh+0x4c>
  write(str);
}

void Print::print(char c, int base)
{
  print((long) c, base);
    5670:	ce 01       	movw	r24, r28
    5672:	4d e2       	ldi	r20, 0x2D	; 45
    5674:	50 e0       	ldi	r21, 0x00	; 0
    5676:	60 e0       	ldi	r22, 0x00	; 0
    5678:	70 e0       	ldi	r23, 0x00	; 0
    567a:	20 e0       	ldi	r18, 0x00	; 0
    567c:	30 e0       	ldi	r19, 0x00	; 0
    567e:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
{ 
  // Handle negative numbers
  if (number < 0.0)
  {
     print('-');
     number = -number;
    5682:	17 fb       	bst	r17, 7
    5684:	10 95       	com	r17
    5686:	17 f9       	bld	r17, 7
    5688:	10 95       	com	r17
    568a:	20 e0       	ldi	r18, 0x00	; 0
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	40 e0       	ldi	r20, 0x00	; 0
    5690:	5f e3       	ldi	r21, 0x3F	; 63
    5692:	aa 24       	eor	r10, r10
    5694:	0b c0       	rjmp	.+22     	; 0x56ac <_ZN5Print10printFloatEdh+0x6e>
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    rounding /= 10.0;
    5696:	ca 01       	movw	r24, r20
    5698:	b9 01       	movw	r22, r18
    569a:	20 e0       	ldi	r18, 0x00	; 0
    569c:	30 e0       	ldi	r19, 0x00	; 0
    569e:	40 e2       	ldi	r20, 0x20	; 32
    56a0:	51 e4       	ldi	r21, 0x41	; 65
    56a2:	0e 94 f6 44 	call	0x89ec	; 0x89ec <__divsf3>
    56a6:	9b 01       	movw	r18, r22
    56a8:	ac 01       	movw	r20, r24
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    56aa:	a3 94       	inc	r10
    56ac:	a9 14       	cp	r10, r9
    56ae:	98 f3       	brcs	.-26     	; 0x5696 <_ZN5Print10printFloatEdh+0x58>
    rounding /= 10.0;
  
  number += rounding;
    56b0:	c8 01       	movw	r24, r16
    56b2:	b7 01       	movw	r22, r14
    56b4:	0e 94 cf 43 	call	0x879e	; 0x879e <__addsf3>
    56b8:	5b 01       	movw	r10, r22
    56ba:	6c 01       	movw	r12, r24

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    56bc:	0e 94 26 42 	call	0x844c	; 0x844c <__fixunssfsi>
    56c0:	7b 01       	movw	r14, r22
    56c2:	8c 01       	movw	r16, r24
  double remainder = number - (double)int_part;
  print(int_part);
    56c4:	ce 01       	movw	r24, r28
    56c6:	b8 01       	movw	r22, r16
    56c8:	a7 01       	movw	r20, r14
    56ca:	2a e0       	ldi	r18, 0x0A	; 10
    56cc:	30 e0       	ldi	r19, 0x00	; 0
    56ce:	0e 94 f2 29 	call	0x53e4	; 0x53e4 <_ZN5Print5printEmi>

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0)
    56d2:	99 20       	and	r9, r9
    56d4:	29 f0       	breq	.+10     	; 0x56e0 <_ZN5Print10printFloatEdh+0xa2>
    print("."); 
    56d6:	ce 01       	movw	r24, r28
    56d8:	67 ea       	ldi	r22, 0xA7	; 167
    56da:	74 e2       	ldi	r23, 0x24	; 36
    56dc:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
  
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    56e0:	c8 01       	movw	r24, r16
    56e2:	b7 01       	movw	r22, r14
    56e4:	0e 94 b4 46 	call	0x8d68	; 0x8d68 <__floatunsisf>
    56e8:	9b 01       	movw	r18, r22
    56ea:	ac 01       	movw	r20, r24
    56ec:	c6 01       	movw	r24, r12
    56ee:	b5 01       	movw	r22, r10
    56f0:	0e 94 9e 43 	call	0x873c	; 0x873c <__subsf3>
    56f4:	22 c0       	rjmp	.+68     	; 0x573a <_ZN5Print10printFloatEdh+0xfc>
    print("."); 

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    56f6:	20 e0       	ldi	r18, 0x00	; 0
    56f8:	30 e0       	ldi	r19, 0x00	; 0
    56fa:	40 e2       	ldi	r20, 0x20	; 32
    56fc:	51 e4       	ldi	r21, 0x41	; 65
    56fe:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__mulsf3>
    5702:	7b 01       	movw	r14, r22
    5704:	8c 01       	movw	r16, r24
    int toPrint = int(remainder);
    5706:	0e 94 60 46 	call	0x8cc0	; 0x8cc0 <__fixsfsi>
    570a:	5b 01       	movw	r10, r22
    570c:	6c 01       	movw	r12, r24
  print((unsigned long) b, base);
}

void Print::print(int n, int base)
{
  print((long) n, base);
    570e:	cc 24       	eor	r12, r12
    5710:	b7 fc       	sbrc	r11, 7
    5712:	c0 94       	com	r12
    5714:	dc 2c       	mov	r13, r12
    5716:	ce 01       	movw	r24, r28
    5718:	b6 01       	movw	r22, r12
    571a:	a5 01       	movw	r20, r10
    571c:	2a e0       	ldi	r18, 0x0A	; 10
    571e:	30 e0       	ldi	r19, 0x00	; 0
    5720:	0e 94 24 2a 	call	0x5448	; 0x5448 <_ZN5Print5printEli>
  while (digits-- > 0)
  {
    remainder *= 10.0;
    int toPrint = int(remainder);
    print(toPrint);
    remainder -= toPrint; 
    5724:	c6 01       	movw	r24, r12
    5726:	b5 01       	movw	r22, r10
    5728:	0e 94 02 46 	call	0x8c04	; 0x8c04 <__floatsisf>
    572c:	9b 01       	movw	r18, r22
    572e:	ac 01       	movw	r20, r24
    5730:	c8 01       	movw	r24, r16
    5732:	b7 01       	movw	r22, r14
    5734:	0e 94 9e 43 	call	0x873c	; 0x873c <__subsf3>
    5738:	9a 94       	dec	r9
  // Print the decimal point, but only if there are digits beyond
  if (digits > 0)
    print("."); 

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    573a:	99 20       	and	r9, r9
    573c:	e1 f6       	brne	.-72     	; 0x56f6 <_ZN5Print10printFloatEdh+0xb8>
    remainder *= 10.0;
    int toPrint = int(remainder);
    print(toPrint);
    remainder -= toPrint; 
  } 
}
    573e:	df 91       	pop	r29
    5740:	cf 91       	pop	r28
    5742:	1f 91       	pop	r17
    5744:	0f 91       	pop	r16
    5746:	ff 90       	pop	r15
    5748:	ef 90       	pop	r14
    574a:	df 90       	pop	r13
    574c:	cf 90       	pop	r12
    574e:	bf 90       	pop	r11
    5750:	af 90       	pop	r10
    5752:	9f 90       	pop	r9
    5754:	08 95       	ret

00005756 <_ZN5Print5printEdi>:
  else printNumber(n, base);
}

void Print::print(double n, int digits)
{
  printFloat(n, digits);
    5756:	0e 94 1f 2b 	call	0x563e	; 0x563e <_ZN5Print10printFloatEdh>
}
    575a:	08 95       	ret

0000575c <_ZN5Print7printlnEdi>:
{
  print(n, base);
  println();
}

void Print::println(double n, int digits)
    575c:	0f 93       	push	r16
    575e:	1f 93       	push	r17
    5760:	8c 01       	movw	r16, r24
  else printNumber(n, base);
}

void Print::print(double n, int digits)
{
  printFloat(n, digits);
    5762:	0e 94 1f 2b 	call	0x563e	; 0x563e <_ZN5Print10printFloatEdh>
}

void Print::println(double n, int digits)
{
  print(n, digits);
  println();
    5766:	c8 01       	movw	r24, r16
    5768:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <_ZN5Print7printlnEv>
}
    576c:	1f 91       	pop	r17
    576e:	0f 91       	pop	r16
    5770:	08 95       	ret

00005772 <_ZL10SetPointerP11PORT_structP4Port>:
static void SetPointer(PORT_t* port,Port* p)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if(port == &PORTA) {
    5772:	26 e0       	ldi	r18, 0x06	; 6
    5774:	80 30       	cpi	r24, 0x00	; 0
    5776:	92 07       	cpc	r25, r18
    5778:	29 f4       	brne	.+10     	; 0x5784 <_ZL10SetPointerP11PORT_structP4Port+0x12>
        PORTAcp = p;
    577a:	60 93 cb 2b 	sts	0x2BCB, r22
    577e:	70 93 cc 2b 	sts	0x2BCC, r23
    5782:	08 95       	ret
    } else if (port == &PORTB) {
    5784:	26 e0       	ldi	r18, 0x06	; 6
    5786:	80 32       	cpi	r24, 0x20	; 32
    5788:	92 07       	cpc	r25, r18
    578a:	29 f4       	brne	.+10     	; 0x5796 <_ZL10SetPointerP11PORT_structP4Port+0x24>
        PORTBcp = p;
    578c:	60 93 cd 2b 	sts	0x2BCD, r22
    5790:	70 93 ce 2b 	sts	0x2BCE, r23
    5794:	08 95       	ret
    } else if (port ==  &PORTC) {
    5796:	26 e0       	ldi	r18, 0x06	; 6
    5798:	80 34       	cpi	r24, 0x40	; 64
    579a:	92 07       	cpc	r25, r18
    579c:	29 f4       	brne	.+10     	; 0x57a8 <_ZL10SetPointerP11PORT_structP4Port+0x36>
        PORTCcp = p;
    579e:	60 93 cf 2b 	sts	0x2BCF, r22
    57a2:	70 93 d0 2b 	sts	0x2BD0, r23
    57a6:	08 95       	ret
    } else if (port ==  &PORTD) {
    57a8:	26 e0       	ldi	r18, 0x06	; 6
    57aa:	80 36       	cpi	r24, 0x60	; 96
    57ac:	92 07       	cpc	r25, r18
    57ae:	29 f4       	brne	.+10     	; 0x57ba <_ZL10SetPointerP11PORT_structP4Port+0x48>
        PORTDcp = p;
    57b0:	60 93 d1 2b 	sts	0x2BD1, r22
    57b4:	70 93 d2 2b 	sts	0x2BD2, r23
    57b8:	08 95       	ret
    } else if (port ==  &PORTE) {
    57ba:	26 e0       	ldi	r18, 0x06	; 6
    57bc:	80 38       	cpi	r24, 0x80	; 128
    57be:	92 07       	cpc	r25, r18
    57c0:	29 f4       	brne	.+10     	; 0x57cc <_ZL10SetPointerP11PORT_structP4Port+0x5a>
        PORTEcp = p;
    57c2:	60 93 d3 2b 	sts	0x2BD3, r22
    57c6:	70 93 d4 2b 	sts	0x2BD4, r23
    57ca:	08 95       	ret
    } else if (port ==  &PORTF) {
    57cc:	26 e0       	ldi	r18, 0x06	; 6
    57ce:	80 3a       	cpi	r24, 0xA0	; 160
    57d0:	92 07       	cpc	r25, r18
    57d2:	29 f4       	brne	.+10     	; 0x57de <_ZL10SetPointerP11PORT_structP4Port+0x6c>
        PORTFcp = p;
    57d4:	60 93 d5 2b 	sts	0x2BD5, r22
    57d8:	70 93 d6 2b 	sts	0x2BD6, r23
    57dc:	08 95       	ret
#if defined (__AVR_ATxmega128A1__)
    } else if (port ==  &PORTH) {
    57de:	80 5e       	subi	r24, 0xE0	; 224
    57e0:	96 40       	sbci	r25, 0x06	; 6
    57e2:	21 f4       	brne	.+8      	; 0x57ec <_ZL10SetPointerP11PORT_structP4Port+0x7a>
        PORTHcp = p;
    57e4:	60 93 d7 2b 	sts	0x2BD7, r22
    57e8:	70 93 d8 2b 	sts	0x2BD8, r23
    57ec:	08 95       	ret

000057ee <_ZN4PortC2EP11PORT_struct>:
#endif
    }
}


Port::Port(PORT_t* pPort)
    57ee:	fc 01       	movw	r30, r24
    57f0:	cb 01       	movw	r24, r22
{
    _pPort = pPort;
    57f2:	60 83       	st	Z, r22
    57f4:	71 83       	std	Z+1, r23	; 0x01
    SetPointer(_pPort,this);
    57f6:	bf 01       	movw	r22, r30
    57f8:	0e 94 b9 2b 	call	0x5772	; 0x5772 <_ZL10SetPointerP11PORT_structP4Port>
}
    57fc:	08 95       	ret

000057fe <_ZN4PortC1EP11PORT_struct>:
#endif
    }
}


Port::Port(PORT_t* pPort)
    57fe:	fc 01       	movw	r30, r24
    5800:	cb 01       	movw	r24, r22
{
    _pPort = pPort;
    5802:	60 83       	st	Z, r22
    5804:	71 83       	std	Z+1, r23	; 0x01
    SetPointer(_pPort,this);
    5806:	bf 01       	movw	r22, r30
    5808:	0e 94 b9 2b 	call	0x5772	; 0x5772 <_ZL10SetPointerP11PORT_structP4Port>
}
    580c:	08 95       	ret

0000580e <_ZN4PortD2Ev>:

Port::~Port()
    580e:	fc 01       	movw	r30, r24
{
    SetPointer(_pPort,0);
    5810:	80 81       	ld	r24, Z
    5812:	91 81       	ldd	r25, Z+1	; 0x01
    5814:	60 e0       	ldi	r22, 0x00	; 0
    5816:	70 e0       	ldi	r23, 0x00	; 0
    5818:	0e 94 b9 2b 	call	0x5772	; 0x5772 <_ZL10SetPointerP11PORT_structP4Port>
}
    581c:	08 95       	ret

0000581e <_ZN4PortD1Ev>:
{
    _pPort = pPort;
    SetPointer(_pPort,this);
}

Port::~Port()
    581e:	fc 01       	movw	r30, r24
{
    SetPointer(_pPort,0);
    5820:	80 81       	ld	r24, Z
    5822:	91 81       	ldd	r25, Z+1	; 0x01
    5824:	60 e0       	ldi	r22, 0x00	; 0
    5826:	70 e0       	ldi	r23, 0x00	; 0
    5828:	0e 94 b9 2b 	call	0x5772	; 0x5772 <_ZL10SetPointerP11PORT_structP4Port>
}
    582c:	08 95       	ret

0000582e <_ZN4Port6NotifyEP10PortNotifyh>:

void Port::Notify(PortNotify* pClient,uint8_t id)
    582e:	fc 01       	movw	r30, r24
{
    _pNotifyClient  = pClient;
    5830:	62 83       	std	Z+2, r22	; 0x02
    5832:	73 83       	std	Z+3, r23	; 0x03
    _pNotifyID      = id;
    5834:	44 83       	std	Z+4, r20	; 0x04
}
    5836:	08 95       	ret

00005838 <_ZN4Port4int0Ev>:

void Port::int0()
    5838:	cf 93       	push	r28
    583a:	df 93       	push	r29
    583c:	ec 01       	movw	r28, r24
{
    if (_pNotifyClient) {
    583e:	aa 81       	ldd	r26, Y+2	; 0x02
    5840:	bb 81       	ldd	r27, Y+3	; 0x03
    5842:	10 97       	sbiw	r26, 0x00	; 0
    5844:	49 f0       	breq	.+18     	; 0x5858 <_ZN4Port4int0Ev+0x20>
        _pNotifyClient->PortISR0(_pNotifyID);
    5846:	ed 91       	ld	r30, X+
    5848:	fc 91       	ld	r31, X
    584a:	11 97       	sbiw	r26, 0x01	; 1
    584c:	01 90       	ld	r0, Z+
    584e:	f0 81       	ld	r31, Z
    5850:	e0 2d       	mov	r30, r0
    5852:	cd 01       	movw	r24, r26
    5854:	6c 81       	ldd	r22, Y+4	; 0x04
    5856:	19 95       	eicall
    }
    _pPort->INTFLAGS = 0x1;
    5858:	e8 81       	ld	r30, Y
    585a:	f9 81       	ldd	r31, Y+1	; 0x01
    585c:	81 e0       	ldi	r24, 0x01	; 1
    585e:	84 87       	std	Z+12, r24	; 0x0c
}
    5860:	df 91       	pop	r29
    5862:	cf 91       	pop	r28
    5864:	08 95       	ret

00005866 <__vector_96>:
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
PORT_ISR_DEF(PORTE);
PORT_ISR_DEF(PORTF);
#if defined (__AVR_ATxmega128A1__)
PORT_ISR_DEF(PORTH);
    5866:	1f 92       	push	r1
    5868:	0f 92       	push	r0
    586a:	0f b6       	in	r0, 0x3f	; 63
    586c:	0f 92       	push	r0
    586e:	08 b6       	in	r0, 0x38	; 56
    5870:	0f 92       	push	r0
    5872:	09 b6       	in	r0, 0x39	; 57
    5874:	0f 92       	push	r0
    5876:	0b b6       	in	r0, 0x3b	; 59
    5878:	0f 92       	push	r0
    587a:	11 24       	eor	r1, r1
    587c:	18 be       	out	0x38, r1	; 56
    587e:	19 be       	out	0x39, r1	; 57
    5880:	1b be       	out	0x3b, r1	; 59
    5882:	2f 93       	push	r18
    5884:	3f 93       	push	r19
    5886:	4f 93       	push	r20
    5888:	5f 93       	push	r21
    588a:	6f 93       	push	r22
    588c:	7f 93       	push	r23
    588e:	8f 93       	push	r24
    5890:	9f 93       	push	r25
    5892:	af 93       	push	r26
    5894:	bf 93       	push	r27
    5896:	ef 93       	push	r30
    5898:	ff 93       	push	r31
    589a:	80 91 d7 2b 	lds	r24, 0x2BD7
    589e:	90 91 d8 2b 	lds	r25, 0x2BD8
    58a2:	00 97       	sbiw	r24, 0x00	; 0
    58a4:	11 f0       	breq	.+4      	; 0x58aa <__vector_96+0x44>
    58a6:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    58aa:	ff 91       	pop	r31
    58ac:	ef 91       	pop	r30
    58ae:	bf 91       	pop	r27
    58b0:	af 91       	pop	r26
    58b2:	9f 91       	pop	r25
    58b4:	8f 91       	pop	r24
    58b6:	7f 91       	pop	r23
    58b8:	6f 91       	pop	r22
    58ba:	5f 91       	pop	r21
    58bc:	4f 91       	pop	r20
    58be:	3f 91       	pop	r19
    58c0:	2f 91       	pop	r18
    58c2:	0f 90       	pop	r0
    58c4:	0b be       	out	0x3b, r0	; 59
    58c6:	0f 90       	pop	r0
    58c8:	09 be       	out	0x39, r0	; 57
    58ca:	0f 90       	pop	r0
    58cc:	08 be       	out	0x38, r0	; 56
    58ce:	0f 90       	pop	r0
    58d0:	0f be       	out	0x3f, r0	; 63
    58d2:	0f 90       	pop	r0
    58d4:	1f 90       	pop	r1
    58d6:	18 95       	reti

000058d8 <__vector_104>:
PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
PORT_ISR_DEF(PORTE);
PORT_ISR_DEF(PORTF);
    58d8:	1f 92       	push	r1
    58da:	0f 92       	push	r0
    58dc:	0f b6       	in	r0, 0x3f	; 63
    58de:	0f 92       	push	r0
    58e0:	08 b6       	in	r0, 0x38	; 56
    58e2:	0f 92       	push	r0
    58e4:	09 b6       	in	r0, 0x39	; 57
    58e6:	0f 92       	push	r0
    58e8:	0b b6       	in	r0, 0x3b	; 59
    58ea:	0f 92       	push	r0
    58ec:	11 24       	eor	r1, r1
    58ee:	18 be       	out	0x38, r1	; 56
    58f0:	19 be       	out	0x39, r1	; 57
    58f2:	1b be       	out	0x3b, r1	; 59
    58f4:	2f 93       	push	r18
    58f6:	3f 93       	push	r19
    58f8:	4f 93       	push	r20
    58fa:	5f 93       	push	r21
    58fc:	6f 93       	push	r22
    58fe:	7f 93       	push	r23
    5900:	8f 93       	push	r24
    5902:	9f 93       	push	r25
    5904:	af 93       	push	r26
    5906:	bf 93       	push	r27
    5908:	ef 93       	push	r30
    590a:	ff 93       	push	r31
    590c:	80 91 d5 2b 	lds	r24, 0x2BD5
    5910:	90 91 d6 2b 	lds	r25, 0x2BD6
    5914:	00 97       	sbiw	r24, 0x00	; 0
    5916:	11 f0       	breq	.+4      	; 0x591c <__vector_104+0x44>
    5918:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    591c:	ff 91       	pop	r31
    591e:	ef 91       	pop	r30
    5920:	bf 91       	pop	r27
    5922:	af 91       	pop	r26
    5924:	9f 91       	pop	r25
    5926:	8f 91       	pop	r24
    5928:	7f 91       	pop	r23
    592a:	6f 91       	pop	r22
    592c:	5f 91       	pop	r21
    592e:	4f 91       	pop	r20
    5930:	3f 91       	pop	r19
    5932:	2f 91       	pop	r18
    5934:	0f 90       	pop	r0
    5936:	0b be       	out	0x3b, r0	; 59
    5938:	0f 90       	pop	r0
    593a:	09 be       	out	0x39, r0	; 57
    593c:	0f 90       	pop	r0
    593e:	08 be       	out	0x38, r0	; 56
    5940:	0f 90       	pop	r0
    5942:	0f be       	out	0x3f, r0	; 63
    5944:	0f 90       	pop	r0
    5946:	1f 90       	pop	r1
    5948:	18 95       	reti

0000594a <__vector_43>:

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
PORT_ISR_DEF(PORTE);
    594a:	1f 92       	push	r1
    594c:	0f 92       	push	r0
    594e:	0f b6       	in	r0, 0x3f	; 63
    5950:	0f 92       	push	r0
    5952:	08 b6       	in	r0, 0x38	; 56
    5954:	0f 92       	push	r0
    5956:	09 b6       	in	r0, 0x39	; 57
    5958:	0f 92       	push	r0
    595a:	0b b6       	in	r0, 0x3b	; 59
    595c:	0f 92       	push	r0
    595e:	11 24       	eor	r1, r1
    5960:	18 be       	out	0x38, r1	; 56
    5962:	19 be       	out	0x39, r1	; 57
    5964:	1b be       	out	0x3b, r1	; 59
    5966:	2f 93       	push	r18
    5968:	3f 93       	push	r19
    596a:	4f 93       	push	r20
    596c:	5f 93       	push	r21
    596e:	6f 93       	push	r22
    5970:	7f 93       	push	r23
    5972:	8f 93       	push	r24
    5974:	9f 93       	push	r25
    5976:	af 93       	push	r26
    5978:	bf 93       	push	r27
    597a:	ef 93       	push	r30
    597c:	ff 93       	push	r31
    597e:	80 91 d3 2b 	lds	r24, 0x2BD3
    5982:	90 91 d4 2b 	lds	r25, 0x2BD4
    5986:	00 97       	sbiw	r24, 0x00	; 0
    5988:	11 f0       	breq	.+4      	; 0x598e <__vector_43+0x44>
    598a:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    598e:	ff 91       	pop	r31
    5990:	ef 91       	pop	r30
    5992:	bf 91       	pop	r27
    5994:	af 91       	pop	r26
    5996:	9f 91       	pop	r25
    5998:	8f 91       	pop	r24
    599a:	7f 91       	pop	r23
    599c:	6f 91       	pop	r22
    599e:	5f 91       	pop	r21
    59a0:	4f 91       	pop	r20
    59a2:	3f 91       	pop	r19
    59a4:	2f 91       	pop	r18
    59a6:	0f 90       	pop	r0
    59a8:	0b be       	out	0x3b, r0	; 59
    59aa:	0f 90       	pop	r0
    59ac:	09 be       	out	0x39, r0	; 57
    59ae:	0f 90       	pop	r0
    59b0:	08 be       	out	0x38, r0	; 56
    59b2:	0f 90       	pop	r0
    59b4:	0f be       	out	0x3f, r0	; 63
    59b6:	0f 90       	pop	r0
    59b8:	1f 90       	pop	r1
    59ba:	18 95       	reti

000059bc <__vector_64>:
}

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
    59bc:	1f 92       	push	r1
    59be:	0f 92       	push	r0
    59c0:	0f b6       	in	r0, 0x3f	; 63
    59c2:	0f 92       	push	r0
    59c4:	08 b6       	in	r0, 0x38	; 56
    59c6:	0f 92       	push	r0
    59c8:	09 b6       	in	r0, 0x39	; 57
    59ca:	0f 92       	push	r0
    59cc:	0b b6       	in	r0, 0x3b	; 59
    59ce:	0f 92       	push	r0
    59d0:	11 24       	eor	r1, r1
    59d2:	18 be       	out	0x38, r1	; 56
    59d4:	19 be       	out	0x39, r1	; 57
    59d6:	1b be       	out	0x3b, r1	; 59
    59d8:	2f 93       	push	r18
    59da:	3f 93       	push	r19
    59dc:	4f 93       	push	r20
    59de:	5f 93       	push	r21
    59e0:	6f 93       	push	r22
    59e2:	7f 93       	push	r23
    59e4:	8f 93       	push	r24
    59e6:	9f 93       	push	r25
    59e8:	af 93       	push	r26
    59ea:	bf 93       	push	r27
    59ec:	ef 93       	push	r30
    59ee:	ff 93       	push	r31
    59f0:	80 91 d1 2b 	lds	r24, 0x2BD1
    59f4:	90 91 d2 2b 	lds	r25, 0x2BD2
    59f8:	00 97       	sbiw	r24, 0x00	; 0
    59fa:	11 f0       	breq	.+4      	; 0x5a00 <__vector_64+0x44>
    59fc:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    5a00:	ff 91       	pop	r31
    5a02:	ef 91       	pop	r30
    5a04:	bf 91       	pop	r27
    5a06:	af 91       	pop	r26
    5a08:	9f 91       	pop	r25
    5a0a:	8f 91       	pop	r24
    5a0c:	7f 91       	pop	r23
    5a0e:	6f 91       	pop	r22
    5a10:	5f 91       	pop	r21
    5a12:	4f 91       	pop	r20
    5a14:	3f 91       	pop	r19
    5a16:	2f 91       	pop	r18
    5a18:	0f 90       	pop	r0
    5a1a:	0b be       	out	0x3b, r0	; 59
    5a1c:	0f 90       	pop	r0
    5a1e:	09 be       	out	0x39, r0	; 57
    5a20:	0f 90       	pop	r0
    5a22:	08 be       	out	0x38, r0	; 56
    5a24:	0f 90       	pop	r0
    5a26:	0f be       	out	0x3f, r0	; 63
    5a28:	0f 90       	pop	r0
    5a2a:	1f 90       	pop	r1
    5a2c:	18 95       	reti

00005a2e <__vector_2>:
    if (port##cp) port##cp->int1();\
}

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
    5a2e:	1f 92       	push	r1
    5a30:	0f 92       	push	r0
    5a32:	0f b6       	in	r0, 0x3f	; 63
    5a34:	0f 92       	push	r0
    5a36:	08 b6       	in	r0, 0x38	; 56
    5a38:	0f 92       	push	r0
    5a3a:	09 b6       	in	r0, 0x39	; 57
    5a3c:	0f 92       	push	r0
    5a3e:	0b b6       	in	r0, 0x3b	; 59
    5a40:	0f 92       	push	r0
    5a42:	11 24       	eor	r1, r1
    5a44:	18 be       	out	0x38, r1	; 56
    5a46:	19 be       	out	0x39, r1	; 57
    5a48:	1b be       	out	0x3b, r1	; 59
    5a4a:	2f 93       	push	r18
    5a4c:	3f 93       	push	r19
    5a4e:	4f 93       	push	r20
    5a50:	5f 93       	push	r21
    5a52:	6f 93       	push	r22
    5a54:	7f 93       	push	r23
    5a56:	8f 93       	push	r24
    5a58:	9f 93       	push	r25
    5a5a:	af 93       	push	r26
    5a5c:	bf 93       	push	r27
    5a5e:	ef 93       	push	r30
    5a60:	ff 93       	push	r31
    5a62:	80 91 cf 2b 	lds	r24, 0x2BCF
    5a66:	90 91 d0 2b 	lds	r25, 0x2BD0
    5a6a:	00 97       	sbiw	r24, 0x00	; 0
    5a6c:	11 f0       	breq	.+4      	; 0x5a72 <__vector_2+0x44>
    5a6e:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    5a72:	ff 91       	pop	r31
    5a74:	ef 91       	pop	r30
    5a76:	bf 91       	pop	r27
    5a78:	af 91       	pop	r26
    5a7a:	9f 91       	pop	r25
    5a7c:	8f 91       	pop	r24
    5a7e:	7f 91       	pop	r23
    5a80:	6f 91       	pop	r22
    5a82:	5f 91       	pop	r21
    5a84:	4f 91       	pop	r20
    5a86:	3f 91       	pop	r19
    5a88:	2f 91       	pop	r18
    5a8a:	0f 90       	pop	r0
    5a8c:	0b be       	out	0x3b, r0	; 59
    5a8e:	0f 90       	pop	r0
    5a90:	09 be       	out	0x39, r0	; 57
    5a92:	0f 90       	pop	r0
    5a94:	08 be       	out	0x38, r0	; 56
    5a96:	0f 90       	pop	r0
    5a98:	0f be       	out	0x3f, r0	; 63
    5a9a:	0f 90       	pop	r0
    5a9c:	1f 90       	pop	r1
    5a9e:	18 95       	reti

00005aa0 <__vector_34>:
ISR(port##_INT1_vect) {\
    if (port##cp) port##cp->int1();\
}

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
    5aa0:	1f 92       	push	r1
    5aa2:	0f 92       	push	r0
    5aa4:	0f b6       	in	r0, 0x3f	; 63
    5aa6:	0f 92       	push	r0
    5aa8:	08 b6       	in	r0, 0x38	; 56
    5aaa:	0f 92       	push	r0
    5aac:	09 b6       	in	r0, 0x39	; 57
    5aae:	0f 92       	push	r0
    5ab0:	0b b6       	in	r0, 0x3b	; 59
    5ab2:	0f 92       	push	r0
    5ab4:	11 24       	eor	r1, r1
    5ab6:	18 be       	out	0x38, r1	; 56
    5ab8:	19 be       	out	0x39, r1	; 57
    5aba:	1b be       	out	0x3b, r1	; 59
    5abc:	2f 93       	push	r18
    5abe:	3f 93       	push	r19
    5ac0:	4f 93       	push	r20
    5ac2:	5f 93       	push	r21
    5ac4:	6f 93       	push	r22
    5ac6:	7f 93       	push	r23
    5ac8:	8f 93       	push	r24
    5aca:	9f 93       	push	r25
    5acc:	af 93       	push	r26
    5ace:	bf 93       	push	r27
    5ad0:	ef 93       	push	r30
    5ad2:	ff 93       	push	r31
    5ad4:	80 91 cd 2b 	lds	r24, 0x2BCD
    5ad8:	90 91 ce 2b 	lds	r25, 0x2BCE
    5adc:	00 97       	sbiw	r24, 0x00	; 0
    5ade:	11 f0       	breq	.+4      	; 0x5ae4 <__vector_34+0x44>
    5ae0:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    5ae4:	ff 91       	pop	r31
    5ae6:	ef 91       	pop	r30
    5ae8:	bf 91       	pop	r27
    5aea:	af 91       	pop	r26
    5aec:	9f 91       	pop	r25
    5aee:	8f 91       	pop	r24
    5af0:	7f 91       	pop	r23
    5af2:	6f 91       	pop	r22
    5af4:	5f 91       	pop	r21
    5af6:	4f 91       	pop	r20
    5af8:	3f 91       	pop	r19
    5afa:	2f 91       	pop	r18
    5afc:	0f 90       	pop	r0
    5afe:	0b be       	out	0x3b, r0	; 59
    5b00:	0f 90       	pop	r0
    5b02:	09 be       	out	0x39, r0	; 57
    5b04:	0f 90       	pop	r0
    5b06:	08 be       	out	0x38, r0	; 56
    5b08:	0f 90       	pop	r0
    5b0a:	0f be       	out	0x3f, r0	; 63
    5b0c:	0f 90       	pop	r0
    5b0e:	1f 90       	pop	r1
    5b10:	18 95       	reti

00005b12 <__vector_66>:
}\
ISR(port##_INT1_vect) {\
    if (port##cp) port##cp->int1();\
}

PORT_ISR_DEF(PORTA);
    5b12:	1f 92       	push	r1
    5b14:	0f 92       	push	r0
    5b16:	0f b6       	in	r0, 0x3f	; 63
    5b18:	0f 92       	push	r0
    5b1a:	08 b6       	in	r0, 0x38	; 56
    5b1c:	0f 92       	push	r0
    5b1e:	09 b6       	in	r0, 0x39	; 57
    5b20:	0f 92       	push	r0
    5b22:	0b b6       	in	r0, 0x3b	; 59
    5b24:	0f 92       	push	r0
    5b26:	11 24       	eor	r1, r1
    5b28:	18 be       	out	0x38, r1	; 56
    5b2a:	19 be       	out	0x39, r1	; 57
    5b2c:	1b be       	out	0x3b, r1	; 59
    5b2e:	2f 93       	push	r18
    5b30:	3f 93       	push	r19
    5b32:	4f 93       	push	r20
    5b34:	5f 93       	push	r21
    5b36:	6f 93       	push	r22
    5b38:	7f 93       	push	r23
    5b3a:	8f 93       	push	r24
    5b3c:	9f 93       	push	r25
    5b3e:	af 93       	push	r26
    5b40:	bf 93       	push	r27
    5b42:	ef 93       	push	r30
    5b44:	ff 93       	push	r31
    5b46:	80 91 cb 2b 	lds	r24, 0x2BCB
    5b4a:	90 91 cc 2b 	lds	r25, 0x2BCC
    5b4e:	00 97       	sbiw	r24, 0x00	; 0
    5b50:	11 f0       	breq	.+4      	; 0x5b56 <__vector_66+0x44>
    5b52:	0e 94 1c 2c 	call	0x5838	; 0x5838 <_ZN4Port4int0Ev>
    5b56:	ff 91       	pop	r31
    5b58:	ef 91       	pop	r30
    5b5a:	bf 91       	pop	r27
    5b5c:	af 91       	pop	r26
    5b5e:	9f 91       	pop	r25
    5b60:	8f 91       	pop	r24
    5b62:	7f 91       	pop	r23
    5b64:	6f 91       	pop	r22
    5b66:	5f 91       	pop	r21
    5b68:	4f 91       	pop	r20
    5b6a:	3f 91       	pop	r19
    5b6c:	2f 91       	pop	r18
    5b6e:	0f 90       	pop	r0
    5b70:	0b be       	out	0x3b, r0	; 59
    5b72:	0f 90       	pop	r0
    5b74:	09 be       	out	0x39, r0	; 57
    5b76:	0f 90       	pop	r0
    5b78:	08 be       	out	0x38, r0	; 56
    5b7a:	0f 90       	pop	r0
    5b7c:	0f be       	out	0x3f, r0	; 63
    5b7e:	0f 90       	pop	r0
    5b80:	1f 90       	pop	r1
    5b82:	18 95       	reti

00005b84 <_ZN4Port4int1Ev>:
        _pNotifyClient->PortISR0(_pNotifyID);
    }
    _pPort->INTFLAGS = 0x1;
}

void Port::int1()
    5b84:	cf 93       	push	r28
    5b86:	df 93       	push	r29
    5b88:	ec 01       	movw	r28, r24
{
    if (_pNotifyClient) {
    5b8a:	aa 81       	ldd	r26, Y+2	; 0x02
    5b8c:	bb 81       	ldd	r27, Y+3	; 0x03
    5b8e:	10 97       	sbiw	r26, 0x00	; 0
    5b90:	49 f0       	breq	.+18     	; 0x5ba4 <_ZN4Port4int1Ev+0x20>
        _pNotifyClient->PortISR1(_pNotifyID);
    5b92:	ed 91       	ld	r30, X+
    5b94:	fc 91       	ld	r31, X
    5b96:	11 97       	sbiw	r26, 0x01	; 1
    5b98:	02 80       	ldd	r0, Z+2	; 0x02
    5b9a:	f3 81       	ldd	r31, Z+3	; 0x03
    5b9c:	e0 2d       	mov	r30, r0
    5b9e:	cd 01       	movw	r24, r26
    5ba0:	6c 81       	ldd	r22, Y+4	; 0x04
    5ba2:	19 95       	eicall
    }
    _pPort->INTFLAGS = 0x2;
    5ba4:	e8 81       	ld	r30, Y
    5ba6:	f9 81       	ldd	r31, Y+1	; 0x01
    5ba8:	82 e0       	ldi	r24, 0x02	; 2
    5baa:	84 87       	std	Z+12, r24	; 0x0c
}
    5bac:	df 91       	pop	r29
    5bae:	cf 91       	pop	r28
    5bb0:	08 95       	ret

00005bb2 <__vector_97>:
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
PORT_ISR_DEF(PORTE);
PORT_ISR_DEF(PORTF);
#if defined (__AVR_ATxmega128A1__)
PORT_ISR_DEF(PORTH);
    5bb2:	1f 92       	push	r1
    5bb4:	0f 92       	push	r0
    5bb6:	0f b6       	in	r0, 0x3f	; 63
    5bb8:	0f 92       	push	r0
    5bba:	08 b6       	in	r0, 0x38	; 56
    5bbc:	0f 92       	push	r0
    5bbe:	09 b6       	in	r0, 0x39	; 57
    5bc0:	0f 92       	push	r0
    5bc2:	0b b6       	in	r0, 0x3b	; 59
    5bc4:	0f 92       	push	r0
    5bc6:	11 24       	eor	r1, r1
    5bc8:	18 be       	out	0x38, r1	; 56
    5bca:	19 be       	out	0x39, r1	; 57
    5bcc:	1b be       	out	0x3b, r1	; 59
    5bce:	2f 93       	push	r18
    5bd0:	3f 93       	push	r19
    5bd2:	4f 93       	push	r20
    5bd4:	5f 93       	push	r21
    5bd6:	6f 93       	push	r22
    5bd8:	7f 93       	push	r23
    5bda:	8f 93       	push	r24
    5bdc:	9f 93       	push	r25
    5bde:	af 93       	push	r26
    5be0:	bf 93       	push	r27
    5be2:	ef 93       	push	r30
    5be4:	ff 93       	push	r31
    5be6:	80 91 d7 2b 	lds	r24, 0x2BD7
    5bea:	90 91 d8 2b 	lds	r25, 0x2BD8
    5bee:	00 97       	sbiw	r24, 0x00	; 0
    5bf0:	11 f0       	breq	.+4      	; 0x5bf6 <__vector_97+0x44>
    5bf2:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5bf6:	ff 91       	pop	r31
    5bf8:	ef 91       	pop	r30
    5bfa:	bf 91       	pop	r27
    5bfc:	af 91       	pop	r26
    5bfe:	9f 91       	pop	r25
    5c00:	8f 91       	pop	r24
    5c02:	7f 91       	pop	r23
    5c04:	6f 91       	pop	r22
    5c06:	5f 91       	pop	r21
    5c08:	4f 91       	pop	r20
    5c0a:	3f 91       	pop	r19
    5c0c:	2f 91       	pop	r18
    5c0e:	0f 90       	pop	r0
    5c10:	0b be       	out	0x3b, r0	; 59
    5c12:	0f 90       	pop	r0
    5c14:	09 be       	out	0x39, r0	; 57
    5c16:	0f 90       	pop	r0
    5c18:	08 be       	out	0x38, r0	; 56
    5c1a:	0f 90       	pop	r0
    5c1c:	0f be       	out	0x3f, r0	; 63
    5c1e:	0f 90       	pop	r0
    5c20:	1f 90       	pop	r1
    5c22:	18 95       	reti

00005c24 <__vector_105>:
PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
PORT_ISR_DEF(PORTE);
PORT_ISR_DEF(PORTF);
    5c24:	1f 92       	push	r1
    5c26:	0f 92       	push	r0
    5c28:	0f b6       	in	r0, 0x3f	; 63
    5c2a:	0f 92       	push	r0
    5c2c:	08 b6       	in	r0, 0x38	; 56
    5c2e:	0f 92       	push	r0
    5c30:	09 b6       	in	r0, 0x39	; 57
    5c32:	0f 92       	push	r0
    5c34:	0b b6       	in	r0, 0x3b	; 59
    5c36:	0f 92       	push	r0
    5c38:	11 24       	eor	r1, r1
    5c3a:	18 be       	out	0x38, r1	; 56
    5c3c:	19 be       	out	0x39, r1	; 57
    5c3e:	1b be       	out	0x3b, r1	; 59
    5c40:	2f 93       	push	r18
    5c42:	3f 93       	push	r19
    5c44:	4f 93       	push	r20
    5c46:	5f 93       	push	r21
    5c48:	6f 93       	push	r22
    5c4a:	7f 93       	push	r23
    5c4c:	8f 93       	push	r24
    5c4e:	9f 93       	push	r25
    5c50:	af 93       	push	r26
    5c52:	bf 93       	push	r27
    5c54:	ef 93       	push	r30
    5c56:	ff 93       	push	r31
    5c58:	80 91 d5 2b 	lds	r24, 0x2BD5
    5c5c:	90 91 d6 2b 	lds	r25, 0x2BD6
    5c60:	00 97       	sbiw	r24, 0x00	; 0
    5c62:	11 f0       	breq	.+4      	; 0x5c68 <__vector_105+0x44>
    5c64:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5c68:	ff 91       	pop	r31
    5c6a:	ef 91       	pop	r30
    5c6c:	bf 91       	pop	r27
    5c6e:	af 91       	pop	r26
    5c70:	9f 91       	pop	r25
    5c72:	8f 91       	pop	r24
    5c74:	7f 91       	pop	r23
    5c76:	6f 91       	pop	r22
    5c78:	5f 91       	pop	r21
    5c7a:	4f 91       	pop	r20
    5c7c:	3f 91       	pop	r19
    5c7e:	2f 91       	pop	r18
    5c80:	0f 90       	pop	r0
    5c82:	0b be       	out	0x3b, r0	; 59
    5c84:	0f 90       	pop	r0
    5c86:	09 be       	out	0x39, r0	; 57
    5c88:	0f 90       	pop	r0
    5c8a:	08 be       	out	0x38, r0	; 56
    5c8c:	0f 90       	pop	r0
    5c8e:	0f be       	out	0x3f, r0	; 63
    5c90:	0f 90       	pop	r0
    5c92:	1f 90       	pop	r1
    5c94:	18 95       	reti

00005c96 <__vector_44>:

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
PORT_ISR_DEF(PORTE);
    5c96:	1f 92       	push	r1
    5c98:	0f 92       	push	r0
    5c9a:	0f b6       	in	r0, 0x3f	; 63
    5c9c:	0f 92       	push	r0
    5c9e:	08 b6       	in	r0, 0x38	; 56
    5ca0:	0f 92       	push	r0
    5ca2:	09 b6       	in	r0, 0x39	; 57
    5ca4:	0f 92       	push	r0
    5ca6:	0b b6       	in	r0, 0x3b	; 59
    5ca8:	0f 92       	push	r0
    5caa:	11 24       	eor	r1, r1
    5cac:	18 be       	out	0x38, r1	; 56
    5cae:	19 be       	out	0x39, r1	; 57
    5cb0:	1b be       	out	0x3b, r1	; 59
    5cb2:	2f 93       	push	r18
    5cb4:	3f 93       	push	r19
    5cb6:	4f 93       	push	r20
    5cb8:	5f 93       	push	r21
    5cba:	6f 93       	push	r22
    5cbc:	7f 93       	push	r23
    5cbe:	8f 93       	push	r24
    5cc0:	9f 93       	push	r25
    5cc2:	af 93       	push	r26
    5cc4:	bf 93       	push	r27
    5cc6:	ef 93       	push	r30
    5cc8:	ff 93       	push	r31
    5cca:	80 91 d3 2b 	lds	r24, 0x2BD3
    5cce:	90 91 d4 2b 	lds	r25, 0x2BD4
    5cd2:	00 97       	sbiw	r24, 0x00	; 0
    5cd4:	11 f0       	breq	.+4      	; 0x5cda <__vector_44+0x44>
    5cd6:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5cda:	ff 91       	pop	r31
    5cdc:	ef 91       	pop	r30
    5cde:	bf 91       	pop	r27
    5ce0:	af 91       	pop	r26
    5ce2:	9f 91       	pop	r25
    5ce4:	8f 91       	pop	r24
    5ce6:	7f 91       	pop	r23
    5ce8:	6f 91       	pop	r22
    5cea:	5f 91       	pop	r21
    5cec:	4f 91       	pop	r20
    5cee:	3f 91       	pop	r19
    5cf0:	2f 91       	pop	r18
    5cf2:	0f 90       	pop	r0
    5cf4:	0b be       	out	0x3b, r0	; 59
    5cf6:	0f 90       	pop	r0
    5cf8:	09 be       	out	0x39, r0	; 57
    5cfa:	0f 90       	pop	r0
    5cfc:	08 be       	out	0x38, r0	; 56
    5cfe:	0f 90       	pop	r0
    5d00:	0f be       	out	0x3f, r0	; 63
    5d02:	0f 90       	pop	r0
    5d04:	1f 90       	pop	r1
    5d06:	18 95       	reti

00005d08 <__vector_65>:
}

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
PORT_ISR_DEF(PORTD);
    5d08:	1f 92       	push	r1
    5d0a:	0f 92       	push	r0
    5d0c:	0f b6       	in	r0, 0x3f	; 63
    5d0e:	0f 92       	push	r0
    5d10:	08 b6       	in	r0, 0x38	; 56
    5d12:	0f 92       	push	r0
    5d14:	09 b6       	in	r0, 0x39	; 57
    5d16:	0f 92       	push	r0
    5d18:	0b b6       	in	r0, 0x3b	; 59
    5d1a:	0f 92       	push	r0
    5d1c:	11 24       	eor	r1, r1
    5d1e:	18 be       	out	0x38, r1	; 56
    5d20:	19 be       	out	0x39, r1	; 57
    5d22:	1b be       	out	0x3b, r1	; 59
    5d24:	2f 93       	push	r18
    5d26:	3f 93       	push	r19
    5d28:	4f 93       	push	r20
    5d2a:	5f 93       	push	r21
    5d2c:	6f 93       	push	r22
    5d2e:	7f 93       	push	r23
    5d30:	8f 93       	push	r24
    5d32:	9f 93       	push	r25
    5d34:	af 93       	push	r26
    5d36:	bf 93       	push	r27
    5d38:	ef 93       	push	r30
    5d3a:	ff 93       	push	r31
    5d3c:	80 91 d1 2b 	lds	r24, 0x2BD1
    5d40:	90 91 d2 2b 	lds	r25, 0x2BD2
    5d44:	00 97       	sbiw	r24, 0x00	; 0
    5d46:	11 f0       	breq	.+4      	; 0x5d4c <__vector_65+0x44>
    5d48:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5d4c:	ff 91       	pop	r31
    5d4e:	ef 91       	pop	r30
    5d50:	bf 91       	pop	r27
    5d52:	af 91       	pop	r26
    5d54:	9f 91       	pop	r25
    5d56:	8f 91       	pop	r24
    5d58:	7f 91       	pop	r23
    5d5a:	6f 91       	pop	r22
    5d5c:	5f 91       	pop	r21
    5d5e:	4f 91       	pop	r20
    5d60:	3f 91       	pop	r19
    5d62:	2f 91       	pop	r18
    5d64:	0f 90       	pop	r0
    5d66:	0b be       	out	0x3b, r0	; 59
    5d68:	0f 90       	pop	r0
    5d6a:	09 be       	out	0x39, r0	; 57
    5d6c:	0f 90       	pop	r0
    5d6e:	08 be       	out	0x38, r0	; 56
    5d70:	0f 90       	pop	r0
    5d72:	0f be       	out	0x3f, r0	; 63
    5d74:	0f 90       	pop	r0
    5d76:	1f 90       	pop	r1
    5d78:	18 95       	reti

00005d7a <__vector_3>:
    if (port##cp) port##cp->int1();\
}

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
PORT_ISR_DEF(PORTC);
    5d7a:	1f 92       	push	r1
    5d7c:	0f 92       	push	r0
    5d7e:	0f b6       	in	r0, 0x3f	; 63
    5d80:	0f 92       	push	r0
    5d82:	08 b6       	in	r0, 0x38	; 56
    5d84:	0f 92       	push	r0
    5d86:	09 b6       	in	r0, 0x39	; 57
    5d88:	0f 92       	push	r0
    5d8a:	0b b6       	in	r0, 0x3b	; 59
    5d8c:	0f 92       	push	r0
    5d8e:	11 24       	eor	r1, r1
    5d90:	18 be       	out	0x38, r1	; 56
    5d92:	19 be       	out	0x39, r1	; 57
    5d94:	1b be       	out	0x3b, r1	; 59
    5d96:	2f 93       	push	r18
    5d98:	3f 93       	push	r19
    5d9a:	4f 93       	push	r20
    5d9c:	5f 93       	push	r21
    5d9e:	6f 93       	push	r22
    5da0:	7f 93       	push	r23
    5da2:	8f 93       	push	r24
    5da4:	9f 93       	push	r25
    5da6:	af 93       	push	r26
    5da8:	bf 93       	push	r27
    5daa:	ef 93       	push	r30
    5dac:	ff 93       	push	r31
    5dae:	80 91 cf 2b 	lds	r24, 0x2BCF
    5db2:	90 91 d0 2b 	lds	r25, 0x2BD0
    5db6:	00 97       	sbiw	r24, 0x00	; 0
    5db8:	11 f0       	breq	.+4      	; 0x5dbe <__vector_3+0x44>
    5dba:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5dbe:	ff 91       	pop	r31
    5dc0:	ef 91       	pop	r30
    5dc2:	bf 91       	pop	r27
    5dc4:	af 91       	pop	r26
    5dc6:	9f 91       	pop	r25
    5dc8:	8f 91       	pop	r24
    5dca:	7f 91       	pop	r23
    5dcc:	6f 91       	pop	r22
    5dce:	5f 91       	pop	r21
    5dd0:	4f 91       	pop	r20
    5dd2:	3f 91       	pop	r19
    5dd4:	2f 91       	pop	r18
    5dd6:	0f 90       	pop	r0
    5dd8:	0b be       	out	0x3b, r0	; 59
    5dda:	0f 90       	pop	r0
    5ddc:	09 be       	out	0x39, r0	; 57
    5dde:	0f 90       	pop	r0
    5de0:	08 be       	out	0x38, r0	; 56
    5de2:	0f 90       	pop	r0
    5de4:	0f be       	out	0x3f, r0	; 63
    5de6:	0f 90       	pop	r0
    5de8:	1f 90       	pop	r1
    5dea:	18 95       	reti

00005dec <__vector_35>:
ISR(port##_INT1_vect) {\
    if (port##cp) port##cp->int1();\
}

PORT_ISR_DEF(PORTA);
PORT_ISR_DEF(PORTB);
    5dec:	1f 92       	push	r1
    5dee:	0f 92       	push	r0
    5df0:	0f b6       	in	r0, 0x3f	; 63
    5df2:	0f 92       	push	r0
    5df4:	08 b6       	in	r0, 0x38	; 56
    5df6:	0f 92       	push	r0
    5df8:	09 b6       	in	r0, 0x39	; 57
    5dfa:	0f 92       	push	r0
    5dfc:	0b b6       	in	r0, 0x3b	; 59
    5dfe:	0f 92       	push	r0
    5e00:	11 24       	eor	r1, r1
    5e02:	18 be       	out	0x38, r1	; 56
    5e04:	19 be       	out	0x39, r1	; 57
    5e06:	1b be       	out	0x3b, r1	; 59
    5e08:	2f 93       	push	r18
    5e0a:	3f 93       	push	r19
    5e0c:	4f 93       	push	r20
    5e0e:	5f 93       	push	r21
    5e10:	6f 93       	push	r22
    5e12:	7f 93       	push	r23
    5e14:	8f 93       	push	r24
    5e16:	9f 93       	push	r25
    5e18:	af 93       	push	r26
    5e1a:	bf 93       	push	r27
    5e1c:	ef 93       	push	r30
    5e1e:	ff 93       	push	r31
    5e20:	80 91 cd 2b 	lds	r24, 0x2BCD
    5e24:	90 91 ce 2b 	lds	r25, 0x2BCE
    5e28:	00 97       	sbiw	r24, 0x00	; 0
    5e2a:	11 f0       	breq	.+4      	; 0x5e30 <__vector_35+0x44>
    5e2c:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5e30:	ff 91       	pop	r31
    5e32:	ef 91       	pop	r30
    5e34:	bf 91       	pop	r27
    5e36:	af 91       	pop	r26
    5e38:	9f 91       	pop	r25
    5e3a:	8f 91       	pop	r24
    5e3c:	7f 91       	pop	r23
    5e3e:	6f 91       	pop	r22
    5e40:	5f 91       	pop	r21
    5e42:	4f 91       	pop	r20
    5e44:	3f 91       	pop	r19
    5e46:	2f 91       	pop	r18
    5e48:	0f 90       	pop	r0
    5e4a:	0b be       	out	0x3b, r0	; 59
    5e4c:	0f 90       	pop	r0
    5e4e:	09 be       	out	0x39, r0	; 57
    5e50:	0f 90       	pop	r0
    5e52:	08 be       	out	0x38, r0	; 56
    5e54:	0f 90       	pop	r0
    5e56:	0f be       	out	0x3f, r0	; 63
    5e58:	0f 90       	pop	r0
    5e5a:	1f 90       	pop	r1
    5e5c:	18 95       	reti

00005e5e <__vector_67>:
}\
ISR(port##_INT1_vect) {\
    if (port##cp) port##cp->int1();\
}

PORT_ISR_DEF(PORTA);
    5e5e:	1f 92       	push	r1
    5e60:	0f 92       	push	r0
    5e62:	0f b6       	in	r0, 0x3f	; 63
    5e64:	0f 92       	push	r0
    5e66:	08 b6       	in	r0, 0x38	; 56
    5e68:	0f 92       	push	r0
    5e6a:	09 b6       	in	r0, 0x39	; 57
    5e6c:	0f 92       	push	r0
    5e6e:	0b b6       	in	r0, 0x3b	; 59
    5e70:	0f 92       	push	r0
    5e72:	11 24       	eor	r1, r1
    5e74:	18 be       	out	0x38, r1	; 56
    5e76:	19 be       	out	0x39, r1	; 57
    5e78:	1b be       	out	0x3b, r1	; 59
    5e7a:	2f 93       	push	r18
    5e7c:	3f 93       	push	r19
    5e7e:	4f 93       	push	r20
    5e80:	5f 93       	push	r21
    5e82:	6f 93       	push	r22
    5e84:	7f 93       	push	r23
    5e86:	8f 93       	push	r24
    5e88:	9f 93       	push	r25
    5e8a:	af 93       	push	r26
    5e8c:	bf 93       	push	r27
    5e8e:	ef 93       	push	r30
    5e90:	ff 93       	push	r31
    5e92:	80 91 cb 2b 	lds	r24, 0x2BCB
    5e96:	90 91 cc 2b 	lds	r25, 0x2BCC
    5e9a:	00 97       	sbiw	r24, 0x00	; 0
    5e9c:	11 f0       	breq	.+4      	; 0x5ea2 <__vector_67+0x44>
    5e9e:	0e 94 c2 2d 	call	0x5b84	; 0x5b84 <_ZN4Port4int1Ev>
    5ea2:	ff 91       	pop	r31
    5ea4:	ef 91       	pop	r30
    5ea6:	bf 91       	pop	r27
    5ea8:	af 91       	pop	r26
    5eaa:	9f 91       	pop	r25
    5eac:	8f 91       	pop	r24
    5eae:	7f 91       	pop	r23
    5eb0:	6f 91       	pop	r22
    5eb2:	5f 91       	pop	r21
    5eb4:	4f 91       	pop	r20
    5eb6:	3f 91       	pop	r19
    5eb8:	2f 91       	pop	r18
    5eba:	0f 90       	pop	r0
    5ebc:	0b be       	out	0x3b, r0	; 59
    5ebe:	0f 90       	pop	r0
    5ec0:	09 be       	out	0x39, r0	; 57
    5ec2:	0f 90       	pop	r0
    5ec4:	08 be       	out	0x38, r0	; 56
    5ec6:	0f 90       	pop	r0
    5ec8:	0f be       	out	0x3f, r0	; 63
    5eca:	0f 90       	pop	r0
    5ecc:	1f 90       	pop	r1
    5ece:	18 95       	reti

00005ed0 <_ZN4Port6SetDirEh>:
        _pNotifyClient->PortISR1(_pNotifyID);
    }
    _pPort->INTFLAGS = 0x2;
}

void Port::SetDir(uint8_t dir)
    5ed0:	fc 01       	movw	r30, r24
{
    _pPort->DIR = dir;
    5ed2:	01 90       	ld	r0, Z+
    5ed4:	f0 81       	ld	r31, Z
    5ed6:	e0 2d       	mov	r30, r0
    5ed8:	60 83       	st	Z, r22
}
    5eda:	08 95       	ret

00005edc <_ZN4Port14SetPinsAsInputEh>:

void Port::SetPinsAsInput(uint8_t mask)
    5edc:	fc 01       	movw	r30, r24
{
    _pPort->DIRCLR = mask;
    5ede:	01 90       	ld	r0, Z+
    5ee0:	f0 81       	ld	r31, Z
    5ee2:	e0 2d       	mov	r30, r0
    5ee4:	62 83       	std	Z+2, r22	; 0x02
}
    5ee6:	08 95       	ret

00005ee8 <_ZN4Port15SetPinsAsOutputEh>:

void Port::SetPinsAsOutput(uint8_t mask)
    5ee8:	fc 01       	movw	r30, r24
{
    _pPort->DIRSET = mask;
    5eea:	01 90       	ld	r0, Z+
    5eec:	f0 81       	ld	r31, Z
    5eee:	e0 2d       	mov	r30, r0
    5ef0:	61 83       	std	Z+1, r22	; 0x01
}
    5ef2:	08 95       	ret

00005ef4 <_ZN4Port11SetPinsHighEh>:

void Port::SetPinsHigh(uint8_t mask)
    5ef4:	fc 01       	movw	r30, r24
{
    _pPort->OUTSET = mask;
    5ef6:	01 90       	ld	r0, Z+
    5ef8:	f0 81       	ld	r31, Z
    5efa:	e0 2d       	mov	r30, r0
    5efc:	65 83       	std	Z+5, r22	; 0x05
}
    5efe:	08 95       	ret

00005f00 <_ZN4Port10SetPinsLowEh>:

void Port::SetPinsLow(uint8_t mask)
    5f00:	fc 01       	movw	r30, r24
{
    _pPort->OUTCLR = mask;
    5f02:	01 90       	ld	r0, Z+
    5f04:	f0 81       	ld	r31, Z
    5f06:	e0 2d       	mov	r30, r0
    5f08:	66 83       	std	Z+6, r22	; 0x06
}
    5f0a:	08 95       	ret

00005f0c <_ZN4Port7GetPinsEv>:

uint8_t Port::GetPins()
    5f0c:	fc 01       	movw	r30, r24
{
    return _pPort->IN;
    5f0e:	01 90       	ld	r0, Z+
    5f10:	f0 81       	ld	r31, Z
    5f12:	e0 2d       	mov	r30, r0
    5f14:	80 85       	ldd	r24, Z+8	; 0x08
}
    5f16:	08 95       	ret

00005f18 <_ZN4Port14InterruptLevelEhh>:

void Port::InterruptLevel(uint8_t num, uint8_t lvl)
    5f18:	fc 01       	movw	r30, r24
    5f1a:	a0 81       	ld	r26, Z
    5f1c:	b1 81       	ldd	r27, Z+1	; 0x01
{
    if (num == 0) {
    5f1e:	66 23       	and	r22, r22
    5f20:	71 f4       	brne	.+28     	; 0x5f3e <_ZN4Port14InterruptLevelEhh+0x26>
        _pPort->INTCTRL &= ~(0x3);
    5f22:	19 96       	adiw	r26, 0x09	; 9
    5f24:	8c 91       	ld	r24, X
    5f26:	19 97       	sbiw	r26, 0x09	; 9
    5f28:	8c 7f       	andi	r24, 0xFC	; 252
    5f2a:	19 96       	adiw	r26, 0x09	; 9
    5f2c:	8c 93       	st	X, r24
        _pPort->INTCTRL |= (lvl & 0x3);
    5f2e:	01 90       	ld	r0, Z+
    5f30:	f0 81       	ld	r31, Z
    5f32:	e0 2d       	mov	r30, r0
    5f34:	81 85       	ldd	r24, Z+9	; 0x09
    5f36:	43 70       	andi	r20, 0x03	; 3
    5f38:	84 2b       	or	r24, r20
    5f3a:	81 87       	std	Z+9, r24	; 0x09
    5f3c:	08 95       	ret
    } else {
        _pPort->INTCTRL &= ~(0xC);
    5f3e:	19 96       	adiw	r26, 0x09	; 9
    5f40:	8c 91       	ld	r24, X
    5f42:	19 97       	sbiw	r26, 0x09	; 9
    5f44:	83 7f       	andi	r24, 0xF3	; 243
    5f46:	19 96       	adiw	r26, 0x09	; 9
    5f48:	8c 93       	st	X, r24
        _pPort->INTCTRL |= (lvl & 0x3) << 2;
    5f4a:	01 90       	ld	r0, Z+
    5f4c:	f0 81       	ld	r31, Z
    5f4e:	e0 2d       	mov	r30, r0
    5f50:	21 85       	ldd	r18, Z+9	; 0x09
    5f52:	84 2f       	mov	r24, r20
    5f54:	90 e0       	ldi	r25, 0x00	; 0
    5f56:	83 70       	andi	r24, 0x03	; 3
    5f58:	90 70       	andi	r25, 0x00	; 0
    5f5a:	88 0f       	add	r24, r24
    5f5c:	99 1f       	adc	r25, r25
    5f5e:	88 0f       	add	r24, r24
    5f60:	99 1f       	adc	r25, r25
    5f62:	28 2b       	or	r18, r24
    5f64:	21 87       	std	Z+9, r18	; 0x09
    5f66:	08 95       	ret

00005f68 <_ZN4Port13InterruptMaskEhh>:
    }
}

void Port::InterruptMask(uint8_t num, uint8_t mask)
    5f68:	fc 01       	movw	r30, r24
    5f6a:	01 90       	ld	r0, Z+
    5f6c:	f0 81       	ld	r31, Z
    5f6e:	e0 2d       	mov	r30, r0
{
    if (num == 0) {
    5f70:	66 23       	and	r22, r22
    5f72:	11 f4       	brne	.+4      	; 0x5f78 <_ZN4Port13InterruptMaskEhh+0x10>
        _pPort->INT0MASK = mask;
    5f74:	42 87       	std	Z+10, r20	; 0x0a
    5f76:	08 95       	ret
    } else {
        _pPort->INT1MASK = mask;
    5f78:	43 87       	std	Z+11, r20	; 0x0b
    5f7a:	08 95       	ret

00005f7c <_ZN4Port10PinControlEhbb13PORT_OPC_enum13PORT_ISC_enum>:
void Port::PinControl(uint8_t mask, 
        bool bSlewLimit,
        bool bInverted,
        PORT_OPC_t OutputConfig,
        PORT_ISC_t InputSense
        )
    5f7c:	ef 92       	push	r14
    5f7e:	0f 93       	push	r16
    5f80:	fc 01       	movw	r30, r24
    //! of the mask high, then configure any of the PINxCTRL
    //! registers, and only the pins specified in the mask get
    //! configured. Also, they all get the same config, so it's
    //! faster. It does not matter if I am actually configuring
    //! pin 0 or not, even though I specify PN0CTRL.
    PORTCFG.MPCMASK = mask;
    5f82:	60 93 b0 00 	sts	0x00B0, r22
    _pPort->PIN0CTRL = 
        (bSlewLimit ? 0x80 : 0x0) |
        (bInverted ? 0x40 : 0x0)  |
        OutputConfig | 
        InputSense
        ;
    5f86:	01 90       	ld	r0, Z+
    5f88:	f0 81       	ld	r31, Z
    5f8a:	e0 2d       	mov	r30, r0
    5f8c:	44 23       	and	r20, r20
    5f8e:	11 f4       	brne	.+4      	; 0x5f94 <_ZN4Port10PinControlEhbb13PORT_OPC_enum13PORT_ISC_enum+0x18>
    5f90:	90 e0       	ldi	r25, 0x00	; 0
    5f92:	01 c0       	rjmp	.+2      	; 0x5f96 <_ZN4Port10PinControlEhbb13PORT_OPC_enum13PORT_ISC_enum+0x1a>
    5f94:	90 e8       	ldi	r25, 0x80	; 128
    5f96:	22 23       	and	r18, r18
    5f98:	11 f4       	brne	.+4      	; 0x5f9e <_ZN4Port10PinControlEhbb13PORT_OPC_enum13PORT_ISC_enum+0x22>
    5f9a:	80 e0       	ldi	r24, 0x00	; 0
    5f9c:	01 c0       	rjmp	.+2      	; 0x5fa0 <_ZN4Port10PinControlEhbb13PORT_OPC_enum13PORT_ISC_enum+0x24>
    5f9e:	80 e4       	ldi	r24, 0x40	; 64
    5fa0:	e0 2a       	or	r14, r16
    5fa2:	9e 29       	or	r25, r14
    5fa4:	89 2b       	or	r24, r25
    5fa6:	80 8b       	std	Z+16, r24	; 0x10
}
    5fa8:	0f 91       	pop	r16
    5faa:	ef 90       	pop	r14
    5fac:	08 95       	ret

00005fae <__cxa_guard_acquire>:
#include "cpp_hacks.h"

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);}; 
    5fae:	fc 01       	movw	r30, r24
    5fb0:	20 e0       	ldi	r18, 0x00	; 0
    5fb2:	30 e0       	ldi	r19, 0x00	; 0
    5fb4:	80 81       	ld	r24, Z
    5fb6:	88 23       	and	r24, r24
    5fb8:	11 f4       	brne	.+4      	; 0x5fbe <__cxa_guard_acquire+0x10>
    5fba:	21 e0       	ldi	r18, 0x01	; 1
    5fbc:	30 e0       	ldi	r19, 0x00	; 0
    5fbe:	c9 01       	movw	r24, r18
    5fc0:	08 95       	ret

00005fc2 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;}; 
    5fc2:	fc 01       	movw	r30, r24
    5fc4:	81 e0       	ldi	r24, 0x01	; 1
    5fc6:	80 83       	st	Z, r24
    5fc8:	08 95       	ret

00005fca <__cxa_guard_abort>:
void __cxa_guard_abort (__guard *) {}; 
    5fca:	08 95       	ret

00005fcc <__cxa_pure_virtual>:

void __cxa_pure_virtual(void) {}; 
    5fcc:	08 95       	ret

00005fce <_ZN4Fifo5clearEv>:
    _pdata = (FifoType*)malloc(_size * sizeof(FifoType));
    clear();
}

//! Clear the fifo by resetting the start and end pointer.
void Fifo::clear()
    5fce:	fc 01       	movw	r30, r24
{
    _start = _end = _pdata;
    5fd0:	80 81       	ld	r24, Z
    5fd2:	91 81       	ldd	r25, Z+1	; 0x01
    5fd4:	84 83       	std	Z+4, r24	; 0x04
    5fd6:	95 83       	std	Z+5, r25	; 0x05
    5fd8:	82 83       	std	Z+2, r24	; 0x02
    5fda:	93 83       	std	Z+3, r25	; 0x03
}
    5fdc:	08 95       	ret

00005fde <_ZN4Fifo5countEv>:
//! In this case end < start, so data wraps around. The total count is equal to the
//! size of the buffer, minus the number of blank spots, or
//! \f$size - (start - end)\f$.<p>
//! The total number of possible elements that can be stored is size -1, so
//! 
uint8_t Fifo::count()
    5fde:	fc 01       	movw	r30, r24
{
    if (_end == _start) return 0;
    5fe0:	44 81       	ldd	r20, Z+4	; 0x04
    5fe2:	55 81       	ldd	r21, Z+5	; 0x05
    5fe4:	22 81       	ldd	r18, Z+2	; 0x02
    5fe6:	33 81       	ldd	r19, Z+3	; 0x03
    5fe8:	42 17       	cp	r20, r18
    5fea:	53 07       	cpc	r21, r19
    5fec:	11 f4       	brne	.+4      	; 0x5ff2 <_ZN4Fifo5countEv+0x14>
    5fee:	80 e0       	ldi	r24, 0x00	; 0
    5ff0:	08 95       	ret
    if (_end > _start) {
    5ff2:	24 17       	cp	r18, r20
    5ff4:	35 07       	cpc	r19, r21
    5ff6:	18 f4       	brcc	.+6      	; 0x5ffe <_ZN4Fifo5countEv+0x20>
        return _end - _start;
    5ff8:	84 2f       	mov	r24, r20
    5ffa:	82 1b       	sub	r24, r18
    5ffc:	08 95       	ret
    }
    return _size - (_start - _end);
    5ffe:	86 81       	ldd	r24, Z+6	; 0x06
    6000:	84 0f       	add	r24, r20
    6002:	82 1b       	sub	r24, r18
}
    6004:	08 95       	ret

00006006 <_ZN4Fifo4fullEv>:

//! Return true if the fifo is full.
bool Fifo::full()
    6006:	fc 01       	movw	r30, r24
{
    return (_start - _end)  == 1 || (_end - _start) == _size;
    6008:	42 81       	ldd	r20, Z+2	; 0x02
    600a:	53 81       	ldd	r21, Z+3	; 0x03
    600c:	24 81       	ldd	r18, Z+4	; 0x04
    600e:	35 81       	ldd	r19, Z+5	; 0x05
    6010:	ca 01       	movw	r24, r20
    6012:	82 1b       	sub	r24, r18
    6014:	93 0b       	sbc	r25, r19
    6016:	01 97       	sbiw	r24, 0x01	; 1
    6018:	41 f0       	breq	.+16     	; 0x602a <_ZN4Fifo4fullEv+0x24>
    601a:	60 e0       	ldi	r22, 0x00	; 0
    601c:	24 1b       	sub	r18, r20
    601e:	35 0b       	sbc	r19, r21
    6020:	86 81       	ldd	r24, Z+6	; 0x06
    6022:	90 e0       	ldi	r25, 0x00	; 0
    6024:	28 17       	cp	r18, r24
    6026:	39 07       	cpc	r19, r25
    6028:	09 f4       	brne	.+2      	; 0x602c <_ZN4Fifo4fullEv+0x26>
    602a:	61 e0       	ldi	r22, 0x01	; 1
}
    602c:	86 2f       	mov	r24, r22
    602e:	08 95       	ret

00006030 <_ZN4Fifo5emptyEv>:

//! Return true if the fifo is empty.
bool Fifo::empty()
    6030:	fc 01       	movw	r30, r24
    6032:	40 e0       	ldi	r20, 0x00	; 0
    6034:	22 81       	ldd	r18, Z+2	; 0x02
    6036:	33 81       	ldd	r19, Z+3	; 0x03
    6038:	84 81       	ldd	r24, Z+4	; 0x04
    603a:	95 81       	ldd	r25, Z+5	; 0x05
    603c:	28 17       	cp	r18, r24
    603e:	39 07       	cpc	r19, r25
    6040:	09 f4       	brne	.+2      	; 0x6044 <_ZN4Fifo5emptyEv+0x14>
    6042:	41 e0       	ldi	r20, 0x01	; 1
{
    return (_start == _end);
}
    6044:	84 2f       	mov	r24, r20
    6046:	08 95       	ret

00006048 <_ZN4Fifo4pushEPh>:

//! Push a new value onto the fifo. 
//! This function returns 0 if the operation succeeds, and a negative
//! value if the operation fails.
int8_t Fifo::push(FifoType* d) 
    6048:	cf 93       	push	r28
    604a:	df 93       	push	r29
    604c:	dc 01       	movw	r26, r24
    604e:	eb 01       	movw	r28, r22
}

//! Return true if the fifo is full.
bool Fifo::full()
{
    return (_start - _end)  == 1 || (_end - _start) == _size;
    6050:	12 96       	adiw	r26, 0x02	; 2
    6052:	2d 91       	ld	r18, X+
    6054:	3c 91       	ld	r19, X
    6056:	13 97       	sbiw	r26, 0x03	; 3
    6058:	14 96       	adiw	r26, 0x04	; 4
    605a:	ed 91       	ld	r30, X+
    605c:	fc 91       	ld	r31, X
    605e:	15 97       	sbiw	r26, 0x05	; 5
    6060:	c9 01       	movw	r24, r18
    6062:	8e 1b       	sub	r24, r30
    6064:	9f 0b       	sbc	r25, r31
    6066:	01 97       	sbiw	r24, 0x01	; 1
    6068:	89 f0       	breq	.+34     	; 0x608c <_ZN4Fifo4pushEPh+0x44>
    606a:	cf 01       	movw	r24, r30
    606c:	82 1b       	sub	r24, r18
    606e:	93 0b       	sbc	r25, r19
    6070:	9c 01       	movw	r18, r24
    6072:	16 96       	adiw	r26, 0x06	; 6
    6074:	8c 91       	ld	r24, X
    6076:	16 97       	sbiw	r26, 0x06	; 6
    6078:	90 e0       	ldi	r25, 0x00	; 0
    607a:	28 17       	cp	r18, r24
    607c:	39 07       	cpc	r19, r25
    607e:	51 f4       	brne	.+20     	; 0x6094 <_ZN4Fifo4pushEPh+0x4c>
    6080:	05 c0       	rjmp	.+10     	; 0x608c <_ZN4Fifo4pushEPh+0x44>
    if (full()) return -1;
    *(_end++) = *d;
    
    // Wrap the end back to the beginning.
    if ((_end - _pdata) > _size) {
        _end = _pdata;
    6082:	14 96       	adiw	r26, 0x04	; 4
    6084:	2d 93       	st	X+, r18
    6086:	3c 93       	st	X, r19
    6088:	15 97       	sbiw	r26, 0x05	; 5
    608a:	16 c0       	rjmp	.+44     	; 0x60b8 <_ZN4Fifo4pushEPh+0x70>
    608c:	8f ef       	ldi	r24, 0xFF	; 255
    }

	return 0;
}
    608e:	df 91       	pop	r29
    6090:	cf 91       	pop	r28
    6092:	08 95       	ret
//! This function returns 0 if the operation succeeds, and a negative
//! value if the operation fails.
int8_t Fifo::push(FifoType* d) 
{
    if (full()) return -1;
    *(_end++) = *d;
    6094:	88 81       	ld	r24, Y
    6096:	81 93       	st	Z+, r24
    6098:	14 96       	adiw	r26, 0x04	; 4
    609a:	ed 93       	st	X+, r30
    609c:	fc 93       	st	X, r31
    609e:	15 97       	sbiw	r26, 0x05	; 5
    
    // Wrap the end back to the beginning.
    if ((_end - _pdata) > _size) {
    60a0:	2d 91       	ld	r18, X+
    60a2:	3c 91       	ld	r19, X
    60a4:	11 97       	sbiw	r26, 0x01	; 1
    60a6:	e2 1b       	sub	r30, r18
    60a8:	f3 0b       	sbc	r31, r19
    60aa:	16 96       	adiw	r26, 0x06	; 6
    60ac:	8c 91       	ld	r24, X
    60ae:	16 97       	sbiw	r26, 0x06	; 6
    60b0:	90 e0       	ldi	r25, 0x00	; 0
    60b2:	8e 17       	cp	r24, r30
    60b4:	9f 07       	cpc	r25, r31
    60b6:	2c f3       	brlt	.-54     	; 0x6082 <_ZN4Fifo4pushEPh+0x3a>
    60b8:	80 e0       	ldi	r24, 0x00	; 0
    60ba:	e9 cf       	rjmp	.-46     	; 0x608e <_ZN4Fifo4pushEPh+0x46>

000060bc <_ZN4Fifo3popEPh>:
//! Remove the top value from the Fifo. 
//! We do not have exceptions in this simple C++ implementation, so this function
//! is not able to do anything to indicate that the called tried to pop a value
//! from an empty fifo. In that case, a zero value is returned, which is not unique
//! so the caller will have to insure that pop is never called on an empty fifo.
int8_t Fifo::pop(FifoType* pD) 
    60bc:	cf 93       	push	r28
    60be:	df 93       	push	r29
    60c0:	dc 01       	movw	r26, r24
    60c2:	eb 01       	movw	r28, r22
}

//! Return true if the fifo is empty.
bool Fifo::empty()
{
    return (_start == _end);
    60c4:	12 96       	adiw	r26, 0x02	; 2
    60c6:	ed 91       	ld	r30, X+
    60c8:	fc 91       	ld	r31, X
    60ca:	13 97       	sbiw	r26, 0x03	; 3
//! is not able to do anything to indicate that the called tried to pop a value
//! from an empty fifo. In that case, a zero value is returned, which is not unique
//! so the caller will have to insure that pop is never called on an empty fifo.
int8_t Fifo::pop(FifoType* pD) 
{
    if (empty()) {
    60cc:	14 96       	adiw	r26, 0x04	; 4
    60ce:	8d 91       	ld	r24, X+
    60d0:	9c 91       	ld	r25, X
    60d2:	15 97       	sbiw	r26, 0x05	; 5
    60d4:	e8 17       	cp	r30, r24
    60d6:	f9 07       	cpc	r31, r25
    60d8:	11 f4       	brne	.+4      	; 0x60de <_ZN4Fifo3popEPh+0x22>
    60da:	8f ef       	ldi	r24, 0xFF	; 255
    60dc:	17 c0       	rjmp	.+46     	; 0x610c <_ZN4Fifo3popEPh+0x50>
        return -1; // Nothing else to do
    }
    *pD = *(_start++);
    60de:	81 91       	ld	r24, Z+
    60e0:	88 83       	st	Y, r24
    60e2:	12 96       	adiw	r26, 0x02	; 2
    60e4:	ed 93       	st	X+, r30
    60e6:	fc 93       	st	X, r31
    60e8:	13 97       	sbiw	r26, 0x03	; 3
    if ((_start - _pdata) > _size) {
    60ea:	2d 91       	ld	r18, X+
    60ec:	3c 91       	ld	r19, X
    60ee:	11 97       	sbiw	r26, 0x01	; 1
    60f0:	e2 1b       	sub	r30, r18
    60f2:	f3 0b       	sbc	r31, r19
    60f4:	16 96       	adiw	r26, 0x06	; 6
    60f6:	8c 91       	ld	r24, X
    60f8:	16 97       	sbiw	r26, 0x06	; 6
    60fa:	90 e0       	ldi	r25, 0x00	; 0
    60fc:	8e 17       	cp	r24, r30
    60fe:	9f 07       	cpc	r25, r31
    6100:	24 f4       	brge	.+8      	; 0x610a <_ZN4Fifo3popEPh+0x4e>
        _start = _pdata;
    6102:	12 96       	adiw	r26, 0x02	; 2
    6104:	2d 93       	st	X+, r18
    6106:	3c 93       	st	X, r19
    6108:	13 97       	sbiw	r26, 0x03	; 3
    610a:	80 e0       	ldi	r24, 0x00	; 0
    }
    return 0;
}
    610c:	df 91       	pop	r29
    610e:	cf 91       	pop	r28
    6110:	08 95       	ret

00006112 <_ZN4FifoC1Eh>:
//! Allocate memory for the specified number of elements
//! and set the internal value to indicate the size of the fifo.
//! Reset the start and end data points to their clear state. The
//! clear function is called to maintain consitency and insure that
//! clear() always does the right thing.
Fifo::Fifo(uint8_t size)
    6112:	0f 93       	push	r16
    6114:	1f 93       	push	r17
    6116:	8c 01       	movw	r16, r24
    6118:	86 2f       	mov	r24, r22
{
    _size = size;
    611a:	f8 01       	movw	r30, r16
    611c:	66 83       	std	Z+6, r22	; 0x06
    _pdata = (FifoType*)malloc(_size * sizeof(FifoType));
    611e:	90 e0       	ldi	r25, 0x00	; 0
    6120:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    6124:	f8 01       	movw	r30, r16
    6126:	80 83       	st	Z, r24
    6128:	91 83       	std	Z+1, r25	; 0x01
}

//! Clear the fifo by resetting the start and end pointer.
void Fifo::clear()
{
    _start = _end = _pdata;
    612a:	84 83       	std	Z+4, r24	; 0x04
    612c:	95 83       	std	Z+5, r25	; 0x05
    612e:	82 83       	std	Z+2, r24	; 0x02
    6130:	93 83       	std	Z+3, r25	; 0x03
Fifo::Fifo(uint8_t size)
{
    _size = size;
    _pdata = (FifoType*)malloc(_size * sizeof(FifoType));
    clear();
}
    6132:	1f 91       	pop	r17
    6134:	0f 91       	pop	r16
    6136:	08 95       	ret

00006138 <_Z8FifoTestR14HardwareSerial>:
//! It is always a good idea to validate your data structures. Languages like
//! Python or Perl have such validation built in, while C++ does not. This function
//! can be used in a special build to run through some test cases and make sure
//! that the fifo behaves as we exect, especially in the edge cases, such as when
//! it gets full, wraps around, etc.
void FifoTest(HardwareSerial& ds)
    6138:	6f 92       	push	r6
    613a:	7f 92       	push	r7
    613c:	8f 92       	push	r8
    613e:	9f 92       	push	r9
    6140:	af 92       	push	r10
    6142:	bf 92       	push	r11
    6144:	cf 92       	push	r12
    6146:	df 92       	push	r13
    6148:	ef 92       	push	r14
    614a:	ff 92       	push	r15
    614c:	0f 93       	push	r16
    614e:	1f 93       	push	r17
    6150:	df 93       	push	r29
    6152:	cf 93       	push	r28
    6154:	cd b7       	in	r28, 0x3d	; 61
    6156:	de b7       	in	r29, 0x3e	; 62
    6158:	c9 58       	subi	r28, 0x89	; 137
    615a:	d0 40       	sbci	r29, 0x00	; 0
    615c:	cd bf       	out	0x3d, r28	; 61
    615e:	de bf       	out	0x3e, r29	; 62
    6160:	5c 01       	movw	r10, r24
{
    Fifo f1(20);
    6162:	8e 01       	movw	r16, r28
    6164:	0d 5f       	subi	r16, 0xFD	; 253
    6166:	1f 4f       	sbci	r17, 0xFF	; 255
    6168:	c8 01       	movw	r24, r16
    616a:	64 e1       	ldi	r22, 0x14	; 20
    616c:	0e 94 89 30 	call	0x6112	; 0x6112 <_ZN4FifoC1Eh>
    Fifo::FifoType x;
    char    buffer[128];
    
    for (x=1;x<25;x++) {
    6170:	81 e0       	ldi	r24, 0x01	; 1
    6172:	89 83       	std	Y+1, r24	; 0x01
    6174:	4a e0       	ldi	r20, 0x0A	; 10
    6176:	e4 2e       	mov	r14, r20
    6178:	f1 2c       	mov	r15, r1
    617a:	ec 0e       	add	r14, r28
    617c:	fd 1e       	adc	r15, r29
        f1.push(&x);
    617e:	4e 01       	movw	r8, r28
    6180:	08 94       	sec
    6182:	81 1c       	adc	r8, r1
    6184:	91 1c       	adc	r9, r1
        sprintf(buffer,"Fifo push %d count %d\n",x,f1.count());
    6186:	33 eb       	ldi	r19, 0xB3	; 179
    6188:	c3 2e       	mov	r12, r19
    618a:	34 e2       	ldi	r19, 0x24	; 36
    618c:	d3 2e       	mov	r13, r19
    618e:	2c c0       	rjmp	.+88     	; 0x61e8 <_Z8FifoTestR14HardwareSerial+0xb0>
    Fifo f1(20);
    Fifo::FifoType x;
    char    buffer[128];
    
    for (x=1;x<25;x++) {
        f1.push(&x);
    6190:	c8 01       	movw	r24, r16
    6192:	b4 01       	movw	r22, r8
    6194:	0e 94 24 30 	call	0x6048	; 0x6048 <_ZN4Fifo4pushEPh>
        sprintf(buffer,"Fifo push %d count %d\n",x,f1.count());
    6198:	c8 01       	movw	r24, r16
    619a:	0e 94 ef 2f 	call	0x5fde	; 0x5fde <_ZN4Fifo5countEv>
    619e:	2d b7       	in	r18, 0x3d	; 61
    61a0:	3e b7       	in	r19, 0x3e	; 62
    61a2:	28 50       	subi	r18, 0x08	; 8
    61a4:	30 40       	sbci	r19, 0x00	; 0
    61a6:	2d bf       	out	0x3d, r18	; 61
    61a8:	3e bf       	out	0x3e, r19	; 62
    61aa:	ed b7       	in	r30, 0x3d	; 61
    61ac:	fe b7       	in	r31, 0x3e	; 62
    61ae:	31 96       	adiw	r30, 0x01	; 1
    61b0:	ad b7       	in	r26, 0x3d	; 61
    61b2:	be b7       	in	r27, 0x3e	; 62
    61b4:	11 96       	adiw	r26, 0x01	; 1
    61b6:	ed 92       	st	X+, r14
    61b8:	fc 92       	st	X, r15
    61ba:	12 97       	sbiw	r26, 0x02	; 2
    61bc:	c2 82       	std	Z+2, r12	; 0x02
    61be:	d3 82       	std	Z+3, r13	; 0x03
    61c0:	99 81       	ldd	r25, Y+1	; 0x01
    61c2:	94 83       	std	Z+4, r25	; 0x04
    61c4:	15 82       	std	Z+5, r1	; 0x05
    61c6:	86 83       	std	Z+6, r24	; 0x06
    61c8:	17 82       	std	Z+7, r1	; 0x07
    61ca:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
        ds.print(buffer);
    61ce:	2d b7       	in	r18, 0x3d	; 61
    61d0:	3e b7       	in	r19, 0x3e	; 62
    61d2:	28 5f       	subi	r18, 0xF8	; 248
    61d4:	3f 4f       	sbci	r19, 0xFF	; 255
    61d6:	2d bf       	out	0x3d, r18	; 61
    61d8:	3e bf       	out	0x3e, r19	; 62
    61da:	c5 01       	movw	r24, r10
    61dc:	b7 01       	movw	r22, r14
    61de:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
{
    Fifo f1(20);
    Fifo::FifoType x;
    char    buffer[128];
    
    for (x=1;x<25;x++) {
    61e2:	89 81       	ldd	r24, Y+1	; 0x01
    61e4:	8f 5f       	subi	r24, 0xFF	; 255
    61e6:	89 83       	std	Y+1, r24	; 0x01
    61e8:	89 81       	ldd	r24, Y+1	; 0x01
    61ea:	89 31       	cpi	r24, 0x19	; 25
    61ec:	88 f2       	brcs	.-94     	; 0x6190 <_Z8FifoTestR14HardwareSerial+0x58>
}

//! Clear the fifo by resetting the start and end pointer.
void Fifo::clear()
{
    _start = _end = _pdata;
    61ee:	8b 81       	ldd	r24, Y+3	; 0x03
    61f0:	9c 81       	ldd	r25, Y+4	; 0x04
    61f2:	8f 83       	std	Y+7, r24	; 0x07
    61f4:	98 87       	std	Y+8, r25	; 0x08
    61f6:	8d 83       	std	Y+5, r24	; 0x05
    61f8:	9e 83       	std	Y+6, r25	; 0x06
        f1.push(&x);
        sprintf(buffer,"Fifo push %d count %d\n",x,f1.count());
        ds.print(buffer);
    }
    f1.clear();
    sprintf(buffer,"Fifo count %d\n",f1.count());
    61fa:	c8 01       	movw	r24, r16
    61fc:	0e 94 ef 2f 	call	0x5fde	; 0x5fde <_ZN4Fifo5countEv>
    6200:	00 d0       	rcall	.+0      	; 0x6202 <_Z8FifoTestR14HardwareSerial+0xca>
    6202:	00 d0       	rcall	.+0      	; 0x6204 <_Z8FifoTestR14HardwareSerial+0xcc>
    6204:	ed b7       	in	r30, 0x3d	; 61
    6206:	fe b7       	in	r31, 0x3e	; 62
    6208:	31 96       	adiw	r30, 0x01	; 1
    620a:	ad b7       	in	r26, 0x3d	; 61
    620c:	be b7       	in	r27, 0x3e	; 62
    620e:	11 96       	adiw	r26, 0x01	; 1
    6210:	ed 92       	st	X+, r14
    6212:	fc 92       	st	X, r15
    6214:	12 97       	sbiw	r26, 0x02	; 2
    6216:	2a ec       	ldi	r18, 0xCA	; 202
    6218:	34 e2       	ldi	r19, 0x24	; 36
    621a:	22 83       	std	Z+2, r18	; 0x02
    621c:	33 83       	std	Z+3, r19	; 0x03
    621e:	84 83       	std	Z+4, r24	; 0x04
    6220:	15 82       	std	Z+5, r1	; 0x05
    6222:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    ds.print(buffer);
    6226:	2d b7       	in	r18, 0x3d	; 61
    6228:	3e b7       	in	r19, 0x3e	; 62
    622a:	2a 5f       	subi	r18, 0xFA	; 250
    622c:	3f 4f       	sbci	r19, 0xFF	; 255
    622e:	2d bf       	out	0x3d, r18	; 61
    6230:	3e bf       	out	0x3e, r19	; 62
    6232:	c5 01       	movw	r24, r10
    6234:	b7 01       	movw	r22, r14
    6236:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    
    for (x=0;x<10;x++) {
    623a:	19 82       	std	Y+1, r1	; 0x01
    623c:	8e 01       	movw	r16, r28
    623e:	0d 5f       	subi	r16, 0xFD	; 253
    6240:	1f 4f       	sbci	r17, 0xFF	; 255
        f1.push(&x);
    6242:	7e 01       	movw	r14, r28
    6244:	08 94       	sec
    6246:	e1 1c       	adc	r14, r1
    6248:	f1 1c       	adc	r15, r1
    624a:	07 c0       	rjmp	.+14     	; 0x625a <_Z8FifoTestR14HardwareSerial+0x122>
    624c:	c8 01       	movw	r24, r16
    624e:	b7 01       	movw	r22, r14
    6250:	0e 94 24 30 	call	0x6048	; 0x6048 <_ZN4Fifo4pushEPh>
    }
    f1.clear();
    sprintf(buffer,"Fifo count %d\n",f1.count());
    ds.print(buffer);
    
    for (x=0;x<10;x++) {
    6254:	89 81       	ldd	r24, Y+1	; 0x01
    6256:	8f 5f       	subi	r24, 0xFF	; 255
    6258:	89 83       	std	Y+1, r24	; 0x01
    625a:	89 81       	ldd	r24, Y+1	; 0x01
    625c:	8a 30       	cpi	r24, 0x0A	; 10
    625e:	b0 f3       	brcs	.-20     	; 0x624c <_Z8FifoTestR14HardwareSerial+0x114>
        f1.push(&x);
    }
    sprintf(buffer,"Fifo count %d. Expected 10\n",f1.count());
    6260:	c8 01       	movw	r24, r16
    6262:	0e 94 ef 2f 	call	0x5fde	; 0x5fde <_ZN4Fifo5countEv>
    6266:	00 d0       	rcall	.+0      	; 0x6268 <_Z8FifoTestR14HardwareSerial+0x130>
    6268:	00 d0       	rcall	.+0      	; 0x626a <_Z8FifoTestR14HardwareSerial+0x132>
    626a:	ed b7       	in	r30, 0x3d	; 61
    626c:	fe b7       	in	r31, 0x3e	; 62
    626e:	31 96       	adiw	r30, 0x01	; 1
    6270:	8e 01       	movw	r16, r28
    6272:	06 5f       	subi	r16, 0xF6	; 246
    6274:	1f 4f       	sbci	r17, 0xFF	; 255
    6276:	ad b7       	in	r26, 0x3d	; 61
    6278:	be b7       	in	r27, 0x3e	; 62
    627a:	11 96       	adiw	r26, 0x01	; 1
    627c:	0d 93       	st	X+, r16
    627e:	1c 93       	st	X, r17
    6280:	12 97       	sbiw	r26, 0x02	; 2
    6282:	29 ed       	ldi	r18, 0xD9	; 217
    6284:	34 e2       	ldi	r19, 0x24	; 36
    6286:	22 83       	std	Z+2, r18	; 0x02
    6288:	33 83       	std	Z+3, r19	; 0x03
    628a:	84 83       	std	Z+4, r24	; 0x04
    628c:	15 82       	std	Z+5, r1	; 0x05
    628e:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
    ds.print(buffer);
    6292:	2d b7       	in	r18, 0x3d	; 61
    6294:	3e b7       	in	r19, 0x3e	; 62
    6296:	2a 5f       	subi	r18, 0xFA	; 250
    6298:	3f 4f       	sbci	r19, 0xFF	; 255
    629a:	2d bf       	out	0x3d, r18	; 61
    629c:	3e bf       	out	0x3e, r19	; 62
    629e:	c5 01       	movw	r24, r10
    62a0:	b8 01       	movw	r22, r16
    62a2:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    
    Fifo::FifoType y;
    for (x=1;x<15;x++) {
    62a6:	81 e0       	ldi	r24, 0x01	; 1
    62a8:	89 83       	std	Y+1, r24	; 0x01
        f1.pop(&y);
    62aa:	23 e0       	ldi	r18, 0x03	; 3
    62ac:	c2 2e       	mov	r12, r18
    62ae:	d1 2c       	mov	r13, r1
    62b0:	cc 0e       	add	r12, r28
    62b2:	dd 1e       	adc	r13, r29
    62b4:	92 e0       	ldi	r25, 0x02	; 2
    62b6:	69 2e       	mov	r6, r25
    62b8:	71 2c       	mov	r7, r1
    62ba:	6c 0e       	add	r6, r28
    62bc:	7d 1e       	adc	r7, r29
        sprintf(buffer,"Fifo pop %d count %d\n",y,f1.count());
    62be:	f0 2e       	mov	r15, r16
    62c0:	01 2f       	mov	r16, r17
    62c2:	85 ef       	ldi	r24, 0xF5	; 245
    62c4:	88 2e       	mov	r8, r24
    62c6:	84 e2       	ldi	r24, 0x24	; 36
    62c8:	98 2e       	mov	r9, r24
    62ca:	2b c0       	rjmp	.+86     	; 0x6322 <_Z8FifoTestR14HardwareSerial+0x1ea>
    sprintf(buffer,"Fifo count %d. Expected 10\n",f1.count());
    ds.print(buffer);
    
    Fifo::FifoType y;
    for (x=1;x<15;x++) {
        f1.pop(&y);
    62cc:	c6 01       	movw	r24, r12
    62ce:	b3 01       	movw	r22, r6
    62d0:	0e 94 5e 30 	call	0x60bc	; 0x60bc <_ZN4Fifo3popEPh>
        sprintf(buffer,"Fifo pop %d count %d\n",y,f1.count());
    62d4:	c6 01       	movw	r24, r12
    62d6:	0e 94 ef 2f 	call	0x5fde	; 0x5fde <_ZN4Fifo5countEv>
    62da:	ad b7       	in	r26, 0x3d	; 61
    62dc:	be b7       	in	r27, 0x3e	; 62
    62de:	18 97       	sbiw	r26, 0x08	; 8
    62e0:	ad bf       	out	0x3d, r26	; 61
    62e2:	be bf       	out	0x3e, r27	; 62
    62e4:	ed b7       	in	r30, 0x3d	; 61
    62e6:	fe b7       	in	r31, 0x3e	; 62
    62e8:	31 96       	adiw	r30, 0x01	; 1
    62ea:	11 96       	adiw	r26, 0x01	; 1
    62ec:	fc 92       	st	X, r15
    62ee:	11 97       	sbiw	r26, 0x01	; 1
    62f0:	12 96       	adiw	r26, 0x02	; 2
    62f2:	0c 93       	st	X, r16
    62f4:	82 82       	std	Z+2, r8	; 0x02
    62f6:	93 82       	std	Z+3, r9	; 0x03
    62f8:	9a 81       	ldd	r25, Y+2	; 0x02
    62fa:	94 83       	std	Z+4, r25	; 0x04
    62fc:	15 82       	std	Z+5, r1	; 0x05
    62fe:	86 83       	std	Z+6, r24	; 0x06
    6300:	17 82       	std	Z+7, r1	; 0x07
    6302:	0e 94 c3 4b 	call	0x9786	; 0x9786 <sprintf>
        ds.print(buffer);
    6306:	2d b7       	in	r18, 0x3d	; 61
    6308:	3e b7       	in	r19, 0x3e	; 62
    630a:	28 5f       	subi	r18, 0xF8	; 248
    630c:	3f 4f       	sbci	r19, 0xFF	; 255
    630e:	2d bf       	out	0x3d, r18	; 61
    6310:	3e bf       	out	0x3e, r19	; 62
    6312:	c5 01       	movw	r24, r10
    6314:	6f 2d       	mov	r22, r15
    6316:	70 2f       	mov	r23, r16
    6318:	0e 94 58 29 	call	0x52b0	; 0x52b0 <_ZN5Print5printEPKc>
    }
    sprintf(buffer,"Fifo count %d. Expected 10\n",f1.count());
    ds.print(buffer);
    
    Fifo::FifoType y;
    for (x=1;x<15;x++) {
    631c:	89 81       	ldd	r24, Y+1	; 0x01
    631e:	8f 5f       	subi	r24, 0xFF	; 255
    6320:	89 83       	std	Y+1, r24	; 0x01
    6322:	89 81       	ldd	r24, Y+1	; 0x01
    6324:	8f 30       	cpi	r24, 0x0F	; 15
    6326:	90 f2       	brcs	.-92     	; 0x62cc <_Z8FifoTestR14HardwareSerial+0x194>
        f1.pop(&y);
        sprintf(buffer,"Fifo pop %d count %d\n",y,f1.count());
        ds.print(buffer);
    }
}
    6328:	c7 57       	subi	r28, 0x77	; 119
    632a:	df 4f       	sbci	r29, 0xFF	; 255
    632c:	cd bf       	out	0x3d, r28	; 61
    632e:	de bf       	out	0x3e, r29	; 62
    6330:	cf 91       	pop	r28
    6332:	df 91       	pop	r29
    6334:	1f 91       	pop	r17
    6336:	0f 91       	pop	r16
    6338:	ff 90       	pop	r15
    633a:	ef 90       	pop	r14
    633c:	df 90       	pop	r13
    633e:	cf 90       	pop	r12
    6340:	bf 90       	pop	r11
    6342:	af 90       	pop	r10
    6344:	9f 90       	pop	r9
    6346:	8f 90       	pop	r8
    6348:	7f 90       	pop	r7
    634a:	6f 90       	pop	r6
    634c:	08 95       	ret

0000634e <_ZN4FifoC2Eh>:
//! Allocate memory for the specified number of elements
//! and set the internal value to indicate the size of the fifo.
//! Reset the start and end data points to their clear state. The
//! clear function is called to maintain consitency and insure that
//! clear() always does the right thing.
Fifo::Fifo(uint8_t size)
    634e:	0f 93       	push	r16
    6350:	1f 93       	push	r17
    6352:	8c 01       	movw	r16, r24
    6354:	86 2f       	mov	r24, r22
{
    _size = size;
    6356:	f8 01       	movw	r30, r16
    6358:	66 83       	std	Z+6, r22	; 0x06
    _pdata = (FifoType*)malloc(_size * sizeof(FifoType));
    635a:	90 e0       	ldi	r25, 0x00	; 0
    635c:	0e 94 e8 49 	call	0x93d0	; 0x93d0 <malloc>
    6360:	f8 01       	movw	r30, r16
    6362:	80 83       	st	Z, r24
    6364:	91 83       	std	Z+1, r25	; 0x01
}

//! Clear the fifo by resetting the start and end pointer.
void Fifo::clear()
{
    _start = _end = _pdata;
    6366:	84 83       	std	Z+4, r24	; 0x04
    6368:	95 83       	std	Z+5, r25	; 0x05
    636a:	82 83       	std	Z+2, r24	; 0x02
    636c:	93 83       	std	Z+3, r25	; 0x03
Fifo::Fifo(uint8_t size)
{
    _size = size;
    _pdata = (FifoType*)malloc(_size * sizeof(FifoType));
    clear();
}
    636e:	1f 91       	pop	r17
    6370:	0f 91       	pop	r16
    6372:	08 95       	ret

00006374 <_ZN9TimerCntrC2EP10TC0_struct>:
#endif
#endif
    }
}

TimerCntr::TimerCntr(TC0_t*  pTC)
    6374:	fc 01       	movw	r30, r24
{
    _pTC = pTC;
    6376:	60 83       	st	Z, r22
    6378:	71 83       	std	Z+1, r23	; 0x01
    _bTC1 = false;
    637a:	12 82       	std	Z+2, r1	; 0x02
    _pNotifyClient = 0;
    637c:	13 82       	std	Z+3, r1	; 0x03
    637e:	14 82       	std	Z+4, r1	; 0x04
    _pNotifyClientID = 0;
    6380:	15 82       	std	Z+5, r1	; 0x05
static void SetPointer(TC0_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC0) {
    6382:	88 e0       	ldi	r24, 0x08	; 8
    6384:	60 30       	cpi	r22, 0x00	; 0
    6386:	78 07       	cpc	r23, r24
    6388:	29 f4       	brne	.+10     	; 0x6394 <_ZN9TimerCntrC2EP10TC0_struct+0x20>
        TCC0cp = pTC;
    638a:	e0 93 df 2b 	sts	0x2BDF, r30
    638e:	f0 93 e0 2b 	sts	0x2BE0, r31
    6392:	08 95       	ret
    } else if (tc == &TCD0) {
    6394:	89 e0       	ldi	r24, 0x09	; 9
    6396:	60 30       	cpi	r22, 0x00	; 0
    6398:	78 07       	cpc	r23, r24
    639a:	29 f4       	brne	.+10     	; 0x63a6 <_ZN9TimerCntrC2EP10TC0_struct+0x32>
        TCD0cp = pTC;
    639c:	e0 93 e1 2b 	sts	0x2BE1, r30
    63a0:	f0 93 e2 2b 	sts	0x2BE2, r31
    63a4:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE0)
    } else if (tc == &TCE0) {
    63a6:	60 50       	subi	r22, 0x00	; 0
    63a8:	7a 40       	sbci	r23, 0x0A	; 10
    63aa:	21 f4       	brne	.+8      	; 0x63b4 <_ZN9TimerCntrC2EP10TC0_struct+0x40>
        TCE0cp = pTC;
    63ac:	e0 93 e3 2b 	sts	0x2BE3, r30
    63b0:	f0 93 e4 2b 	sts	0x2BE4, r31
    63b4:	08 95       	ret

000063b6 <_ZN9TimerCntrC1EP10TC0_struct>:
#endif
#endif
    }
}

TimerCntr::TimerCntr(TC0_t*  pTC)
    63b6:	fc 01       	movw	r30, r24
{
    _pTC = pTC;
    63b8:	60 83       	st	Z, r22
    63ba:	71 83       	std	Z+1, r23	; 0x01
    _bTC1 = false;
    63bc:	12 82       	std	Z+2, r1	; 0x02
    _pNotifyClient = 0;
    63be:	13 82       	std	Z+3, r1	; 0x03
    63c0:	14 82       	std	Z+4, r1	; 0x04
    _pNotifyClientID = 0;
    63c2:	15 82       	std	Z+5, r1	; 0x05
static void SetPointer(TC0_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC0) {
    63c4:	88 e0       	ldi	r24, 0x08	; 8
    63c6:	60 30       	cpi	r22, 0x00	; 0
    63c8:	78 07       	cpc	r23, r24
    63ca:	29 f4       	brne	.+10     	; 0x63d6 <_ZN9TimerCntrC1EP10TC0_struct+0x20>
        TCC0cp = pTC;
    63cc:	e0 93 df 2b 	sts	0x2BDF, r30
    63d0:	f0 93 e0 2b 	sts	0x2BE0, r31
    63d4:	08 95       	ret
    } else if (tc == &TCD0) {
    63d6:	89 e0       	ldi	r24, 0x09	; 9
    63d8:	60 30       	cpi	r22, 0x00	; 0
    63da:	78 07       	cpc	r23, r24
    63dc:	29 f4       	brne	.+10     	; 0x63e8 <_ZN9TimerCntrC1EP10TC0_struct+0x32>
        TCD0cp = pTC;
    63de:	e0 93 e1 2b 	sts	0x2BE1, r30
    63e2:	f0 93 e2 2b 	sts	0x2BE2, r31
    63e6:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE0)
    } else if (tc == &TCE0) {
    63e8:	60 50       	subi	r22, 0x00	; 0
    63ea:	7a 40       	sbci	r23, 0x0A	; 10
    63ec:	21 f4       	brne	.+8      	; 0x63f6 <_ZN9TimerCntrC1EP10TC0_struct+0x40>
        TCE0cp = pTC;
    63ee:	e0 93 e3 2b 	sts	0x2BE3, r30
    63f2:	f0 93 e4 2b 	sts	0x2BE4, r31
    63f6:	08 95       	ret

000063f8 <_ZN9TimerCntrC2EP10TC1_struct>:
    _pNotifyClient = 0;
    _pNotifyClientID = 0;
    SetPointer(pTC,this);
}

TimerCntr::TimerCntr(TC1_t*  pTC)
    63f8:	fc 01       	movw	r30, r24
{
    _pTC = (TC0_t*)pTC;
    63fa:	60 83       	st	Z, r22
    63fc:	71 83       	std	Z+1, r23	; 0x01
    _bTC1 = true;
    63fe:	81 e0       	ldi	r24, 0x01	; 1
    6400:	82 83       	std	Z+2, r24	; 0x02
    _pNotifyClient = 0;
    6402:	13 82       	std	Z+3, r1	; 0x03
    6404:	14 82       	std	Z+4, r1	; 0x04
    _pNotifyClientID = 0;
    6406:	15 82       	std	Z+5, r1	; 0x05
static void SetPointer(TC1_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC1) {
    6408:	88 e0       	ldi	r24, 0x08	; 8
    640a:	60 34       	cpi	r22, 0x40	; 64
    640c:	78 07       	cpc	r23, r24
    640e:	29 f4       	brne	.+10     	; 0x641a <_ZN9TimerCntrC2EP10TC1_struct+0x22>
        TCC1cp = pTC;
    6410:	e0 93 d9 2b 	sts	0x2BD9, r30
    6414:	f0 93 da 2b 	sts	0x2BDA, r31
    6418:	08 95       	ret
    } else if (tc == &TCD1) {
    641a:	89 e0       	ldi	r24, 0x09	; 9
    641c:	60 34       	cpi	r22, 0x40	; 64
    641e:	78 07       	cpc	r23, r24
    6420:	29 f4       	brne	.+10     	; 0x642c <_ZN9TimerCntrC2EP10TC1_struct+0x34>
        TCD1cp = pTC;
    6422:	e0 93 db 2b 	sts	0x2BDB, r30
    6426:	f0 93 dc 2b 	sts	0x2BDC, r31
    642a:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE1)
    } else if (tc == &TCE1) {
    642c:	60 54       	subi	r22, 0x40	; 64
    642e:	7a 40       	sbci	r23, 0x0A	; 10
    6430:	21 f4       	brne	.+8      	; 0x643a <_ZN9TimerCntrC2EP10TC1_struct+0x42>
        TCE1cp = pTC;
    6432:	e0 93 dd 2b 	sts	0x2BDD, r30
    6436:	f0 93 de 2b 	sts	0x2BDE, r31
    643a:	08 95       	ret

0000643c <_ZN9TimerCntrC1EP10TC1_struct>:
    _pNotifyClient = 0;
    _pNotifyClientID = 0;
    SetPointer(pTC,this);
}

TimerCntr::TimerCntr(TC1_t*  pTC)
    643c:	fc 01       	movw	r30, r24
{
    _pTC = (TC0_t*)pTC;
    643e:	60 83       	st	Z, r22
    6440:	71 83       	std	Z+1, r23	; 0x01
    _bTC1 = true;
    6442:	81 e0       	ldi	r24, 0x01	; 1
    6444:	82 83       	std	Z+2, r24	; 0x02
    _pNotifyClient = 0;
    6446:	13 82       	std	Z+3, r1	; 0x03
    6448:	14 82       	std	Z+4, r1	; 0x04
    _pNotifyClientID = 0;
    644a:	15 82       	std	Z+5, r1	; 0x05
static void SetPointer(TC1_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC1) {
    644c:	88 e0       	ldi	r24, 0x08	; 8
    644e:	60 34       	cpi	r22, 0x40	; 64
    6450:	78 07       	cpc	r23, r24
    6452:	29 f4       	brne	.+10     	; 0x645e <_ZN9TimerCntrC1EP10TC1_struct+0x22>
        TCC1cp = pTC;
    6454:	e0 93 d9 2b 	sts	0x2BD9, r30
    6458:	f0 93 da 2b 	sts	0x2BDA, r31
    645c:	08 95       	ret
    } else if (tc == &TCD1) {
    645e:	89 e0       	ldi	r24, 0x09	; 9
    6460:	60 34       	cpi	r22, 0x40	; 64
    6462:	78 07       	cpc	r23, r24
    6464:	29 f4       	brne	.+10     	; 0x6470 <_ZN9TimerCntrC1EP10TC1_struct+0x34>
        TCD1cp = pTC;
    6466:	e0 93 db 2b 	sts	0x2BDB, r30
    646a:	f0 93 dc 2b 	sts	0x2BDC, r31
    646e:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE1)
    } else if (tc == &TCE1) {
    6470:	60 54       	subi	r22, 0x40	; 64
    6472:	7a 40       	sbci	r23, 0x0A	; 10
    6474:	21 f4       	brne	.+8      	; 0x647e <_ZN9TimerCntrC1EP10TC1_struct+0x42>
        TCE1cp = pTC;
    6476:	e0 93 dd 2b 	sts	0x2BDD, r30
    647a:	f0 93 de 2b 	sts	0x2BDE, r31
    647e:	08 95       	ret

00006480 <_ZN9TimerCntrD2Ev>:
    _pNotifyClient = 0;
    _pNotifyClientID = 0;
    SetPointer(pTC,this);
}

TimerCntr::~TimerCntr()
    6480:	fc 01       	movw	r30, r24
{
    if (_bTC1) {
    6482:	82 81       	ldd	r24, Z+2	; 0x02
    6484:	01 90       	ld	r0, Z+
    6486:	f0 81       	ld	r31, Z
    6488:	e0 2d       	mov	r30, r0
    648a:	88 23       	and	r24, r24
    648c:	d1 f0       	breq	.+52     	; 0x64c2 <_ZN9TimerCntrD2Ev+0x42>
static void SetPointer(TC1_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC1) {
    648e:	88 e0       	ldi	r24, 0x08	; 8
    6490:	e0 34       	cpi	r30, 0x40	; 64
    6492:	f8 07       	cpc	r31, r24
    6494:	29 f4       	brne	.+10     	; 0x64a0 <_ZN9TimerCntrD2Ev+0x20>
        TCC1cp = pTC;
    6496:	10 92 d9 2b 	sts	0x2BD9, r1
    649a:	10 92 da 2b 	sts	0x2BDA, r1
    649e:	08 95       	ret
    } else if (tc == &TCD1) {
    64a0:	89 e0       	ldi	r24, 0x09	; 9
    64a2:	e0 34       	cpi	r30, 0x40	; 64
    64a4:	f8 07       	cpc	r31, r24
    64a6:	29 f4       	brne	.+10     	; 0x64b2 <_ZN9TimerCntrD2Ev+0x32>
        TCD1cp = pTC;
    64a8:	10 92 db 2b 	sts	0x2BDB, r1
    64ac:	10 92 dc 2b 	sts	0x2BDC, r1
    64b0:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE1)
    } else if (tc == &TCE1) {
    64b2:	e0 54       	subi	r30, 0x40	; 64
    64b4:	fa 40       	sbci	r31, 0x0A	; 10
    64b6:	f1 f4       	brne	.+60     	; 0x64f4 <_ZN9TimerCntrD2Ev+0x74>
        TCE1cp = pTC;
    64b8:	10 92 dd 2b 	sts	0x2BDD, r1
    64bc:	10 92 de 2b 	sts	0x2BDE, r1
    64c0:	08 95       	ret
static void SetPointer(TC0_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC0) {
    64c2:	88 e0       	ldi	r24, 0x08	; 8
    64c4:	e0 30       	cpi	r30, 0x00	; 0
    64c6:	f8 07       	cpc	r31, r24
    64c8:	29 f4       	brne	.+10     	; 0x64d4 <_ZN9TimerCntrD2Ev+0x54>
        TCC0cp = pTC;
    64ca:	10 92 df 2b 	sts	0x2BDF, r1
    64ce:	10 92 e0 2b 	sts	0x2BE0, r1
    64d2:	08 95       	ret
    } else if (tc == &TCD0) {
    64d4:	89 e0       	ldi	r24, 0x09	; 9
    64d6:	e0 30       	cpi	r30, 0x00	; 0
    64d8:	f8 07       	cpc	r31, r24
    64da:	29 f4       	brne	.+10     	; 0x64e6 <_ZN9TimerCntrD2Ev+0x66>
        TCD0cp = pTC;
    64dc:	10 92 e1 2b 	sts	0x2BE1, r1
    64e0:	10 92 e2 2b 	sts	0x2BE2, r1
    64e4:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE0)
    } else if (tc == &TCE0) {
    64e6:	e0 50       	subi	r30, 0x00	; 0
    64e8:	fa 40       	sbci	r31, 0x0A	; 10
    64ea:	21 f4       	brne	.+8      	; 0x64f4 <_ZN9TimerCntrD2Ev+0x74>
        TCE0cp = pTC;
    64ec:	10 92 e3 2b 	sts	0x2BE3, r1
    64f0:	10 92 e4 2b 	sts	0x2BE4, r1
    64f4:	08 95       	ret

000064f6 <_ZN9TimerCntrD1Ev>:
    _pNotifyClient = 0;
    _pNotifyClientID = 0;
    SetPointer(pTC,this);
}

TimerCntr::~TimerCntr()
    64f6:	fc 01       	movw	r30, r24
{
    if (_bTC1) {
    64f8:	82 81       	ldd	r24, Z+2	; 0x02
    64fa:	01 90       	ld	r0, Z+
    64fc:	f0 81       	ld	r31, Z
    64fe:	e0 2d       	mov	r30, r0
    6500:	88 23       	and	r24, r24
    6502:	d1 f0       	breq	.+52     	; 0x6538 <_ZN9TimerCntrD1Ev+0x42>
static void SetPointer(TC1_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC1) {
    6504:	88 e0       	ldi	r24, 0x08	; 8
    6506:	e0 34       	cpi	r30, 0x40	; 64
    6508:	f8 07       	cpc	r31, r24
    650a:	29 f4       	brne	.+10     	; 0x6516 <_ZN9TimerCntrD1Ev+0x20>
        TCC1cp = pTC;
    650c:	10 92 d9 2b 	sts	0x2BD9, r1
    6510:	10 92 da 2b 	sts	0x2BDA, r1
    6514:	08 95       	ret
    } else if (tc == &TCD1) {
    6516:	89 e0       	ldi	r24, 0x09	; 9
    6518:	e0 34       	cpi	r30, 0x40	; 64
    651a:	f8 07       	cpc	r31, r24
    651c:	29 f4       	brne	.+10     	; 0x6528 <_ZN9TimerCntrD1Ev+0x32>
        TCD1cp = pTC;
    651e:	10 92 db 2b 	sts	0x2BDB, r1
    6522:	10 92 dc 2b 	sts	0x2BDC, r1
    6526:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE1)
    } else if (tc == &TCE1) {
    6528:	e0 54       	subi	r30, 0x40	; 64
    652a:	fa 40       	sbci	r31, 0x0A	; 10
    652c:	f1 f4       	brne	.+60     	; 0x656a <_ZN9TimerCntrD1Ev+0x74>
        TCE1cp = pTC;
    652e:	10 92 dd 2b 	sts	0x2BDD, r1
    6532:	10 92 de 2b 	sts	0x2BDE, r1
    6536:	08 95       	ret
static void SetPointer(TC0_t* tc,TimerCntr* pTC)
{
    // Register this object with the appropriate
    // pointer so that the ISR routines can call p
    // class.
    if (tc == &TCC0) {
    6538:	88 e0       	ldi	r24, 0x08	; 8
    653a:	e0 30       	cpi	r30, 0x00	; 0
    653c:	f8 07       	cpc	r31, r24
    653e:	29 f4       	brne	.+10     	; 0x654a <_ZN9TimerCntrD1Ev+0x54>
        TCC0cp = pTC;
    6540:	10 92 df 2b 	sts	0x2BDF, r1
    6544:	10 92 e0 2b 	sts	0x2BE0, r1
    6548:	08 95       	ret
    } else if (tc == &TCD0) {
    654a:	89 e0       	ldi	r24, 0x09	; 9
    654c:	e0 30       	cpi	r30, 0x00	; 0
    654e:	f8 07       	cpc	r31, r24
    6550:	29 f4       	brne	.+10     	; 0x655c <_ZN9TimerCntrD1Ev+0x66>
        TCD0cp = pTC;
    6552:	10 92 e1 2b 	sts	0x2BE1, r1
    6556:	10 92 e2 2b 	sts	0x2BE2, r1
    655a:	08 95       	ret
#if not defined(TIMERCORE_USE_TCE0)
    } else if (tc == &TCE0) {
    655c:	e0 50       	subi	r30, 0x00	; 0
    655e:	fa 40       	sbci	r31, 0x0A	; 10
    6560:	21 f4       	brne	.+8      	; 0x656a <_ZN9TimerCntrD1Ev+0x74>
        TCE0cp = pTC;
    6562:	10 92 e3 2b 	sts	0x2BE3, r1
    6566:	10 92 e4 2b 	sts	0x2BE4, r1
    656a:	08 95       	ret

0000656c <_ZN9TimerCntr6ClkSelE14TC_CLKSEL_enum>:
        SetPointer(_pTC,0);
    }
}


void TimerCntr::ClkSel(TC_CLKSEL_t clksel)
    656c:	fc 01       	movw	r30, r24
{
    _pTC->CTRLA = clksel; 
    656e:	01 90       	ld	r0, Z+
    6570:	f0 81       	ld	r31, Z
    6572:	e0 2d       	mov	r30, r0
    6574:	60 83       	st	Z, r22
}
    6576:	08 95       	ret

00006578 <_ZN9TimerCntr8CCEnableEh>:


void TimerCntr::CCEnable(uint8_t mask)
    6578:	fc 01       	movw	r30, r24
{
    _pTC->CTRLB = ((_pTC->CTRLB & 0x0F) | (mask << 4));
    657a:	01 90       	ld	r0, Z+
    657c:	f0 81       	ld	r31, Z
    657e:	e0 2d       	mov	r30, r0
    6580:	81 81       	ldd	r24, Z+1	; 0x01
    6582:	62 95       	swap	r22
    6584:	60 7f       	andi	r22, 0xF0	; 240
    6586:	8f 70       	andi	r24, 0x0F	; 15
    6588:	86 2b       	or	r24, r22
    658a:	81 83       	std	Z+1, r24	; 0x01
}
    658c:	08 95       	ret

0000658e <_ZN9TimerCntr15WaveformGenModeE14TC_WGMODE_enum>:


void TimerCntr::WaveformGenMode(TC_WGMODE_t wgmode)
    658e:	fc 01       	movw	r30, r24
{
    _pTC->CTRLB = ((_pTC->CTRLB & 0xF0) | wgmode);
    6590:	01 90       	ld	r0, Z+
    6592:	f0 81       	ld	r31, Z
    6594:	e0 2d       	mov	r30, r0
    6596:	81 81       	ldd	r24, Z+1	; 0x01
    6598:	80 7f       	andi	r24, 0xF0	; 240
    659a:	86 2b       	or	r24, r22
    659c:	81 83       	std	Z+1, r24	; 0x01
}
    659e:	08 95       	ret

000065a0 <_ZN9TimerCntr10EventSetupE13TC_EVACT_enum13TC_EVSEL_enum>:


void TimerCntr::EventSetup(TC_EVACT_t act, TC_EVSEL_t src)
    65a0:	fc 01       	movw	r30, r24
{
    _pTC->CTRLD = act | src;
    65a2:	01 90       	ld	r0, Z+
    65a4:	f0 81       	ld	r31, Z
    65a6:	e0 2d       	mov	r30, r0
    65a8:	46 2b       	or	r20, r22
    65aa:	43 83       	std	Z+3, r20	; 0x03
}
    65ac:	08 95       	ret

000065ae <_ZN9TimerCntr7IntLvlAEhh>:


void TimerCntr::IntLvlA(uint8_t errlvl, uint8_t ovflvl)
    65ae:	fc 01       	movw	r30, r24
{
    _pTC->INTCTRLA = (errlvl & 0x3) << 2 | (ovflvl & 0x3);
    65b0:	01 90       	ld	r0, Z+
    65b2:	f0 81       	ld	r31, Z
    65b4:	e0 2d       	mov	r30, r0
    65b6:	70 e0       	ldi	r23, 0x00	; 0
    65b8:	63 70       	andi	r22, 0x03	; 3
    65ba:	70 70       	andi	r23, 0x00	; 0
    65bc:	66 0f       	add	r22, r22
    65be:	77 1f       	adc	r23, r23
    65c0:	66 0f       	add	r22, r22
    65c2:	77 1f       	adc	r23, r23
    65c4:	43 70       	andi	r20, 0x03	; 3
    65c6:	46 2b       	or	r20, r22
    65c8:	46 83       	std	Z+6, r20	; 0x06
}
    65ca:	08 95       	ret

000065cc <_ZN9TimerCntr7IntLvlBEh>:

void TimerCntr::IntLvlB(uint8_t val)
    65cc:	fc 01       	movw	r30, r24
{
    _pTC->INTCTRLB = val;
    65ce:	01 90       	ld	r0, Z+
    65d0:	f0 81       	ld	r31, Z
    65d2:	e0 2d       	mov	r30, r0
    65d4:	67 83       	std	Z+7, r22	; 0x07
}
    65d6:	08 95       	ret

000065d8 <_ZN9TimerCntr7CounterEj>:

void TimerCntr::Counter(uint16_t newVal)
    65d8:	fc 01       	movw	r30, r24
{
    _pTC->CNT = newVal;
    65da:	01 90       	ld	r0, Z+
    65dc:	f0 81       	ld	r31, Z
    65de:	e0 2d       	mov	r30, r0
    65e0:	60 a3       	std	Z+32, r22	; 0x20
    65e2:	71 a3       	std	Z+33, r23	; 0x21
}
    65e4:	08 95       	ret

000065e6 <_ZN9TimerCntr7CounterEv>:

uint16_t TimerCntr::Counter()
    65e6:	fc 01       	movw	r30, r24
{
    return _pTC->CNT;
    65e8:	01 90       	ld	r0, Z+
    65ea:	f0 81       	ld	r31, Z
    65ec:	e0 2d       	mov	r30, r0
    65ee:	20 a1       	ldd	r18, Z+32	; 0x20
    65f0:	31 a1       	ldd	r19, Z+33	; 0x21
}
    65f2:	c9 01       	movw	r24, r18
    65f4:	08 95       	ret

000065f6 <_ZN9TimerCntr6PeriodEj>:


void TimerCntr::Period(uint16_t newVal)
    65f6:	fc 01       	movw	r30, r24
{
    _pTC->PER = newVal;
    65f8:	01 90       	ld	r0, Z+
    65fa:	f0 81       	ld	r31, Z
    65fc:	e0 2d       	mov	r30, r0
    65fe:	66 a3       	std	Z+38, r22	; 0x26
    6600:	77 a3       	std	Z+39, r23	; 0x27
}
    6602:	08 95       	ret

00006604 <_ZN9TimerCntr6PeriodEv>:

uint16_t TimerCntr::Period()
    6604:	fc 01       	movw	r30, r24
{
    return _pTC->PER;
    6606:	01 90       	ld	r0, Z+
    6608:	f0 81       	ld	r31, Z
    660a:	e0 2d       	mov	r30, r0
    660c:	26 a1       	ldd	r18, Z+38	; 0x26
    660e:	37 a1       	ldd	r19, Z+39	; 0x27
}
    6610:	c9 01       	movw	r24, r18
    6612:	08 95       	ret

00006614 <_ZN9TimerCntr5CCRegEhj>:


void TimerCntr::CCReg(uint8_t idx, uint16_t newVal)
    6614:	fc 01       	movw	r30, r24
{
    if (idx == 0) {
    6616:	66 23       	and	r22, r22
    6618:	31 f4       	brne	.+12     	; 0x6626 <_ZN9TimerCntr5CCRegEhj+0x12>
        _pTC->CCA = newVal;
    661a:	01 90       	ld	r0, Z+
    661c:	f0 81       	ld	r31, Z
    661e:	e0 2d       	mov	r30, r0
    6620:	40 a7       	std	Z+40, r20	; 0x28
    6622:	51 a7       	std	Z+41, r21	; 0x29
    6624:	08 95       	ret
    } else if (idx == 1) {
    6626:	61 30       	cpi	r22, 0x01	; 1
    6628:	31 f4       	brne	.+12     	; 0x6636 <_ZN9TimerCntr5CCRegEhj+0x22>
        _pTC->CCB = newVal;
    662a:	01 90       	ld	r0, Z+
    662c:	f0 81       	ld	r31, Z
    662e:	e0 2d       	mov	r30, r0
    6630:	42 a7       	std	Z+42, r20	; 0x2a
    6632:	53 a7       	std	Z+43, r21	; 0x2b
    6634:	08 95       	ret
    } else if (!_bTC1 && idx == 2) {
    6636:	82 81       	ldd	r24, Z+2	; 0x02
    6638:	88 23       	and	r24, r24
    663a:	79 f4       	brne	.+30     	; 0x665a <_ZN9TimerCntr5CCRegEhj+0x46>
    663c:	62 30       	cpi	r22, 0x02	; 2
    663e:	31 f4       	brne	.+12     	; 0x664c <_ZN9TimerCntr5CCRegEhj+0x38>
        _pTC->CCC = newVal;
    6640:	01 90       	ld	r0, Z+
    6642:	f0 81       	ld	r31, Z
    6644:	e0 2d       	mov	r30, r0
    6646:	44 a7       	std	Z+44, r20	; 0x2c
    6648:	55 a7       	std	Z+45, r21	; 0x2d
    664a:	08 95       	ret
    } else if (!_bTC1 && idx == 3) {
    664c:	63 30       	cpi	r22, 0x03	; 3
    664e:	29 f4       	brne	.+10     	; 0x665a <_ZN9TimerCntr5CCRegEhj+0x46>
        _pTC->CCD = newVal;
    6650:	01 90       	ld	r0, Z+
    6652:	f0 81       	ld	r31, Z
    6654:	e0 2d       	mov	r30, r0
    6656:	46 a7       	std	Z+46, r20	; 0x2e
    6658:	57 a7       	std	Z+47, r21	; 0x2f
    665a:	08 95       	ret

0000665c <_ZN9TimerCntr5CCRegEh>:
    }
}

uint16_t TimerCntr::CCReg(uint8_t idx)
    665c:	fc 01       	movw	r30, r24
{
    if (idx == 0) {
    665e:	66 23       	and	r22, r22
    6660:	39 f4       	brne	.+14     	; 0x6670 <_ZN9TimerCntr5CCRegEh+0x14>
        return _pTC->CCA;
    6662:	01 90       	ld	r0, Z+
    6664:	f0 81       	ld	r31, Z
    6666:	e0 2d       	mov	r30, r0
    6668:	00 a4       	ldd	r0, Z+40	; 0x28
    666a:	f1 a5       	ldd	r31, Z+41	; 0x29
    666c:	e0 2d       	mov	r30, r0
    666e:	20 c0       	rjmp	.+64     	; 0x66b0 <_ZN9TimerCntr5CCRegEh+0x54>
    } else if (idx == 1) {
    6670:	61 30       	cpi	r22, 0x01	; 1
    6672:	39 f4       	brne	.+14     	; 0x6682 <_ZN9TimerCntr5CCRegEh+0x26>
        return _pTC->CCB;
    6674:	01 90       	ld	r0, Z+
    6676:	f0 81       	ld	r31, Z
    6678:	e0 2d       	mov	r30, r0
    667a:	02 a4       	ldd	r0, Z+42	; 0x2a
    667c:	f3 a5       	ldd	r31, Z+43	; 0x2b
    667e:	e0 2d       	mov	r30, r0
    6680:	17 c0       	rjmp	.+46     	; 0x66b0 <_ZN9TimerCntr5CCRegEh+0x54>
    } else if (!_bTC1 && idx == 2) {
    6682:	82 81       	ldd	r24, Z+2	; 0x02
    6684:	88 23       	and	r24, r24
    6686:	91 f4       	brne	.+36     	; 0x66ac <_ZN9TimerCntr5CCRegEh+0x50>
    6688:	62 30       	cpi	r22, 0x02	; 2
    668a:	39 f4       	brne	.+14     	; 0x669a <_ZN9TimerCntr5CCRegEh+0x3e>
        return _pTC->CCC;
    668c:	01 90       	ld	r0, Z+
    668e:	f0 81       	ld	r31, Z
    6690:	e0 2d       	mov	r30, r0
    6692:	04 a4       	ldd	r0, Z+44	; 0x2c
    6694:	f5 a5       	ldd	r31, Z+45	; 0x2d
    6696:	e0 2d       	mov	r30, r0
    6698:	0b c0       	rjmp	.+22     	; 0x66b0 <_ZN9TimerCntr5CCRegEh+0x54>
    } else if (!_bTC1 && idx == 3) {
    669a:	63 30       	cpi	r22, 0x03	; 3
    669c:	39 f4       	brne	.+14     	; 0x66ac <_ZN9TimerCntr5CCRegEh+0x50>
        return _pTC->CCD;
    669e:	01 90       	ld	r0, Z+
    66a0:	f0 81       	ld	r31, Z
    66a2:	e0 2d       	mov	r30, r0
    66a4:	06 a4       	ldd	r0, Z+46	; 0x2e
    66a6:	f7 a5       	ldd	r31, Z+47	; 0x2f
    66a8:	e0 2d       	mov	r30, r0
    66aa:	02 c0       	rjmp	.+4      	; 0x66b0 <_ZN9TimerCntr5CCRegEh+0x54>
    66ac:	e0 e0       	ldi	r30, 0x00	; 0
    66ae:	f0 e0       	ldi	r31, 0x00	; 0
    }
    return 0;
}
    66b0:	cf 01       	movw	r24, r30
    66b2:	08 95       	ret

000066b4 <_ZN9TimerCntr6NotifyEP11TimerNotifyh>:

void TimerCntr::Notify(TimerNotify* pClient,uint8_t id)
    66b4:	fc 01       	movw	r30, r24
{
    _pNotifyClient = pClient;
    66b6:	63 83       	std	Z+3, r22	; 0x03
    66b8:	74 83       	std	Z+4, r23	; 0x04
    _pNotifyClientID = id;
    66ba:	45 83       	std	Z+5, r20	; 0x05
}
    66bc:	08 95       	ret

000066be <_ZN9TimerCntr3errEv>:

void TimerCntr::err()
    66be:	cf 93       	push	r28
    66c0:	df 93       	push	r29
    66c2:	ec 01       	movw	r28, r24
{
    if (_pNotifyClient)  
    66c4:	ab 81       	ldd	r26, Y+3	; 0x03
    66c6:	bc 81       	ldd	r27, Y+4	; 0x04
    66c8:	10 97       	sbiw	r26, 0x00	; 0
    66ca:	49 f0       	breq	.+18     	; 0x66de <_ZN9TimerCntr3errEv+0x20>
        _pNotifyClient->err(_pNotifyClientID);
    66cc:	ed 91       	ld	r30, X+
    66ce:	fc 91       	ld	r31, X
    66d0:	11 97       	sbiw	r26, 0x01	; 1
    66d2:	01 90       	ld	r0, Z+
    66d4:	f0 81       	ld	r31, Z
    66d6:	e0 2d       	mov	r30, r0
    66d8:	cd 01       	movw	r24, r26
    66da:	6d 81       	ldd	r22, Y+5	; 0x05
    66dc:	19 95       	eicall
}
    66de:	df 91       	pop	r29
    66e0:	cf 91       	pop	r28
    66e2:	08 95       	ret

000066e4 <__vector_54>:
}

TC1_ISR_DEF(TCC1);
TC1_ISR_DEF(TCD1);
#if not defined(TIMERCORE_USE_TCE1)
TC1_ISR_DEF(TCE1);
    66e4:	1f 92       	push	r1
    66e6:	0f 92       	push	r0
    66e8:	0f b6       	in	r0, 0x3f	; 63
    66ea:	0f 92       	push	r0
    66ec:	08 b6       	in	r0, 0x38	; 56
    66ee:	0f 92       	push	r0
    66f0:	09 b6       	in	r0, 0x39	; 57
    66f2:	0f 92       	push	r0
    66f4:	0b b6       	in	r0, 0x3b	; 59
    66f6:	0f 92       	push	r0
    66f8:	11 24       	eor	r1, r1
    66fa:	18 be       	out	0x38, r1	; 56
    66fc:	19 be       	out	0x39, r1	; 57
    66fe:	1b be       	out	0x3b, r1	; 59
    6700:	2f 93       	push	r18
    6702:	3f 93       	push	r19
    6704:	4f 93       	push	r20
    6706:	5f 93       	push	r21
    6708:	6f 93       	push	r22
    670a:	7f 93       	push	r23
    670c:	8f 93       	push	r24
    670e:	9f 93       	push	r25
    6710:	af 93       	push	r26
    6712:	bf 93       	push	r27
    6714:	ef 93       	push	r30
    6716:	ff 93       	push	r31
    6718:	80 91 dd 2b 	lds	r24, 0x2BDD
    671c:	90 91 de 2b 	lds	r25, 0x2BDE
    6720:	00 97       	sbiw	r24, 0x00	; 0
    6722:	11 f0       	breq	.+4      	; 0x6728 <__vector_54+0x44>
    6724:	0e 94 5f 33 	call	0x66be	; 0x66be <_ZN9TimerCntr3errEv>
    6728:	ff 91       	pop	r31
    672a:	ef 91       	pop	r30
    672c:	bf 91       	pop	r27
    672e:	af 91       	pop	r26
    6730:	9f 91       	pop	r25
    6732:	8f 91       	pop	r24
    6734:	7f 91       	pop	r23
    6736:	6f 91       	pop	r22
    6738:	5f 91       	pop	r21
    673a:	4f 91       	pop	r20
    673c:	3f 91       	pop	r19
    673e:	2f 91       	pop	r18
    6740:	0f 90       	pop	r0
    6742:	0b be       	out	0x3b, r0	; 59
    6744:	0f 90       	pop	r0
    6746:	09 be       	out	0x39, r0	; 57
    6748:	0f 90       	pop	r0
    674a:	08 be       	out	0x38, r0	; 56
    674c:	0f 90       	pop	r0
    674e:	0f be       	out	0x3f, r0	; 63
    6750:	0f 90       	pop	r0
    6752:	1f 90       	pop	r1
    6754:	18 95       	reti

00006756 <__vector_84>:
ISR(tc##_CCB_vect) {\
    if (tc##cp) tc##cp->ccx(1);\
}

TC1_ISR_DEF(TCC1);
TC1_ISR_DEF(TCD1);
    6756:	1f 92       	push	r1
    6758:	0f 92       	push	r0
    675a:	0f b6       	in	r0, 0x3f	; 63
    675c:	0f 92       	push	r0
    675e:	08 b6       	in	r0, 0x38	; 56
    6760:	0f 92       	push	r0
    6762:	09 b6       	in	r0, 0x39	; 57
    6764:	0f 92       	push	r0
    6766:	0b b6       	in	r0, 0x3b	; 59
    6768:	0f 92       	push	r0
    676a:	11 24       	eor	r1, r1
    676c:	18 be       	out	0x38, r1	; 56
    676e:	19 be       	out	0x39, r1	; 57
    6770:	1b be       	out	0x3b, r1	; 59
    6772:	2f 93       	push	r18
    6774:	3f 93       	push	r19
    6776:	4f 93       	push	r20
    6778:	5f 93       	push	r21
    677a:	6f 93       	push	r22
    677c:	7f 93       	push	r23
    677e:	8f 93       	push	r24
    6780:	9f 93       	push	r25
    6782:	af 93       	push	r26
    6784:	bf 93       	push	r27
    6786:	ef 93       	push	r30
    6788:	ff 93       	push	r31
    678a:	80 91 db 2b 	lds	r24, 0x2BDB
    678e:	90 91 dc 2b 	lds	r25, 0x2BDC
    6792:	00 97       	sbiw	r24, 0x00	; 0
    6794:	11 f0       	breq	.+4      	; 0x679a <__vector_84+0x44>
    6796:	0e 94 5f 33 	call	0x66be	; 0x66be <_ZN9TimerCntr3errEv>
    679a:	ff 91       	pop	r31
    679c:	ef 91       	pop	r30
    679e:	bf 91       	pop	r27
    67a0:	af 91       	pop	r26
    67a2:	9f 91       	pop	r25
    67a4:	8f 91       	pop	r24
    67a6:	7f 91       	pop	r23
    67a8:	6f 91       	pop	r22
    67aa:	5f 91       	pop	r21
    67ac:	4f 91       	pop	r20
    67ae:	3f 91       	pop	r19
    67b0:	2f 91       	pop	r18
    67b2:	0f 90       	pop	r0
    67b4:	0b be       	out	0x3b, r0	; 59
    67b6:	0f 90       	pop	r0
    67b8:	09 be       	out	0x39, r0	; 57
    67ba:	0f 90       	pop	r0
    67bc:	08 be       	out	0x38, r0	; 56
    67be:	0f 90       	pop	r0
    67c0:	0f be       	out	0x3f, r0	; 63
    67c2:	0f 90       	pop	r0
    67c4:	1f 90       	pop	r1
    67c6:	18 95       	reti

000067c8 <__vector_21>:
}\
ISR(tc##_CCB_vect) {\
    if (tc##cp) tc##cp->ccx(1);\
}

TC1_ISR_DEF(TCC1);
    67c8:	1f 92       	push	r1
    67ca:	0f 92       	push	r0
    67cc:	0f b6       	in	r0, 0x3f	; 63
    67ce:	0f 92       	push	r0
    67d0:	08 b6       	in	r0, 0x38	; 56
    67d2:	0f 92       	push	r0
    67d4:	09 b6       	in	r0, 0x39	; 57
    67d6:	0f 92       	push	r0
    67d8:	0b b6       	in	r0, 0x3b	; 59
    67da:	0f 92       	push	r0
    67dc:	11 24       	eor	r1, r1
    67de:	18 be       	out	0x38, r1	; 56
    67e0:	19 be       	out	0x39, r1	; 57
    67e2:	1b be       	out	0x3b, r1	; 59
    67e4:	2f 93       	push	r18
    67e6:	3f 93       	push	r19
    67e8:	4f 93       	push	r20
    67ea:	5f 93       	push	r21
    67ec:	6f 93       	push	r22
    67ee:	7f 93       	push	r23
    67f0:	8f 93       	push	r24
    67f2:	9f 93       	push	r25
    67f4:	af 93       	push	r26
    67f6:	bf 93       	push	r27
    67f8:	ef 93       	push	r30
    67fa:	ff 93       	push	r31
    67fc:	80 91 d9 2b 	lds	r24, 0x2BD9
    6800:	90 91 da 2b 	lds	r25, 0x2BDA
    6804:	00 97       	sbiw	r24, 0x00	; 0
    6806:	11 f0       	breq	.+4      	; 0x680c <__vector_21+0x44>
    6808:	0e 94 5f 33 	call	0x66be	; 0x66be <_ZN9TimerCntr3errEv>
    680c:	ff 91       	pop	r31
    680e:	ef 91       	pop	r30
    6810:	bf 91       	pop	r27
    6812:	af 91       	pop	r26
    6814:	9f 91       	pop	r25
    6816:	8f 91       	pop	r24
    6818:	7f 91       	pop	r23
    681a:	6f 91       	pop	r22
    681c:	5f 91       	pop	r21
    681e:	4f 91       	pop	r20
    6820:	3f 91       	pop	r19
    6822:	2f 91       	pop	r18
    6824:	0f 90       	pop	r0
    6826:	0b be       	out	0x3b, r0	; 59
    6828:	0f 90       	pop	r0
    682a:	09 be       	out	0x39, r0	; 57
    682c:	0f 90       	pop	r0
    682e:	08 be       	out	0x38, r0	; 56
    6830:	0f 90       	pop	r0
    6832:	0f be       	out	0x3f, r0	; 63
    6834:	0f 90       	pop	r0
    6836:	1f 90       	pop	r1
    6838:	18 95       	reti

0000683a <__vector_48>:

// The TimerCore.cpp will use TCE0 and TCE1 if
// TCF1 is not defined.. Hence, I need to NOT define
// It here. 
#if not defined(TIMERCORE_USE_TCE0)
TC0_ISR_DEF(TCE0);
    683a:	1f 92       	push	r1
    683c:	0f 92       	push	r0
    683e:	0f b6       	in	r0, 0x3f	; 63
    6840:	0f 92       	push	r0
    6842:	08 b6       	in	r0, 0x38	; 56
    6844:	0f 92       	push	r0
    6846:	09 b6       	in	r0, 0x39	; 57
    6848:	0f 92       	push	r0
    684a:	0b b6       	in	r0, 0x3b	; 59
    684c:	0f 92       	push	r0
    684e:	11 24       	eor	r1, r1
    6850:	18 be       	out	0x38, r1	; 56
    6852:	19 be       	out	0x39, r1	; 57
    6854:	1b be       	out	0x3b, r1	; 59
    6856:	2f 93       	push	r18
    6858:	3f 93       	push	r19
    685a:	4f 93       	push	r20
    685c:	5f 93       	push	r21
    685e:	6f 93       	push	r22
    6860:	7f 93       	push	r23
    6862:	8f 93       	push	r24
    6864:	9f 93       	push	r25
    6866:	af 93       	push	r26
    6868:	bf 93       	push	r27
    686a:	ef 93       	push	r30
    686c:	ff 93       	push	r31
    686e:	80 91 e3 2b 	lds	r24, 0x2BE3
    6872:	90 91 e4 2b 	lds	r25, 0x2BE4
    6876:	00 97       	sbiw	r24, 0x00	; 0
    6878:	11 f0       	breq	.+4      	; 0x687e <__vector_48+0x44>
    687a:	0e 94 5f 33 	call	0x66be	; 0x66be <_ZN9TimerCntr3errEv>
    687e:	ff 91       	pop	r31
    6880:	ef 91       	pop	r30
    6882:	bf 91       	pop	r27
    6884:	af 91       	pop	r26
    6886:	9f 91       	pop	r25
    6888:	8f 91       	pop	r24
    688a:	7f 91       	pop	r23
    688c:	6f 91       	pop	r22
    688e:	5f 91       	pop	r21
    6890:	4f 91       	pop	r20
    6892:	3f 91       	pop	r19
    6894:	2f 91       	pop	r18
    6896:	0f 90       	pop	r0
    6898:	0b be       	out	0x3b, r0	; 59
    689a:	0f 90       	pop	r0
    689c:	09 be       	out	0x39, r0	; 57
    689e:	0f 90       	pop	r0
    68a0:	08 be       	out	0x38, r0	; 56
    68a2:	0f 90       	pop	r0
    68a4:	0f be       	out	0x3f, r0	; 63
    68a6:	0f 90       	pop	r0
    68a8:	1f 90       	pop	r1
    68aa:	18 95       	reti

000068ac <__vector_78>:
ISR(tc##_CCD_vect) {\
    if (tc##cp) tc##cp->ccx(3);\
}

TC0_ISR_DEF(TCC0);
TC0_ISR_DEF(TCD0);
    68ac:	1f 92       	push	r1
    68ae:	0f 92       	push	r0
    68b0:	0f b6       	in	r0, 0x3f	; 63
    68b2:	0f 92       	push	r0
    68b4:	08 b6       	in	r0, 0x38	; 56
    68b6:	0f 92       	push	r0
    68b8:	09 b6       	in	r0, 0x39	; 57
    68ba:	0f 92       	push	r0
    68bc:	0b b6       	in	r0, 0x3b	; 59
    68be:	0f 92       	push	r0
    68c0:	11 24       	eor	r1, r1
    68c2:	18 be       	out	0x38, r1	; 56
    68c4:	19 be       	out	0x39, r1	; 57
    68c6:	1b be       	out	0x3b, r1	; 59
    68c8:	2f 93       	push	r18
    68ca:	3f 93       	push	r19
    68cc:	4f 93       	push	r20
    68ce:	5f 93       	push	r21
    68d0:	6f 93       	push	r22
    68d2:	7f 93       	push	r23
    68d4:	8f 93       	push	r24
    68d6:	9f 93       	push	r25
    68d8:	af 93       	push	r26
    68da:	bf 93       	push	r27
    68dc:	ef 93       	push	r30
    68de:	ff 93       	push	r31
    68e0:	80 91 e1 2b 	lds	r24, 0x2BE1
    68e4:	90 91 e2 2b 	lds	r25, 0x2BE2
    68e8:	00 97       	sbiw	r24, 0x00	; 0
    68ea:	11 f0       	breq	.+4      	; 0x68f0 <__vector_78+0x44>
    68ec:	0e 94 5f 33 	call	0x66be	; 0x66be <_ZN9TimerCntr3errEv>
    68f0:	ff 91       	pop	r31
    68f2:	ef 91       	pop	r30
    68f4:	bf 91       	pop	r27
    68f6:	af 91       	pop	r26
    68f8:	9f 91       	pop	r25
    68fa:	8f 91       	pop	r24
    68fc:	7f 91       	pop	r23
    68fe:	6f 91       	pop	r22
    6900:	5f 91       	pop	r21
    6902:	4f 91       	pop	r20
    6904:	3f 91       	pop	r19
    6906:	2f 91       	pop	r18
    6908:	0f 90       	pop	r0
    690a:	0b be       	out	0x3b, r0	; 59
    690c:	0f 90       	pop	r0
    690e:	09 be       	out	0x39, r0	; 57
    6910:	0f 90       	pop	r0
    6912:	08 be       	out	0x38, r0	; 56
    6914:	0f 90       	pop	r0
    6916:	0f be       	out	0x3f, r0	; 63
    6918:	0f 90       	pop	r0
    691a:	1f 90       	pop	r1
    691c:	18 95       	reti

0000691e <__vector_15>:
}\
ISR(tc##_CCD_vect) {\
    if (tc##cp) tc##cp->ccx(3);\
}

TC0_ISR_DEF(TCC0);
    691e:	1f 92       	push	r1
    6920:	0f 92       	push	r0
    6922:	0f b6       	in	r0, 0x3f	; 63
    6924:	0f 92       	push	r0
    6926:	08 b6       	in	r0, 0x38	; 56
    6928:	0f 92       	push	r0
    692a:	09 b6       	in	r0, 0x39	; 57
    692c:	0f 92       	push	r0
    692e:	0b b6       	in	r0, 0x3b	; 59
    6930:	0f 92       	push	r0
    6932:	11 24       	eor	r1, r1
    6934:	18 be       	out	0x38, r1	; 56
    6936:	19 be       	out	0x39, r1	; 57
    6938:	1b be       	out	0x3b, r1	; 59
    693a:	2f 93       	push	r18
    693c:	3f 93       	push	r19
    693e:	4f 93       	push	r20
    6940:	5f 93       	push	r21
    6942:	6f 93       	push	r22
    6944:	7f 93       	push	r23
    6946:	8f 93       	push	r24
    6948:	9f 93       	push	r25
    694a:	af 93       	push	r26
    694c:	bf 93       	push	r27
    694e:	ef 93       	push	r30
    6950:	ff 93       	push	r31
    6952:	80 91 df 2b 	lds	r24, 0x2BDF
    6956:	90 91 e0 2b 	lds	r25, 0x2BE0
    695a:	00 97       	sbiw	r24, 0x00	; 0
    695c:	11 f0       	breq	.+4      	; 0x6962 <__vector_15+0x44>
    695e:	0e 94 5f 33 	call	0x66be	; 0x66be <_ZN9TimerCntr3errEv>
    6962:	ff 91       	pop	r31
    6964:	ef 91       	pop	r30
    6966:	bf 91       	pop	r27
    6968:	af 91       	pop	r26
    696a:	9f 91       	pop	r25
    696c:	8f 91       	pop	r24
    696e:	7f 91       	pop	r23
    6970:	6f 91       	pop	r22
    6972:	5f 91       	pop	r21
    6974:	4f 91       	pop	r20
    6976:	3f 91       	pop	r19
    6978:	2f 91       	pop	r18
    697a:	0f 90       	pop	r0
    697c:	0b be       	out	0x3b, r0	; 59
    697e:	0f 90       	pop	r0
    6980:	09 be       	out	0x39, r0	; 57
    6982:	0f 90       	pop	r0
    6984:	08 be       	out	0x38, r0	; 56
    6986:	0f 90       	pop	r0
    6988:	0f be       	out	0x3f, r0	; 63
    698a:	0f 90       	pop	r0
    698c:	1f 90       	pop	r1
    698e:	18 95       	reti

00006990 <_ZN9TimerCntr3ovfEv>:
{
    if (_pNotifyClient)  
        _pNotifyClient->err(_pNotifyClientID);
}

void TimerCntr::ovf()
    6990:	cf 93       	push	r28
    6992:	df 93       	push	r29
    6994:	ec 01       	movw	r28, r24
{
    if (_pNotifyClient) 
    6996:	ab 81       	ldd	r26, Y+3	; 0x03
    6998:	bc 81       	ldd	r27, Y+4	; 0x04
    699a:	10 97       	sbiw	r26, 0x00	; 0
    699c:	49 f0       	breq	.+18     	; 0x69b0 <_ZN9TimerCntr3ovfEv+0x20>
        _pNotifyClient->ovf(_pNotifyClientID);
    699e:	ed 91       	ld	r30, X+
    69a0:	fc 91       	ld	r31, X
    69a2:	11 97       	sbiw	r26, 0x01	; 1
    69a4:	02 80       	ldd	r0, Z+2	; 0x02
    69a6:	f3 81       	ldd	r31, Z+3	; 0x03
    69a8:	e0 2d       	mov	r30, r0
    69aa:	cd 01       	movw	r24, r26
    69ac:	6d 81       	ldd	r22, Y+5	; 0x05
    69ae:	19 95       	eicall
}
    69b0:	df 91       	pop	r29
    69b2:	cf 91       	pop	r28
    69b4:	08 95       	ret

000069b6 <__vector_53>:
}

TC1_ISR_DEF(TCC1);
TC1_ISR_DEF(TCD1);
#if not defined(TIMERCORE_USE_TCE1)
TC1_ISR_DEF(TCE1);
    69b6:	1f 92       	push	r1
    69b8:	0f 92       	push	r0
    69ba:	0f b6       	in	r0, 0x3f	; 63
    69bc:	0f 92       	push	r0
    69be:	08 b6       	in	r0, 0x38	; 56
    69c0:	0f 92       	push	r0
    69c2:	09 b6       	in	r0, 0x39	; 57
    69c4:	0f 92       	push	r0
    69c6:	0b b6       	in	r0, 0x3b	; 59
    69c8:	0f 92       	push	r0
    69ca:	11 24       	eor	r1, r1
    69cc:	18 be       	out	0x38, r1	; 56
    69ce:	19 be       	out	0x39, r1	; 57
    69d0:	1b be       	out	0x3b, r1	; 59
    69d2:	2f 93       	push	r18
    69d4:	3f 93       	push	r19
    69d6:	4f 93       	push	r20
    69d8:	5f 93       	push	r21
    69da:	6f 93       	push	r22
    69dc:	7f 93       	push	r23
    69de:	8f 93       	push	r24
    69e0:	9f 93       	push	r25
    69e2:	af 93       	push	r26
    69e4:	bf 93       	push	r27
    69e6:	ef 93       	push	r30
    69e8:	ff 93       	push	r31
    69ea:	80 91 dd 2b 	lds	r24, 0x2BDD
    69ee:	90 91 de 2b 	lds	r25, 0x2BDE
    69f2:	00 97       	sbiw	r24, 0x00	; 0
    69f4:	11 f0       	breq	.+4      	; 0x69fa <__vector_53+0x44>
    69f6:	0e 94 c8 34 	call	0x6990	; 0x6990 <_ZN9TimerCntr3ovfEv>
    69fa:	ff 91       	pop	r31
    69fc:	ef 91       	pop	r30
    69fe:	bf 91       	pop	r27
    6a00:	af 91       	pop	r26
    6a02:	9f 91       	pop	r25
    6a04:	8f 91       	pop	r24
    6a06:	7f 91       	pop	r23
    6a08:	6f 91       	pop	r22
    6a0a:	5f 91       	pop	r21
    6a0c:	4f 91       	pop	r20
    6a0e:	3f 91       	pop	r19
    6a10:	2f 91       	pop	r18
    6a12:	0f 90       	pop	r0
    6a14:	0b be       	out	0x3b, r0	; 59
    6a16:	0f 90       	pop	r0
    6a18:	09 be       	out	0x39, r0	; 57
    6a1a:	0f 90       	pop	r0
    6a1c:	08 be       	out	0x38, r0	; 56
    6a1e:	0f 90       	pop	r0
    6a20:	0f be       	out	0x3f, r0	; 63
    6a22:	0f 90       	pop	r0
    6a24:	1f 90       	pop	r1
    6a26:	18 95       	reti

00006a28 <__vector_83>:
ISR(tc##_CCB_vect) {\
    if (tc##cp) tc##cp->ccx(1);\
}

TC1_ISR_DEF(TCC1);
TC1_ISR_DEF(TCD1);
    6a28:	1f 92       	push	r1
    6a2a:	0f 92       	push	r0
    6a2c:	0f b6       	in	r0, 0x3f	; 63
    6a2e:	0f 92       	push	r0
    6a30:	08 b6       	in	r0, 0x38	; 56
    6a32:	0f 92       	push	r0
    6a34:	09 b6       	in	r0, 0x39	; 57
    6a36:	0f 92       	push	r0
    6a38:	0b b6       	in	r0, 0x3b	; 59
    6a3a:	0f 92       	push	r0
    6a3c:	11 24       	eor	r1, r1
    6a3e:	18 be       	out	0x38, r1	; 56
    6a40:	19 be       	out	0x39, r1	; 57
    6a42:	1b be       	out	0x3b, r1	; 59
    6a44:	2f 93       	push	r18
    6a46:	3f 93       	push	r19
    6a48:	4f 93       	push	r20
    6a4a:	5f 93       	push	r21
    6a4c:	6f 93       	push	r22
    6a4e:	7f 93       	push	r23
    6a50:	8f 93       	push	r24
    6a52:	9f 93       	push	r25
    6a54:	af 93       	push	r26
    6a56:	bf 93       	push	r27
    6a58:	ef 93       	push	r30
    6a5a:	ff 93       	push	r31
    6a5c:	80 91 db 2b 	lds	r24, 0x2BDB
    6a60:	90 91 dc 2b 	lds	r25, 0x2BDC
    6a64:	00 97       	sbiw	r24, 0x00	; 0
    6a66:	11 f0       	breq	.+4      	; 0x6a6c <__vector_83+0x44>
    6a68:	0e 94 c8 34 	call	0x6990	; 0x6990 <_ZN9TimerCntr3ovfEv>
    6a6c:	ff 91       	pop	r31
    6a6e:	ef 91       	pop	r30
    6a70:	bf 91       	pop	r27
    6a72:	af 91       	pop	r26
    6a74:	9f 91       	pop	r25
    6a76:	8f 91       	pop	r24
    6a78:	7f 91       	pop	r23
    6a7a:	6f 91       	pop	r22
    6a7c:	5f 91       	pop	r21
    6a7e:	4f 91       	pop	r20
    6a80:	3f 91       	pop	r19
    6a82:	2f 91       	pop	r18
    6a84:	0f 90       	pop	r0
    6a86:	0b be       	out	0x3b, r0	; 59
    6a88:	0f 90       	pop	r0
    6a8a:	09 be       	out	0x39, r0	; 57
    6a8c:	0f 90       	pop	r0
    6a8e:	08 be       	out	0x38, r0	; 56
    6a90:	0f 90       	pop	r0
    6a92:	0f be       	out	0x3f, r0	; 63
    6a94:	0f 90       	pop	r0
    6a96:	1f 90       	pop	r1
    6a98:	18 95       	reti

00006a9a <__vector_20>:
}\
ISR(tc##_CCB_vect) {\
    if (tc##cp) tc##cp->ccx(1);\
}

TC1_ISR_DEF(TCC1);
    6a9a:	1f 92       	push	r1
    6a9c:	0f 92       	push	r0
    6a9e:	0f b6       	in	r0, 0x3f	; 63
    6aa0:	0f 92       	push	r0
    6aa2:	08 b6       	in	r0, 0x38	; 56
    6aa4:	0f 92       	push	r0
    6aa6:	09 b6       	in	r0, 0x39	; 57
    6aa8:	0f 92       	push	r0
    6aaa:	0b b6       	in	r0, 0x3b	; 59
    6aac:	0f 92       	push	r0
    6aae:	11 24       	eor	r1, r1
    6ab0:	18 be       	out	0x38, r1	; 56
    6ab2:	19 be       	out	0x39, r1	; 57
    6ab4:	1b be       	out	0x3b, r1	; 59
    6ab6:	2f 93       	push	r18
    6ab8:	3f 93       	push	r19
    6aba:	4f 93       	push	r20
    6abc:	5f 93       	push	r21
    6abe:	6f 93       	push	r22
    6ac0:	7f 93       	push	r23
    6ac2:	8f 93       	push	r24
    6ac4:	9f 93       	push	r25
    6ac6:	af 93       	push	r26
    6ac8:	bf 93       	push	r27
    6aca:	ef 93       	push	r30
    6acc:	ff 93       	push	r31
    6ace:	80 91 d9 2b 	lds	r24, 0x2BD9
    6ad2:	90 91 da 2b 	lds	r25, 0x2BDA
    6ad6:	00 97       	sbiw	r24, 0x00	; 0
    6ad8:	11 f0       	breq	.+4      	; 0x6ade <__vector_20+0x44>
    6ada:	0e 94 c8 34 	call	0x6990	; 0x6990 <_ZN9TimerCntr3ovfEv>
    6ade:	ff 91       	pop	r31
    6ae0:	ef 91       	pop	r30
    6ae2:	bf 91       	pop	r27
    6ae4:	af 91       	pop	r26
    6ae6:	9f 91       	pop	r25
    6ae8:	8f 91       	pop	r24
    6aea:	7f 91       	pop	r23
    6aec:	6f 91       	pop	r22
    6aee:	5f 91       	pop	r21
    6af0:	4f 91       	pop	r20
    6af2:	3f 91       	pop	r19
    6af4:	2f 91       	pop	r18
    6af6:	0f 90       	pop	r0
    6af8:	0b be       	out	0x3b, r0	; 59
    6afa:	0f 90       	pop	r0
    6afc:	09 be       	out	0x39, r0	; 57
    6afe:	0f 90       	pop	r0
    6b00:	08 be       	out	0x38, r0	; 56
    6b02:	0f 90       	pop	r0
    6b04:	0f be       	out	0x3f, r0	; 63
    6b06:	0f 90       	pop	r0
    6b08:	1f 90       	pop	r1
    6b0a:	18 95       	reti

00006b0c <__vector_47>:

// The TimerCore.cpp will use TCE0 and TCE1 if
// TCF1 is not defined.. Hence, I need to NOT define
// It here. 
#if not defined(TIMERCORE_USE_TCE0)
TC0_ISR_DEF(TCE0);
    6b0c:	1f 92       	push	r1
    6b0e:	0f 92       	push	r0
    6b10:	0f b6       	in	r0, 0x3f	; 63
    6b12:	0f 92       	push	r0
    6b14:	08 b6       	in	r0, 0x38	; 56
    6b16:	0f 92       	push	r0
    6b18:	09 b6       	in	r0, 0x39	; 57
    6b1a:	0f 92       	push	r0
    6b1c:	0b b6       	in	r0, 0x3b	; 59
    6b1e:	0f 92       	push	r0
    6b20:	11 24       	eor	r1, r1
    6b22:	18 be       	out	0x38, r1	; 56
    6b24:	19 be       	out	0x39, r1	; 57
    6b26:	1b be       	out	0x3b, r1	; 59
    6b28:	2f 93       	push	r18
    6b2a:	3f 93       	push	r19
    6b2c:	4f 93       	push	r20
    6b2e:	5f 93       	push	r21
    6b30:	6f 93       	push	r22
    6b32:	7f 93       	push	r23
    6b34:	8f 93       	push	r24
    6b36:	9f 93       	push	r25
    6b38:	af 93       	push	r26
    6b3a:	bf 93       	push	r27
    6b3c:	ef 93       	push	r30
    6b3e:	ff 93       	push	r31
    6b40:	80 91 e3 2b 	lds	r24, 0x2BE3
    6b44:	90 91 e4 2b 	lds	r25, 0x2BE4
    6b48:	00 97       	sbiw	r24, 0x00	; 0
    6b4a:	11 f0       	breq	.+4      	; 0x6b50 <__vector_47+0x44>
    6b4c:	0e 94 c8 34 	call	0x6990	; 0x6990 <_ZN9TimerCntr3ovfEv>
    6b50:	ff 91       	pop	r31
    6b52:	ef 91       	pop	r30
    6b54:	bf 91       	pop	r27
    6b56:	af 91       	pop	r26
    6b58:	9f 91       	pop	r25
    6b5a:	8f 91       	pop	r24
    6b5c:	7f 91       	pop	r23
    6b5e:	6f 91       	pop	r22
    6b60:	5f 91       	pop	r21
    6b62:	4f 91       	pop	r20
    6b64:	3f 91       	pop	r19
    6b66:	2f 91       	pop	r18
    6b68:	0f 90       	pop	r0
    6b6a:	0b be       	out	0x3b, r0	; 59
    6b6c:	0f 90       	pop	r0
    6b6e:	09 be       	out	0x39, r0	; 57
    6b70:	0f 90       	pop	r0
    6b72:	08 be       	out	0x38, r0	; 56
    6b74:	0f 90       	pop	r0
    6b76:	0f be       	out	0x3f, r0	; 63
    6b78:	0f 90       	pop	r0
    6b7a:	1f 90       	pop	r1
    6b7c:	18 95       	reti

00006b7e <__vector_77>:
ISR(tc##_CCD_vect) {\
    if (tc##cp) tc##cp->ccx(3);\
}

TC0_ISR_DEF(TCC0);
TC0_ISR_DEF(TCD0);
    6b7e:	1f 92       	push	r1
    6b80:	0f 92       	push	r0
    6b82:	0f b6       	in	r0, 0x3f	; 63
    6b84:	0f 92       	push	r0
    6b86:	08 b6       	in	r0, 0x38	; 56
    6b88:	0f 92       	push	r0
    6b8a:	09 b6       	in	r0, 0x39	; 57
    6b8c:	0f 92       	push	r0
    6b8e:	0b b6       	in	r0, 0x3b	; 59
    6b90:	0f 92       	push	r0
    6b92:	11 24       	eor	r1, r1
    6b94:	18 be       	out	0x38, r1	; 56
    6b96:	19 be       	out	0x39, r1	; 57
    6b98:	1b be       	out	0x3b, r1	; 59
    6b9a:	2f 93       	push	r18
    6b9c:	3f 93       	push	r19
    6b9e:	4f 93       	push	r20
    6ba0:	5f 93       	push	r21
    6ba2:	6f 93       	push	r22
    6ba4:	7f 93       	push	r23
    6ba6:	8f 93       	push	r24
    6ba8:	9f 93       	push	r25
    6baa:	af 93       	push	r26
    6bac:	bf 93       	push	r27
    6bae:	ef 93       	push	r30
    6bb0:	ff 93       	push	r31
    6bb2:	80 91 e1 2b 	lds	r24, 0x2BE1
    6bb6:	90 91 e2 2b 	lds	r25, 0x2BE2
    6bba:	00 97       	sbiw	r24, 0x00	; 0
    6bbc:	11 f0       	breq	.+4      	; 0x6bc2 <__vector_77+0x44>
    6bbe:	0e 94 c8 34 	call	0x6990	; 0x6990 <_ZN9TimerCntr3ovfEv>
    6bc2:	ff 91       	pop	r31
    6bc4:	ef 91       	pop	r30
    6bc6:	bf 91       	pop	r27
    6bc8:	af 91       	pop	r26
    6bca:	9f 91       	pop	r25
    6bcc:	8f 91       	pop	r24
    6bce:	7f 91       	pop	r23
    6bd0:	6f 91       	pop	r22
    6bd2:	5f 91       	pop	r21
    6bd4:	4f 91       	pop	r20
    6bd6:	3f 91       	pop	r19
    6bd8:	2f 91       	pop	r18
    6bda:	0f 90       	pop	r0
    6bdc:	0b be       	out	0x3b, r0	; 59
    6bde:	0f 90       	pop	r0
    6be0:	09 be       	out	0x39, r0	; 57
    6be2:	0f 90       	pop	r0
    6be4:	08 be       	out	0x38, r0	; 56
    6be6:	0f 90       	pop	r0
    6be8:	0f be       	out	0x3f, r0	; 63
    6bea:	0f 90       	pop	r0
    6bec:	1f 90       	pop	r1
    6bee:	18 95       	reti

00006bf0 <__vector_14>:
}\
ISR(tc##_CCD_vect) {\
    if (tc##cp) tc##cp->ccx(3);\
}

TC0_ISR_DEF(TCC0);
    6bf0:	1f 92       	push	r1
    6bf2:	0f 92       	push	r0
    6bf4:	0f b6       	in	r0, 0x3f	; 63
    6bf6:	0f 92       	push	r0
    6bf8:	08 b6       	in	r0, 0x38	; 56
    6bfa:	0f 92       	push	r0
    6bfc:	09 b6       	in	r0, 0x39	; 57
    6bfe:	0f 92       	push	r0
    6c00:	0b b6       	in	r0, 0x3b	; 59
    6c02:	0f 92       	push	r0
    6c04:	11 24       	eor	r1, r1
    6c06:	18 be       	out	0x38, r1	; 56
    6c08:	19 be       	out	0x39, r1	; 57
    6c0a:	1b be       	out	0x3b, r1	; 59
    6c0c:	2f 93       	push	r18
    6c0e:	3f 93       	push	r19
    6c10:	4f 93       	push	r20
    6c12:	5f 93       	push	r21
    6c14:	6f 93       	push	r22
    6c16:	7f 93       	push	r23
    6c18:	8f 93       	push	r24
    6c1a:	9f 93       	push	r25
    6c1c:	af 93       	push	r26
    6c1e:	bf 93       	push	r27
    6c20:	ef 93       	push	r30
    6c22:	ff 93       	push	r31
    6c24:	80 91 df 2b 	lds	r24, 0x2BDF
    6c28:	90 91 e0 2b 	lds	r25, 0x2BE0
    6c2c:	00 97       	sbiw	r24, 0x00	; 0
    6c2e:	11 f0       	breq	.+4      	; 0x6c34 <__vector_14+0x44>
    6c30:	0e 94 c8 34 	call	0x6990	; 0x6990 <_ZN9TimerCntr3ovfEv>
    6c34:	ff 91       	pop	r31
    6c36:	ef 91       	pop	r30
    6c38:	bf 91       	pop	r27
    6c3a:	af 91       	pop	r26
    6c3c:	9f 91       	pop	r25
    6c3e:	8f 91       	pop	r24
    6c40:	7f 91       	pop	r23
    6c42:	6f 91       	pop	r22
    6c44:	5f 91       	pop	r21
    6c46:	4f 91       	pop	r20
    6c48:	3f 91       	pop	r19
    6c4a:	2f 91       	pop	r18
    6c4c:	0f 90       	pop	r0
    6c4e:	0b be       	out	0x3b, r0	; 59
    6c50:	0f 90       	pop	r0
    6c52:	09 be       	out	0x39, r0	; 57
    6c54:	0f 90       	pop	r0
    6c56:	08 be       	out	0x38, r0	; 56
    6c58:	0f 90       	pop	r0
    6c5a:	0f be       	out	0x3f, r0	; 63
    6c5c:	0f 90       	pop	r0
    6c5e:	1f 90       	pop	r1
    6c60:	18 95       	reti

00006c62 <_ZN9TimerCntr3ccxEh>:
{
    if (_pNotifyClient) 
        _pNotifyClient->ovf(_pNotifyClientID);
}

void TimerCntr::ccx(uint8_t idx)
    6c62:	cf 93       	push	r28
    6c64:	df 93       	push	r29
    6c66:	ec 01       	movw	r28, r24
    6c68:	46 2f       	mov	r20, r22
{
    if (_pNotifyClient) 
    6c6a:	ab 81       	ldd	r26, Y+3	; 0x03
    6c6c:	bc 81       	ldd	r27, Y+4	; 0x04
    6c6e:	10 97       	sbiw	r26, 0x00	; 0
    6c70:	49 f0       	breq	.+18     	; 0x6c84 <_ZN9TimerCntr3ccxEh+0x22>
        _pNotifyClient->ccx(_pNotifyClientID,idx);
    6c72:	ed 91       	ld	r30, X+
    6c74:	fc 91       	ld	r31, X
    6c76:	11 97       	sbiw	r26, 0x01	; 1
    6c78:	04 80       	ldd	r0, Z+4	; 0x04
    6c7a:	f5 81       	ldd	r31, Z+5	; 0x05
    6c7c:	e0 2d       	mov	r30, r0
    6c7e:	cd 01       	movw	r24, r26
    6c80:	6d 81       	ldd	r22, Y+5	; 0x05
    6c82:	19 95       	eicall
}
    6c84:	df 91       	pop	r29
    6c86:	cf 91       	pop	r28
    6c88:	08 95       	ret

00006c8a <__vector_56>:
}

TC1_ISR_DEF(TCC1);
TC1_ISR_DEF(TCD1);
#if not defined(TIMERCORE_USE_TCE1)
TC1_ISR_DEF(TCE1);
    6c8a:	1f 92       	push	r1
    6c8c:	0f 92       	push	r0
    6c8e:	0f b6       	in	r0, 0x3f	; 63
    6c90:	0f 92       	push	r0
    6c92:	08 b6       	in	r0, 0x38	; 56
    6c94:	0f 92       	push	r0
    6c96:	09 b6       	in	r0, 0x39	; 57
    6c98:	0f 92       	push	r0
    6c9a:	0b b6       	in	r0, 0x3b	; 59
    6c9c:	0f 92       	push	r0
    6c9e:	11 24       	eor	r1, r1
    6ca0:	18 be       	out	0x38, r1	; 56
    6ca2:	19 be       	out	0x39, r1	; 57
    6ca4:	1b be       	out	0x3b, r1	; 59
    6ca6:	2f 93       	push	r18
    6ca8:	3f 93       	push	r19
    6caa:	4f 93       	push	r20
    6cac:	5f 93       	push	r21
    6cae:	6f 93       	push	r22
    6cb0:	7f 93       	push	r23
    6cb2:	8f 93       	push	r24
    6cb4:	9f 93       	push	r25
    6cb6:	af 93       	push	r26
    6cb8:	bf 93       	push	r27
    6cba:	ef 93       	push	r30
    6cbc:	ff 93       	push	r31
    6cbe:	80 91 dd 2b 	lds	r24, 0x2BDD
    6cc2:	90 91 de 2b 	lds	r25, 0x2BDE
    6cc6:	00 97       	sbiw	r24, 0x00	; 0
    6cc8:	19 f0       	breq	.+6      	; 0x6cd0 <__vector_56+0x46>
    6cca:	61 e0       	ldi	r22, 0x01	; 1
    6ccc:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6cd0:	ff 91       	pop	r31
    6cd2:	ef 91       	pop	r30
    6cd4:	bf 91       	pop	r27
    6cd6:	af 91       	pop	r26
    6cd8:	9f 91       	pop	r25
    6cda:	8f 91       	pop	r24
    6cdc:	7f 91       	pop	r23
    6cde:	6f 91       	pop	r22
    6ce0:	5f 91       	pop	r21
    6ce2:	4f 91       	pop	r20
    6ce4:	3f 91       	pop	r19
    6ce6:	2f 91       	pop	r18
    6ce8:	0f 90       	pop	r0
    6cea:	0b be       	out	0x3b, r0	; 59
    6cec:	0f 90       	pop	r0
    6cee:	09 be       	out	0x39, r0	; 57
    6cf0:	0f 90       	pop	r0
    6cf2:	08 be       	out	0x38, r0	; 56
    6cf4:	0f 90       	pop	r0
    6cf6:	0f be       	out	0x3f, r0	; 63
    6cf8:	0f 90       	pop	r0
    6cfa:	1f 90       	pop	r1
    6cfc:	18 95       	reti

00006cfe <__vector_55>:
    6cfe:	1f 92       	push	r1
    6d00:	0f 92       	push	r0
    6d02:	0f b6       	in	r0, 0x3f	; 63
    6d04:	0f 92       	push	r0
    6d06:	08 b6       	in	r0, 0x38	; 56
    6d08:	0f 92       	push	r0
    6d0a:	09 b6       	in	r0, 0x39	; 57
    6d0c:	0f 92       	push	r0
    6d0e:	0b b6       	in	r0, 0x3b	; 59
    6d10:	0f 92       	push	r0
    6d12:	11 24       	eor	r1, r1
    6d14:	18 be       	out	0x38, r1	; 56
    6d16:	19 be       	out	0x39, r1	; 57
    6d18:	1b be       	out	0x3b, r1	; 59
    6d1a:	2f 93       	push	r18
    6d1c:	3f 93       	push	r19
    6d1e:	4f 93       	push	r20
    6d20:	5f 93       	push	r21
    6d22:	6f 93       	push	r22
    6d24:	7f 93       	push	r23
    6d26:	8f 93       	push	r24
    6d28:	9f 93       	push	r25
    6d2a:	af 93       	push	r26
    6d2c:	bf 93       	push	r27
    6d2e:	ef 93       	push	r30
    6d30:	ff 93       	push	r31
    6d32:	80 91 dd 2b 	lds	r24, 0x2BDD
    6d36:	90 91 de 2b 	lds	r25, 0x2BDE
    6d3a:	00 97       	sbiw	r24, 0x00	; 0
    6d3c:	19 f0       	breq	.+6      	; 0x6d44 <__vector_55+0x46>
    6d3e:	60 e0       	ldi	r22, 0x00	; 0
    6d40:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6d44:	ff 91       	pop	r31
    6d46:	ef 91       	pop	r30
    6d48:	bf 91       	pop	r27
    6d4a:	af 91       	pop	r26
    6d4c:	9f 91       	pop	r25
    6d4e:	8f 91       	pop	r24
    6d50:	7f 91       	pop	r23
    6d52:	6f 91       	pop	r22
    6d54:	5f 91       	pop	r21
    6d56:	4f 91       	pop	r20
    6d58:	3f 91       	pop	r19
    6d5a:	2f 91       	pop	r18
    6d5c:	0f 90       	pop	r0
    6d5e:	0b be       	out	0x3b, r0	; 59
    6d60:	0f 90       	pop	r0
    6d62:	09 be       	out	0x39, r0	; 57
    6d64:	0f 90       	pop	r0
    6d66:	08 be       	out	0x38, r0	; 56
    6d68:	0f 90       	pop	r0
    6d6a:	0f be       	out	0x3f, r0	; 63
    6d6c:	0f 90       	pop	r0
    6d6e:	1f 90       	pop	r1
    6d70:	18 95       	reti

00006d72 <__vector_86>:
ISR(tc##_CCB_vect) {\
    if (tc##cp) tc##cp->ccx(1);\
}

TC1_ISR_DEF(TCC1);
TC1_ISR_DEF(TCD1);
    6d72:	1f 92       	push	r1
    6d74:	0f 92       	push	r0
    6d76:	0f b6       	in	r0, 0x3f	; 63
    6d78:	0f 92       	push	r0
    6d7a:	08 b6       	in	r0, 0x38	; 56
    6d7c:	0f 92       	push	r0
    6d7e:	09 b6       	in	r0, 0x39	; 57
    6d80:	0f 92       	push	r0
    6d82:	0b b6       	in	r0, 0x3b	; 59
    6d84:	0f 92       	push	r0
    6d86:	11 24       	eor	r1, r1
    6d88:	18 be       	out	0x38, r1	; 56
    6d8a:	19 be       	out	0x39, r1	; 57
    6d8c:	1b be       	out	0x3b, r1	; 59
    6d8e:	2f 93       	push	r18
    6d90:	3f 93       	push	r19
    6d92:	4f 93       	push	r20
    6d94:	5f 93       	push	r21
    6d96:	6f 93       	push	r22
    6d98:	7f 93       	push	r23
    6d9a:	8f 93       	push	r24
    6d9c:	9f 93       	push	r25
    6d9e:	af 93       	push	r26
    6da0:	bf 93       	push	r27
    6da2:	ef 93       	push	r30
    6da4:	ff 93       	push	r31
    6da6:	80 91 db 2b 	lds	r24, 0x2BDB
    6daa:	90 91 dc 2b 	lds	r25, 0x2BDC
    6dae:	00 97       	sbiw	r24, 0x00	; 0
    6db0:	19 f0       	breq	.+6      	; 0x6db8 <__vector_86+0x46>
    6db2:	61 e0       	ldi	r22, 0x01	; 1
    6db4:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6db8:	ff 91       	pop	r31
    6dba:	ef 91       	pop	r30
    6dbc:	bf 91       	pop	r27
    6dbe:	af 91       	pop	r26
    6dc0:	9f 91       	pop	r25
    6dc2:	8f 91       	pop	r24
    6dc4:	7f 91       	pop	r23
    6dc6:	6f 91       	pop	r22
    6dc8:	5f 91       	pop	r21
    6dca:	4f 91       	pop	r20
    6dcc:	3f 91       	pop	r19
    6dce:	2f 91       	pop	r18
    6dd0:	0f 90       	pop	r0
    6dd2:	0b be       	out	0x3b, r0	; 59
    6dd4:	0f 90       	pop	r0
    6dd6:	09 be       	out	0x39, r0	; 57
    6dd8:	0f 90       	pop	r0
    6dda:	08 be       	out	0x38, r0	; 56
    6ddc:	0f 90       	pop	r0
    6dde:	0f be       	out	0x3f, r0	; 63
    6de0:	0f 90       	pop	r0
    6de2:	1f 90       	pop	r1
    6de4:	18 95       	reti

00006de6 <__vector_85>:
    6de6:	1f 92       	push	r1
    6de8:	0f 92       	push	r0
    6dea:	0f b6       	in	r0, 0x3f	; 63
    6dec:	0f 92       	push	r0
    6dee:	08 b6       	in	r0, 0x38	; 56
    6df0:	0f 92       	push	r0
    6df2:	09 b6       	in	r0, 0x39	; 57
    6df4:	0f 92       	push	r0
    6df6:	0b b6       	in	r0, 0x3b	; 59
    6df8:	0f 92       	push	r0
    6dfa:	11 24       	eor	r1, r1
    6dfc:	18 be       	out	0x38, r1	; 56
    6dfe:	19 be       	out	0x39, r1	; 57
    6e00:	1b be       	out	0x3b, r1	; 59
    6e02:	2f 93       	push	r18
    6e04:	3f 93       	push	r19
    6e06:	4f 93       	push	r20
    6e08:	5f 93       	push	r21
    6e0a:	6f 93       	push	r22
    6e0c:	7f 93       	push	r23
    6e0e:	8f 93       	push	r24
    6e10:	9f 93       	push	r25
    6e12:	af 93       	push	r26
    6e14:	bf 93       	push	r27
    6e16:	ef 93       	push	r30
    6e18:	ff 93       	push	r31
    6e1a:	80 91 db 2b 	lds	r24, 0x2BDB
    6e1e:	90 91 dc 2b 	lds	r25, 0x2BDC
    6e22:	00 97       	sbiw	r24, 0x00	; 0
    6e24:	19 f0       	breq	.+6      	; 0x6e2c <__vector_85+0x46>
    6e26:	60 e0       	ldi	r22, 0x00	; 0
    6e28:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6e2c:	ff 91       	pop	r31
    6e2e:	ef 91       	pop	r30
    6e30:	bf 91       	pop	r27
    6e32:	af 91       	pop	r26
    6e34:	9f 91       	pop	r25
    6e36:	8f 91       	pop	r24
    6e38:	7f 91       	pop	r23
    6e3a:	6f 91       	pop	r22
    6e3c:	5f 91       	pop	r21
    6e3e:	4f 91       	pop	r20
    6e40:	3f 91       	pop	r19
    6e42:	2f 91       	pop	r18
    6e44:	0f 90       	pop	r0
    6e46:	0b be       	out	0x3b, r0	; 59
    6e48:	0f 90       	pop	r0
    6e4a:	09 be       	out	0x39, r0	; 57
    6e4c:	0f 90       	pop	r0
    6e4e:	08 be       	out	0x38, r0	; 56
    6e50:	0f 90       	pop	r0
    6e52:	0f be       	out	0x3f, r0	; 63
    6e54:	0f 90       	pop	r0
    6e56:	1f 90       	pop	r1
    6e58:	18 95       	reti

00006e5a <__vector_23>:
}\
ISR(tc##_CCB_vect) {\
    if (tc##cp) tc##cp->ccx(1);\
}

TC1_ISR_DEF(TCC1);
    6e5a:	1f 92       	push	r1
    6e5c:	0f 92       	push	r0
    6e5e:	0f b6       	in	r0, 0x3f	; 63
    6e60:	0f 92       	push	r0
    6e62:	08 b6       	in	r0, 0x38	; 56
    6e64:	0f 92       	push	r0
    6e66:	09 b6       	in	r0, 0x39	; 57
    6e68:	0f 92       	push	r0
    6e6a:	0b b6       	in	r0, 0x3b	; 59
    6e6c:	0f 92       	push	r0
    6e6e:	11 24       	eor	r1, r1
    6e70:	18 be       	out	0x38, r1	; 56
    6e72:	19 be       	out	0x39, r1	; 57
    6e74:	1b be       	out	0x3b, r1	; 59
    6e76:	2f 93       	push	r18
    6e78:	3f 93       	push	r19
    6e7a:	4f 93       	push	r20
    6e7c:	5f 93       	push	r21
    6e7e:	6f 93       	push	r22
    6e80:	7f 93       	push	r23
    6e82:	8f 93       	push	r24
    6e84:	9f 93       	push	r25
    6e86:	af 93       	push	r26
    6e88:	bf 93       	push	r27
    6e8a:	ef 93       	push	r30
    6e8c:	ff 93       	push	r31
    6e8e:	80 91 d9 2b 	lds	r24, 0x2BD9
    6e92:	90 91 da 2b 	lds	r25, 0x2BDA
    6e96:	00 97       	sbiw	r24, 0x00	; 0
    6e98:	19 f0       	breq	.+6      	; 0x6ea0 <__vector_23+0x46>
    6e9a:	61 e0       	ldi	r22, 0x01	; 1
    6e9c:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6ea0:	ff 91       	pop	r31
    6ea2:	ef 91       	pop	r30
    6ea4:	bf 91       	pop	r27
    6ea6:	af 91       	pop	r26
    6ea8:	9f 91       	pop	r25
    6eaa:	8f 91       	pop	r24
    6eac:	7f 91       	pop	r23
    6eae:	6f 91       	pop	r22
    6eb0:	5f 91       	pop	r21
    6eb2:	4f 91       	pop	r20
    6eb4:	3f 91       	pop	r19
    6eb6:	2f 91       	pop	r18
    6eb8:	0f 90       	pop	r0
    6eba:	0b be       	out	0x3b, r0	; 59
    6ebc:	0f 90       	pop	r0
    6ebe:	09 be       	out	0x39, r0	; 57
    6ec0:	0f 90       	pop	r0
    6ec2:	08 be       	out	0x38, r0	; 56
    6ec4:	0f 90       	pop	r0
    6ec6:	0f be       	out	0x3f, r0	; 63
    6ec8:	0f 90       	pop	r0
    6eca:	1f 90       	pop	r1
    6ecc:	18 95       	reti

00006ece <__vector_22>:
    6ece:	1f 92       	push	r1
    6ed0:	0f 92       	push	r0
    6ed2:	0f b6       	in	r0, 0x3f	; 63
    6ed4:	0f 92       	push	r0
    6ed6:	08 b6       	in	r0, 0x38	; 56
    6ed8:	0f 92       	push	r0
    6eda:	09 b6       	in	r0, 0x39	; 57
    6edc:	0f 92       	push	r0
    6ede:	0b b6       	in	r0, 0x3b	; 59
    6ee0:	0f 92       	push	r0
    6ee2:	11 24       	eor	r1, r1
    6ee4:	18 be       	out	0x38, r1	; 56
    6ee6:	19 be       	out	0x39, r1	; 57
    6ee8:	1b be       	out	0x3b, r1	; 59
    6eea:	2f 93       	push	r18
    6eec:	3f 93       	push	r19
    6eee:	4f 93       	push	r20
    6ef0:	5f 93       	push	r21
    6ef2:	6f 93       	push	r22
    6ef4:	7f 93       	push	r23
    6ef6:	8f 93       	push	r24
    6ef8:	9f 93       	push	r25
    6efa:	af 93       	push	r26
    6efc:	bf 93       	push	r27
    6efe:	ef 93       	push	r30
    6f00:	ff 93       	push	r31
    6f02:	80 91 d9 2b 	lds	r24, 0x2BD9
    6f06:	90 91 da 2b 	lds	r25, 0x2BDA
    6f0a:	00 97       	sbiw	r24, 0x00	; 0
    6f0c:	19 f0       	breq	.+6      	; 0x6f14 <__vector_22+0x46>
    6f0e:	60 e0       	ldi	r22, 0x00	; 0
    6f10:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6f14:	ff 91       	pop	r31
    6f16:	ef 91       	pop	r30
    6f18:	bf 91       	pop	r27
    6f1a:	af 91       	pop	r26
    6f1c:	9f 91       	pop	r25
    6f1e:	8f 91       	pop	r24
    6f20:	7f 91       	pop	r23
    6f22:	6f 91       	pop	r22
    6f24:	5f 91       	pop	r21
    6f26:	4f 91       	pop	r20
    6f28:	3f 91       	pop	r19
    6f2a:	2f 91       	pop	r18
    6f2c:	0f 90       	pop	r0
    6f2e:	0b be       	out	0x3b, r0	; 59
    6f30:	0f 90       	pop	r0
    6f32:	09 be       	out	0x39, r0	; 57
    6f34:	0f 90       	pop	r0
    6f36:	08 be       	out	0x38, r0	; 56
    6f38:	0f 90       	pop	r0
    6f3a:	0f be       	out	0x3f, r0	; 63
    6f3c:	0f 90       	pop	r0
    6f3e:	1f 90       	pop	r1
    6f40:	18 95       	reti

00006f42 <__vector_52>:

// The TimerCore.cpp will use TCE0 and TCE1 if
// TCF1 is not defined.. Hence, I need to NOT define
// It here. 
#if not defined(TIMERCORE_USE_TCE0)
TC0_ISR_DEF(TCE0);
    6f42:	1f 92       	push	r1
    6f44:	0f 92       	push	r0
    6f46:	0f b6       	in	r0, 0x3f	; 63
    6f48:	0f 92       	push	r0
    6f4a:	08 b6       	in	r0, 0x38	; 56
    6f4c:	0f 92       	push	r0
    6f4e:	09 b6       	in	r0, 0x39	; 57
    6f50:	0f 92       	push	r0
    6f52:	0b b6       	in	r0, 0x3b	; 59
    6f54:	0f 92       	push	r0
    6f56:	11 24       	eor	r1, r1
    6f58:	18 be       	out	0x38, r1	; 56
    6f5a:	19 be       	out	0x39, r1	; 57
    6f5c:	1b be       	out	0x3b, r1	; 59
    6f5e:	2f 93       	push	r18
    6f60:	3f 93       	push	r19
    6f62:	4f 93       	push	r20
    6f64:	5f 93       	push	r21
    6f66:	6f 93       	push	r22
    6f68:	7f 93       	push	r23
    6f6a:	8f 93       	push	r24
    6f6c:	9f 93       	push	r25
    6f6e:	af 93       	push	r26
    6f70:	bf 93       	push	r27
    6f72:	ef 93       	push	r30
    6f74:	ff 93       	push	r31
    6f76:	80 91 e3 2b 	lds	r24, 0x2BE3
    6f7a:	90 91 e4 2b 	lds	r25, 0x2BE4
    6f7e:	00 97       	sbiw	r24, 0x00	; 0
    6f80:	19 f0       	breq	.+6      	; 0x6f88 <__vector_52+0x46>
    6f82:	63 e0       	ldi	r22, 0x03	; 3
    6f84:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6f88:	ff 91       	pop	r31
    6f8a:	ef 91       	pop	r30
    6f8c:	bf 91       	pop	r27
    6f8e:	af 91       	pop	r26
    6f90:	9f 91       	pop	r25
    6f92:	8f 91       	pop	r24
    6f94:	7f 91       	pop	r23
    6f96:	6f 91       	pop	r22
    6f98:	5f 91       	pop	r21
    6f9a:	4f 91       	pop	r20
    6f9c:	3f 91       	pop	r19
    6f9e:	2f 91       	pop	r18
    6fa0:	0f 90       	pop	r0
    6fa2:	0b be       	out	0x3b, r0	; 59
    6fa4:	0f 90       	pop	r0
    6fa6:	09 be       	out	0x39, r0	; 57
    6fa8:	0f 90       	pop	r0
    6faa:	08 be       	out	0x38, r0	; 56
    6fac:	0f 90       	pop	r0
    6fae:	0f be       	out	0x3f, r0	; 63
    6fb0:	0f 90       	pop	r0
    6fb2:	1f 90       	pop	r1
    6fb4:	18 95       	reti

00006fb6 <__vector_51>:
    6fb6:	1f 92       	push	r1
    6fb8:	0f 92       	push	r0
    6fba:	0f b6       	in	r0, 0x3f	; 63
    6fbc:	0f 92       	push	r0
    6fbe:	08 b6       	in	r0, 0x38	; 56
    6fc0:	0f 92       	push	r0
    6fc2:	09 b6       	in	r0, 0x39	; 57
    6fc4:	0f 92       	push	r0
    6fc6:	0b b6       	in	r0, 0x3b	; 59
    6fc8:	0f 92       	push	r0
    6fca:	11 24       	eor	r1, r1
    6fcc:	18 be       	out	0x38, r1	; 56
    6fce:	19 be       	out	0x39, r1	; 57
    6fd0:	1b be       	out	0x3b, r1	; 59
    6fd2:	2f 93       	push	r18
    6fd4:	3f 93       	push	r19
    6fd6:	4f 93       	push	r20
    6fd8:	5f 93       	push	r21
    6fda:	6f 93       	push	r22
    6fdc:	7f 93       	push	r23
    6fde:	8f 93       	push	r24
    6fe0:	9f 93       	push	r25
    6fe2:	af 93       	push	r26
    6fe4:	bf 93       	push	r27
    6fe6:	ef 93       	push	r30
    6fe8:	ff 93       	push	r31
    6fea:	80 91 e3 2b 	lds	r24, 0x2BE3
    6fee:	90 91 e4 2b 	lds	r25, 0x2BE4
    6ff2:	00 97       	sbiw	r24, 0x00	; 0
    6ff4:	19 f0       	breq	.+6      	; 0x6ffc <__vector_51+0x46>
    6ff6:	62 e0       	ldi	r22, 0x02	; 2
    6ff8:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    6ffc:	ff 91       	pop	r31
    6ffe:	ef 91       	pop	r30
    7000:	bf 91       	pop	r27
    7002:	af 91       	pop	r26
    7004:	9f 91       	pop	r25
    7006:	8f 91       	pop	r24
    7008:	7f 91       	pop	r23
    700a:	6f 91       	pop	r22
    700c:	5f 91       	pop	r21
    700e:	4f 91       	pop	r20
    7010:	3f 91       	pop	r19
    7012:	2f 91       	pop	r18
    7014:	0f 90       	pop	r0
    7016:	0b be       	out	0x3b, r0	; 59
    7018:	0f 90       	pop	r0
    701a:	09 be       	out	0x39, r0	; 57
    701c:	0f 90       	pop	r0
    701e:	08 be       	out	0x38, r0	; 56
    7020:	0f 90       	pop	r0
    7022:	0f be       	out	0x3f, r0	; 63
    7024:	0f 90       	pop	r0
    7026:	1f 90       	pop	r1
    7028:	18 95       	reti

0000702a <__vector_50>:
    702a:	1f 92       	push	r1
    702c:	0f 92       	push	r0
    702e:	0f b6       	in	r0, 0x3f	; 63
    7030:	0f 92       	push	r0
    7032:	08 b6       	in	r0, 0x38	; 56
    7034:	0f 92       	push	r0
    7036:	09 b6       	in	r0, 0x39	; 57
    7038:	0f 92       	push	r0
    703a:	0b b6       	in	r0, 0x3b	; 59
    703c:	0f 92       	push	r0
    703e:	11 24       	eor	r1, r1
    7040:	18 be       	out	0x38, r1	; 56
    7042:	19 be       	out	0x39, r1	; 57
    7044:	1b be       	out	0x3b, r1	; 59
    7046:	2f 93       	push	r18
    7048:	3f 93       	push	r19
    704a:	4f 93       	push	r20
    704c:	5f 93       	push	r21
    704e:	6f 93       	push	r22
    7050:	7f 93       	push	r23
    7052:	8f 93       	push	r24
    7054:	9f 93       	push	r25
    7056:	af 93       	push	r26
    7058:	bf 93       	push	r27
    705a:	ef 93       	push	r30
    705c:	ff 93       	push	r31
    705e:	80 91 e3 2b 	lds	r24, 0x2BE3
    7062:	90 91 e4 2b 	lds	r25, 0x2BE4
    7066:	00 97       	sbiw	r24, 0x00	; 0
    7068:	19 f0       	breq	.+6      	; 0x7070 <__vector_50+0x46>
    706a:	61 e0       	ldi	r22, 0x01	; 1
    706c:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    7070:	ff 91       	pop	r31
    7072:	ef 91       	pop	r30
    7074:	bf 91       	pop	r27
    7076:	af 91       	pop	r26
    7078:	9f 91       	pop	r25
    707a:	8f 91       	pop	r24
    707c:	7f 91       	pop	r23
    707e:	6f 91       	pop	r22
    7080:	5f 91       	pop	r21
    7082:	4f 91       	pop	r20
    7084:	3f 91       	pop	r19
    7086:	2f 91       	pop	r18
    7088:	0f 90       	pop	r0
    708a:	0b be       	out	0x3b, r0	; 59
    708c:	0f 90       	pop	r0
    708e:	09 be       	out	0x39, r0	; 57
    7090:	0f 90       	pop	r0
    7092:	08 be       	out	0x38, r0	; 56
    7094:	0f 90       	pop	r0
    7096:	0f be       	out	0x3f, r0	; 63
    7098:	0f 90       	pop	r0
    709a:	1f 90       	pop	r1
    709c:	18 95       	reti

0000709e <__vector_49>:
    709e:	1f 92       	push	r1
    70a0:	0f 92       	push	r0
    70a2:	0f b6       	in	r0, 0x3f	; 63
    70a4:	0f 92       	push	r0
    70a6:	08 b6       	in	r0, 0x38	; 56
    70a8:	0f 92       	push	r0
    70aa:	09 b6       	in	r0, 0x39	; 57
    70ac:	0f 92       	push	r0
    70ae:	0b b6       	in	r0, 0x3b	; 59
    70b0:	0f 92       	push	r0
    70b2:	11 24       	eor	r1, r1
    70b4:	18 be       	out	0x38, r1	; 56
    70b6:	19 be       	out	0x39, r1	; 57
    70b8:	1b be       	out	0x3b, r1	; 59
    70ba:	2f 93       	push	r18
    70bc:	3f 93       	push	r19
    70be:	4f 93       	push	r20
    70c0:	5f 93       	push	r21
    70c2:	6f 93       	push	r22
    70c4:	7f 93       	push	r23
    70c6:	8f 93       	push	r24
    70c8:	9f 93       	push	r25
    70ca:	af 93       	push	r26
    70cc:	bf 93       	push	r27
    70ce:	ef 93       	push	r30
    70d0:	ff 93       	push	r31
    70d2:	80 91 e3 2b 	lds	r24, 0x2BE3
    70d6:	90 91 e4 2b 	lds	r25, 0x2BE4
    70da:	00 97       	sbiw	r24, 0x00	; 0
    70dc:	19 f0       	breq	.+6      	; 0x70e4 <__vector_49+0x46>
    70de:	60 e0       	ldi	r22, 0x00	; 0
    70e0:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    70e4:	ff 91       	pop	r31
    70e6:	ef 91       	pop	r30
    70e8:	bf 91       	pop	r27
    70ea:	af 91       	pop	r26
    70ec:	9f 91       	pop	r25
    70ee:	8f 91       	pop	r24
    70f0:	7f 91       	pop	r23
    70f2:	6f 91       	pop	r22
    70f4:	5f 91       	pop	r21
    70f6:	4f 91       	pop	r20
    70f8:	3f 91       	pop	r19
    70fa:	2f 91       	pop	r18
    70fc:	0f 90       	pop	r0
    70fe:	0b be       	out	0x3b, r0	; 59
    7100:	0f 90       	pop	r0
    7102:	09 be       	out	0x39, r0	; 57
    7104:	0f 90       	pop	r0
    7106:	08 be       	out	0x38, r0	; 56
    7108:	0f 90       	pop	r0
    710a:	0f be       	out	0x3f, r0	; 63
    710c:	0f 90       	pop	r0
    710e:	1f 90       	pop	r1
    7110:	18 95       	reti

00007112 <__vector_82>:
ISR(tc##_CCD_vect) {\
    if (tc##cp) tc##cp->ccx(3);\
}

TC0_ISR_DEF(TCC0);
TC0_ISR_DEF(TCD0);
    7112:	1f 92       	push	r1
    7114:	0f 92       	push	r0
    7116:	0f b6       	in	r0, 0x3f	; 63
    7118:	0f 92       	push	r0
    711a:	08 b6       	in	r0, 0x38	; 56
    711c:	0f 92       	push	r0
    711e:	09 b6       	in	r0, 0x39	; 57
    7120:	0f 92       	push	r0
    7122:	0b b6       	in	r0, 0x3b	; 59
    7124:	0f 92       	push	r0
    7126:	11 24       	eor	r1, r1
    7128:	18 be       	out	0x38, r1	; 56
    712a:	19 be       	out	0x39, r1	; 57
    712c:	1b be       	out	0x3b, r1	; 59
    712e:	2f 93       	push	r18
    7130:	3f 93       	push	r19
    7132:	4f 93       	push	r20
    7134:	5f 93       	push	r21
    7136:	6f 93       	push	r22
    7138:	7f 93       	push	r23
    713a:	8f 93       	push	r24
    713c:	9f 93       	push	r25
    713e:	af 93       	push	r26
    7140:	bf 93       	push	r27
    7142:	ef 93       	push	r30
    7144:	ff 93       	push	r31
    7146:	80 91 e1 2b 	lds	r24, 0x2BE1
    714a:	90 91 e2 2b 	lds	r25, 0x2BE2
    714e:	00 97       	sbiw	r24, 0x00	; 0
    7150:	19 f0       	breq	.+6      	; 0x7158 <__vector_82+0x46>
    7152:	63 e0       	ldi	r22, 0x03	; 3
    7154:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    7158:	ff 91       	pop	r31
    715a:	ef 91       	pop	r30
    715c:	bf 91       	pop	r27
    715e:	af 91       	pop	r26
    7160:	9f 91       	pop	r25
    7162:	8f 91       	pop	r24
    7164:	7f 91       	pop	r23
    7166:	6f 91       	pop	r22
    7168:	5f 91       	pop	r21
    716a:	4f 91       	pop	r20
    716c:	3f 91       	pop	r19
    716e:	2f 91       	pop	r18
    7170:	0f 90       	pop	r0
    7172:	0b be       	out	0x3b, r0	; 59
    7174:	0f 90       	pop	r0
    7176:	09 be       	out	0x39, r0	; 57
    7178:	0f 90       	pop	r0
    717a:	08 be       	out	0x38, r0	; 56
    717c:	0f 90       	pop	r0
    717e:	0f be       	out	0x3f, r0	; 63
    7180:	0f 90       	pop	r0
    7182:	1f 90       	pop	r1
    7184:	18 95       	reti

00007186 <__vector_81>:
    7186:	1f 92       	push	r1
    7188:	0f 92       	push	r0
    718a:	0f b6       	in	r0, 0x3f	; 63
    718c:	0f 92       	push	r0
    718e:	08 b6       	in	r0, 0x38	; 56
    7190:	0f 92       	push	r0
    7192:	09 b6       	in	r0, 0x39	; 57
    7194:	0f 92       	push	r0
    7196:	0b b6       	in	r0, 0x3b	; 59
    7198:	0f 92       	push	r0
    719a:	11 24       	eor	r1, r1
    719c:	18 be       	out	0x38, r1	; 56
    719e:	19 be       	out	0x39, r1	; 57
    71a0:	1b be       	out	0x3b, r1	; 59
    71a2:	2f 93       	push	r18
    71a4:	3f 93       	push	r19
    71a6:	4f 93       	push	r20
    71a8:	5f 93       	push	r21
    71aa:	6f 93       	push	r22
    71ac:	7f 93       	push	r23
    71ae:	8f 93       	push	r24
    71b0:	9f 93       	push	r25
    71b2:	af 93       	push	r26
    71b4:	bf 93       	push	r27
    71b6:	ef 93       	push	r30
    71b8:	ff 93       	push	r31
    71ba:	80 91 e1 2b 	lds	r24, 0x2BE1
    71be:	90 91 e2 2b 	lds	r25, 0x2BE2
    71c2:	00 97       	sbiw	r24, 0x00	; 0
    71c4:	19 f0       	breq	.+6      	; 0x71cc <__vector_81+0x46>
    71c6:	62 e0       	ldi	r22, 0x02	; 2
    71c8:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    71cc:	ff 91       	pop	r31
    71ce:	ef 91       	pop	r30
    71d0:	bf 91       	pop	r27
    71d2:	af 91       	pop	r26
    71d4:	9f 91       	pop	r25
    71d6:	8f 91       	pop	r24
    71d8:	7f 91       	pop	r23
    71da:	6f 91       	pop	r22
    71dc:	5f 91       	pop	r21
    71de:	4f 91       	pop	r20
    71e0:	3f 91       	pop	r19
    71e2:	2f 91       	pop	r18
    71e4:	0f 90       	pop	r0
    71e6:	0b be       	out	0x3b, r0	; 59
    71e8:	0f 90       	pop	r0
    71ea:	09 be       	out	0x39, r0	; 57
    71ec:	0f 90       	pop	r0
    71ee:	08 be       	out	0x38, r0	; 56
    71f0:	0f 90       	pop	r0
    71f2:	0f be       	out	0x3f, r0	; 63
    71f4:	0f 90       	pop	r0
    71f6:	1f 90       	pop	r1
    71f8:	18 95       	reti

000071fa <__vector_80>:
    71fa:	1f 92       	push	r1
    71fc:	0f 92       	push	r0
    71fe:	0f b6       	in	r0, 0x3f	; 63
    7200:	0f 92       	push	r0
    7202:	08 b6       	in	r0, 0x38	; 56
    7204:	0f 92       	push	r0
    7206:	09 b6       	in	r0, 0x39	; 57
    7208:	0f 92       	push	r0
    720a:	0b b6       	in	r0, 0x3b	; 59
    720c:	0f 92       	push	r0
    720e:	11 24       	eor	r1, r1
    7210:	18 be       	out	0x38, r1	; 56
    7212:	19 be       	out	0x39, r1	; 57
    7214:	1b be       	out	0x3b, r1	; 59
    7216:	2f 93       	push	r18
    7218:	3f 93       	push	r19
    721a:	4f 93       	push	r20
    721c:	5f 93       	push	r21
    721e:	6f 93       	push	r22
    7220:	7f 93       	push	r23
    7222:	8f 93       	push	r24
    7224:	9f 93       	push	r25
    7226:	af 93       	push	r26
    7228:	bf 93       	push	r27
    722a:	ef 93       	push	r30
    722c:	ff 93       	push	r31
    722e:	80 91 e1 2b 	lds	r24, 0x2BE1
    7232:	90 91 e2 2b 	lds	r25, 0x2BE2
    7236:	00 97       	sbiw	r24, 0x00	; 0
    7238:	19 f0       	breq	.+6      	; 0x7240 <__vector_80+0x46>
    723a:	61 e0       	ldi	r22, 0x01	; 1
    723c:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    7240:	ff 91       	pop	r31
    7242:	ef 91       	pop	r30
    7244:	bf 91       	pop	r27
    7246:	af 91       	pop	r26
    7248:	9f 91       	pop	r25
    724a:	8f 91       	pop	r24
    724c:	7f 91       	pop	r23
    724e:	6f 91       	pop	r22
    7250:	5f 91       	pop	r21
    7252:	4f 91       	pop	r20
    7254:	3f 91       	pop	r19
    7256:	2f 91       	pop	r18
    7258:	0f 90       	pop	r0
    725a:	0b be       	out	0x3b, r0	; 59
    725c:	0f 90       	pop	r0
    725e:	09 be       	out	0x39, r0	; 57
    7260:	0f 90       	pop	r0
    7262:	08 be       	out	0x38, r0	; 56
    7264:	0f 90       	pop	r0
    7266:	0f be       	out	0x3f, r0	; 63
    7268:	0f 90       	pop	r0
    726a:	1f 90       	pop	r1
    726c:	18 95       	reti

0000726e <__vector_79>:
    726e:	1f 92       	push	r1
    7270:	0f 92       	push	r0
    7272:	0f b6       	in	r0, 0x3f	; 63
    7274:	0f 92       	push	r0
    7276:	08 b6       	in	r0, 0x38	; 56
    7278:	0f 92       	push	r0
    727a:	09 b6       	in	r0, 0x39	; 57
    727c:	0f 92       	push	r0
    727e:	0b b6       	in	r0, 0x3b	; 59
    7280:	0f 92       	push	r0
    7282:	11 24       	eor	r1, r1
    7284:	18 be       	out	0x38, r1	; 56
    7286:	19 be       	out	0x39, r1	; 57
    7288:	1b be       	out	0x3b, r1	; 59
    728a:	2f 93       	push	r18
    728c:	3f 93       	push	r19
    728e:	4f 93       	push	r20
    7290:	5f 93       	push	r21
    7292:	6f 93       	push	r22
    7294:	7f 93       	push	r23
    7296:	8f 93       	push	r24
    7298:	9f 93       	push	r25
    729a:	af 93       	push	r26
    729c:	bf 93       	push	r27
    729e:	ef 93       	push	r30
    72a0:	ff 93       	push	r31
    72a2:	80 91 e1 2b 	lds	r24, 0x2BE1
    72a6:	90 91 e2 2b 	lds	r25, 0x2BE2
    72aa:	00 97       	sbiw	r24, 0x00	; 0
    72ac:	19 f0       	breq	.+6      	; 0x72b4 <__vector_79+0x46>
    72ae:	60 e0       	ldi	r22, 0x00	; 0
    72b0:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    72b4:	ff 91       	pop	r31
    72b6:	ef 91       	pop	r30
    72b8:	bf 91       	pop	r27
    72ba:	af 91       	pop	r26
    72bc:	9f 91       	pop	r25
    72be:	8f 91       	pop	r24
    72c0:	7f 91       	pop	r23
    72c2:	6f 91       	pop	r22
    72c4:	5f 91       	pop	r21
    72c6:	4f 91       	pop	r20
    72c8:	3f 91       	pop	r19
    72ca:	2f 91       	pop	r18
    72cc:	0f 90       	pop	r0
    72ce:	0b be       	out	0x3b, r0	; 59
    72d0:	0f 90       	pop	r0
    72d2:	09 be       	out	0x39, r0	; 57
    72d4:	0f 90       	pop	r0
    72d6:	08 be       	out	0x38, r0	; 56
    72d8:	0f 90       	pop	r0
    72da:	0f be       	out	0x3f, r0	; 63
    72dc:	0f 90       	pop	r0
    72de:	1f 90       	pop	r1
    72e0:	18 95       	reti

000072e2 <__vector_19>:
}\
ISR(tc##_CCD_vect) {\
    if (tc##cp) tc##cp->ccx(3);\
}

TC0_ISR_DEF(TCC0);
    72e2:	1f 92       	push	r1
    72e4:	0f 92       	push	r0
    72e6:	0f b6       	in	r0, 0x3f	; 63
    72e8:	0f 92       	push	r0
    72ea:	08 b6       	in	r0, 0x38	; 56
    72ec:	0f 92       	push	r0
    72ee:	09 b6       	in	r0, 0x39	; 57
    72f0:	0f 92       	push	r0
    72f2:	0b b6       	in	r0, 0x3b	; 59
    72f4:	0f 92       	push	r0
    72f6:	11 24       	eor	r1, r1
    72f8:	18 be       	out	0x38, r1	; 56
    72fa:	19 be       	out	0x39, r1	; 57
    72fc:	1b be       	out	0x3b, r1	; 59
    72fe:	2f 93       	push	r18
    7300:	3f 93       	push	r19
    7302:	4f 93       	push	r20
    7304:	5f 93       	push	r21
    7306:	6f 93       	push	r22
    7308:	7f 93       	push	r23
    730a:	8f 93       	push	r24
    730c:	9f 93       	push	r25
    730e:	af 93       	push	r26
    7310:	bf 93       	push	r27
    7312:	ef 93       	push	r30
    7314:	ff 93       	push	r31
    7316:	80 91 df 2b 	lds	r24, 0x2BDF
    731a:	90 91 e0 2b 	lds	r25, 0x2BE0
    731e:	00 97       	sbiw	r24, 0x00	; 0
    7320:	19 f0       	breq	.+6      	; 0x7328 <__vector_19+0x46>
    7322:	63 e0       	ldi	r22, 0x03	; 3
    7324:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    7328:	ff 91       	pop	r31
    732a:	ef 91       	pop	r30
    732c:	bf 91       	pop	r27
    732e:	af 91       	pop	r26
    7330:	9f 91       	pop	r25
    7332:	8f 91       	pop	r24
    7334:	7f 91       	pop	r23
    7336:	6f 91       	pop	r22
    7338:	5f 91       	pop	r21
    733a:	4f 91       	pop	r20
    733c:	3f 91       	pop	r19
    733e:	2f 91       	pop	r18
    7340:	0f 90       	pop	r0
    7342:	0b be       	out	0x3b, r0	; 59
    7344:	0f 90       	pop	r0
    7346:	09 be       	out	0x39, r0	; 57
    7348:	0f 90       	pop	r0
    734a:	08 be       	out	0x38, r0	; 56
    734c:	0f 90       	pop	r0
    734e:	0f be       	out	0x3f, r0	; 63
    7350:	0f 90       	pop	r0
    7352:	1f 90       	pop	r1
    7354:	18 95       	reti

00007356 <__vector_18>:
    7356:	1f 92       	push	r1
    7358:	0f 92       	push	r0
    735a:	0f b6       	in	r0, 0x3f	; 63
    735c:	0f 92       	push	r0
    735e:	08 b6       	in	r0, 0x38	; 56
    7360:	0f 92       	push	r0
    7362:	09 b6       	in	r0, 0x39	; 57
    7364:	0f 92       	push	r0
    7366:	0b b6       	in	r0, 0x3b	; 59
    7368:	0f 92       	push	r0
    736a:	11 24       	eor	r1, r1
    736c:	18 be       	out	0x38, r1	; 56
    736e:	19 be       	out	0x39, r1	; 57
    7370:	1b be       	out	0x3b, r1	; 59
    7372:	2f 93       	push	r18
    7374:	3f 93       	push	r19
    7376:	4f 93       	push	r20
    7378:	5f 93       	push	r21
    737a:	6f 93       	push	r22
    737c:	7f 93       	push	r23
    737e:	8f 93       	push	r24
    7380:	9f 93       	push	r25
    7382:	af 93       	push	r26
    7384:	bf 93       	push	r27
    7386:	ef 93       	push	r30
    7388:	ff 93       	push	r31
    738a:	80 91 df 2b 	lds	r24, 0x2BDF
    738e:	90 91 e0 2b 	lds	r25, 0x2BE0
    7392:	00 97       	sbiw	r24, 0x00	; 0
    7394:	19 f0       	breq	.+6      	; 0x739c <__vector_18+0x46>
    7396:	62 e0       	ldi	r22, 0x02	; 2
    7398:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    739c:	ff 91       	pop	r31
    739e:	ef 91       	pop	r30
    73a0:	bf 91       	pop	r27
    73a2:	af 91       	pop	r26
    73a4:	9f 91       	pop	r25
    73a6:	8f 91       	pop	r24
    73a8:	7f 91       	pop	r23
    73aa:	6f 91       	pop	r22
    73ac:	5f 91       	pop	r21
    73ae:	4f 91       	pop	r20
    73b0:	3f 91       	pop	r19
    73b2:	2f 91       	pop	r18
    73b4:	0f 90       	pop	r0
    73b6:	0b be       	out	0x3b, r0	; 59
    73b8:	0f 90       	pop	r0
    73ba:	09 be       	out	0x39, r0	; 57
    73bc:	0f 90       	pop	r0
    73be:	08 be       	out	0x38, r0	; 56
    73c0:	0f 90       	pop	r0
    73c2:	0f be       	out	0x3f, r0	; 63
    73c4:	0f 90       	pop	r0
    73c6:	1f 90       	pop	r1
    73c8:	18 95       	reti

000073ca <__vector_17>:
    73ca:	1f 92       	push	r1
    73cc:	0f 92       	push	r0
    73ce:	0f b6       	in	r0, 0x3f	; 63
    73d0:	0f 92       	push	r0
    73d2:	08 b6       	in	r0, 0x38	; 56
    73d4:	0f 92       	push	r0
    73d6:	09 b6       	in	r0, 0x39	; 57
    73d8:	0f 92       	push	r0
    73da:	0b b6       	in	r0, 0x3b	; 59
    73dc:	0f 92       	push	r0
    73de:	11 24       	eor	r1, r1
    73e0:	18 be       	out	0x38, r1	; 56
    73e2:	19 be       	out	0x39, r1	; 57
    73e4:	1b be       	out	0x3b, r1	; 59
    73e6:	2f 93       	push	r18
    73e8:	3f 93       	push	r19
    73ea:	4f 93       	push	r20
    73ec:	5f 93       	push	r21
    73ee:	6f 93       	push	r22
    73f0:	7f 93       	push	r23
    73f2:	8f 93       	push	r24
    73f4:	9f 93       	push	r25
    73f6:	af 93       	push	r26
    73f8:	bf 93       	push	r27
    73fa:	ef 93       	push	r30
    73fc:	ff 93       	push	r31
    73fe:	80 91 df 2b 	lds	r24, 0x2BDF
    7402:	90 91 e0 2b 	lds	r25, 0x2BE0
    7406:	00 97       	sbiw	r24, 0x00	; 0
    7408:	19 f0       	breq	.+6      	; 0x7410 <__vector_17+0x46>
    740a:	61 e0       	ldi	r22, 0x01	; 1
    740c:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    7410:	ff 91       	pop	r31
    7412:	ef 91       	pop	r30
    7414:	bf 91       	pop	r27
    7416:	af 91       	pop	r26
    7418:	9f 91       	pop	r25
    741a:	8f 91       	pop	r24
    741c:	7f 91       	pop	r23
    741e:	6f 91       	pop	r22
    7420:	5f 91       	pop	r21
    7422:	4f 91       	pop	r20
    7424:	3f 91       	pop	r19
    7426:	2f 91       	pop	r18
    7428:	0f 90       	pop	r0
    742a:	0b be       	out	0x3b, r0	; 59
    742c:	0f 90       	pop	r0
    742e:	09 be       	out	0x39, r0	; 57
    7430:	0f 90       	pop	r0
    7432:	08 be       	out	0x38, r0	; 56
    7434:	0f 90       	pop	r0
    7436:	0f be       	out	0x3f, r0	; 63
    7438:	0f 90       	pop	r0
    743a:	1f 90       	pop	r1
    743c:	18 95       	reti

0000743e <__vector_16>:
    743e:	1f 92       	push	r1
    7440:	0f 92       	push	r0
    7442:	0f b6       	in	r0, 0x3f	; 63
    7444:	0f 92       	push	r0
    7446:	08 b6       	in	r0, 0x38	; 56
    7448:	0f 92       	push	r0
    744a:	09 b6       	in	r0, 0x39	; 57
    744c:	0f 92       	push	r0
    744e:	0b b6       	in	r0, 0x3b	; 59
    7450:	0f 92       	push	r0
    7452:	11 24       	eor	r1, r1
    7454:	18 be       	out	0x38, r1	; 56
    7456:	19 be       	out	0x39, r1	; 57
    7458:	1b be       	out	0x3b, r1	; 59
    745a:	2f 93       	push	r18
    745c:	3f 93       	push	r19
    745e:	4f 93       	push	r20
    7460:	5f 93       	push	r21
    7462:	6f 93       	push	r22
    7464:	7f 93       	push	r23
    7466:	8f 93       	push	r24
    7468:	9f 93       	push	r25
    746a:	af 93       	push	r26
    746c:	bf 93       	push	r27
    746e:	ef 93       	push	r30
    7470:	ff 93       	push	r31
    7472:	80 91 df 2b 	lds	r24, 0x2BDF
    7476:	90 91 e0 2b 	lds	r25, 0x2BE0
    747a:	00 97       	sbiw	r24, 0x00	; 0
    747c:	19 f0       	breq	.+6      	; 0x7484 <__vector_16+0x46>
    747e:	60 e0       	ldi	r22, 0x00	; 0
    7480:	0e 94 31 36 	call	0x6c62	; 0x6c62 <_ZN9TimerCntr3ccxEh>
    7484:	ff 91       	pop	r31
    7486:	ef 91       	pop	r30
    7488:	bf 91       	pop	r27
    748a:	af 91       	pop	r26
    748c:	9f 91       	pop	r25
    748e:	8f 91       	pop	r24
    7490:	7f 91       	pop	r23
    7492:	6f 91       	pop	r22
    7494:	5f 91       	pop	r21
    7496:	4f 91       	pop	r20
    7498:	3f 91       	pop	r19
    749a:	2f 91       	pop	r18
    749c:	0f 90       	pop	r0
    749e:	0b be       	out	0x3b, r0	; 59
    74a0:	0f 90       	pop	r0
    74a2:	09 be       	out	0x39, r0	; 57
    74a4:	0f 90       	pop	r0
    74a6:	08 be       	out	0x38, r0	; 56
    74a8:	0f 90       	pop	r0
    74aa:	0f be       	out	0x3f, r0	; 63
    74ac:	0f 90       	pop	r0
    74ae:	1f 90       	pop	r1
    74b0:	18 95       	reti

000074b2 <_Z10timer_initv>:
     * this is more efficient than just having the first timer
     * increment the second whenever it counts 1000 times? This would
     * require that we do a few more machine instrcutions PER 1ms timer
     * tick.. but this could be kept to a minimum could it not?
     */
    TIMERA.CTRLA    = TC_CLKSEL_DIV8_gc;
    74b2:	e0 e0       	ldi	r30, 0x00	; 0
    74b4:	fb e0       	ldi	r31, 0x0B	; 11
    74b6:	84 e0       	ldi	r24, 0x04	; 4
    74b8:	80 83       	st	Z, r24
    TIMERA.PERBUF   = 4000;
    74ba:	80 ea       	ldi	r24, 0xA0	; 160
    74bc:	9f e0       	ldi	r25, 0x0F	; 15
    74be:	86 ab       	std	Z+54, r24	; 0x36
    74c0:	97 ab       	std	Z+55, r25	; 0x37
    TIMERA.CTRLB    = ( TIMERA.CTRLB & ~TC0_WGMODE_gm ) | TC_WGMODE_NORMAL_gc;
    74c2:	81 81       	ldd	r24, Z+1	; 0x01
    74c4:	88 7f       	andi	r24, 0xF8	; 248
    74c6:	81 83       	std	Z+1, r24	; 0x01
    //      EVSYS.CH0MUX  = EVSYS_CHMUX_TIMERA_OVF_gc;
    TIMERA.INTCTRLA = TC_OVFINTLVL_HI_gc;
    74c8:	23 e0       	ldi	r18, 0x03	; 3
    74ca:	26 83       	std	Z+6, r18	; 0x06
    
    TIMERB.CTRLA    = TC_CLKSEL_EVCH0_gc;
    74cc:	e0 e4       	ldi	r30, 0x40	; 64
    74ce:	fb e0       	ldi	r31, 0x0B	; 11
    74d0:	88 e0       	ldi	r24, 0x08	; 8
    74d2:	80 83       	st	Z, r24
    TIMERB.PERBUF   = 1000;
    74d4:	88 ee       	ldi	r24, 0xE8	; 232
    74d6:	93 e0       	ldi	r25, 0x03	; 3
    74d8:	86 ab       	std	Z+54, r24	; 0x36
    74da:	97 ab       	std	Z+55, r25	; 0x37
    TIMERB.CTRLB    = ( TIMERB.CTRLB & ~TC1_WGMODE_gm ) | TC_WGMODE_NORMAL_gc;
    74dc:	81 81       	ldd	r24, Z+1	; 0x01
    74de:	88 7f       	andi	r24, 0xF8	; 248
    74e0:	81 83       	std	Z+1, r24	; 0x01
    TIMERB.CTRLD    = TC_EVACT_UPDOWN_gc | TC1_EVDLY_bm;
    74e2:	80 e5       	ldi	r24, 0x50	; 80
    74e4:	83 83       	std	Z+3, r24	; 0x03
    TIMERB.INTCTRLA = TC_OVFINTLVL_HI_gc;
    74e6:	26 83       	std	Z+6, r18	; 0x06
}
    74e8:	08 95       	ret

000074ea <__vector_108>:

volatile unsigned long millis_count = 0;
volatile unsigned long seconds_count = 0;

#if defined(TCF1)
ISR(TCF0_OVF_vect)
    74ea:	1f 92       	push	r1
    74ec:	0f 92       	push	r0
    74ee:	0f b6       	in	r0, 0x3f	; 63
    74f0:	0f 92       	push	r0
    74f2:	08 b6       	in	r0, 0x38	; 56
    74f4:	0f 92       	push	r0
    74f6:	09 b6       	in	r0, 0x39	; 57
    74f8:	0f 92       	push	r0
    74fa:	0b b6       	in	r0, 0x3b	; 59
    74fc:	0f 92       	push	r0
    74fe:	11 24       	eor	r1, r1
    7500:	18 be       	out	0x38, r1	; 56
    7502:	19 be       	out	0x39, r1	; 57
    7504:	1b be       	out	0x3b, r1	; 59
    7506:	8f 93       	push	r24
    7508:	9f 93       	push	r25
    750a:	af 93       	push	r26
    750c:	bf 93       	push	r27
    750e:	ef 93       	push	r30
    7510:	ff 93       	push	r31
{
    ++millis_count;
    7512:	80 91 e5 2b 	lds	r24, 0x2BE5
    7516:	90 91 e6 2b 	lds	r25, 0x2BE6
    751a:	a0 91 e7 2b 	lds	r26, 0x2BE7
    751e:	b0 91 e8 2b 	lds	r27, 0x2BE8
    7522:	01 96       	adiw	r24, 0x01	; 1
    7524:	a1 1d       	adc	r26, r1
    7526:	b1 1d       	adc	r27, r1
    7528:	80 93 e5 2b 	sts	0x2BE5, r24
    752c:	90 93 e6 2b 	sts	0x2BE6, r25
    7530:	a0 93 e7 2b 	sts	0x2BE7, r26
    7534:	b0 93 e8 2b 	sts	0x2BE8, r27
    EVSYS.STROBE = 0xF;
    7538:	8f e0       	ldi	r24, 0x0F	; 15
    753a:	e0 e8       	ldi	r30, 0x80	; 128
    753c:	f1 e0       	ldi	r31, 0x01	; 1
    753e:	80 8b       	std	Z+16, r24	; 0x10
}
    7540:	ff 91       	pop	r31
    7542:	ef 91       	pop	r30
    7544:	bf 91       	pop	r27
    7546:	af 91       	pop	r26
    7548:	9f 91       	pop	r25
    754a:	8f 91       	pop	r24
    754c:	0f 90       	pop	r0
    754e:	0b be       	out	0x3b, r0	; 59
    7550:	0f 90       	pop	r0
    7552:	09 be       	out	0x39, r0	; 57
    7554:	0f 90       	pop	r0
    7556:	08 be       	out	0x38, r0	; 56
    7558:	0f 90       	pop	r0
    755a:	0f be       	out	0x3f, r0	; 63
    755c:	0f 90       	pop	r0
    755e:	1f 90       	pop	r1
    7560:	18 95       	reti

00007562 <__vector_114>:

ISR(TCF1_OVF_vect)
    7562:	1f 92       	push	r1
    7564:	0f 92       	push	r0
    7566:	0f b6       	in	r0, 0x3f	; 63
    7568:	0f 92       	push	r0
    756a:	08 b6       	in	r0, 0x38	; 56
    756c:	0f 92       	push	r0
    756e:	09 b6       	in	r0, 0x39	; 57
    7570:	0f 92       	push	r0
    7572:	11 24       	eor	r1, r1
    7574:	18 be       	out	0x38, r1	; 56
    7576:	19 be       	out	0x39, r1	; 57
    7578:	8f 93       	push	r24
    757a:	9f 93       	push	r25
    757c:	af 93       	push	r26
    757e:	bf 93       	push	r27
{
    ++seconds_count;
    7580:	80 91 e9 2b 	lds	r24, 0x2BE9
    7584:	90 91 ea 2b 	lds	r25, 0x2BEA
    7588:	a0 91 eb 2b 	lds	r26, 0x2BEB
    758c:	b0 91 ec 2b 	lds	r27, 0x2BEC
    7590:	01 96       	adiw	r24, 0x01	; 1
    7592:	a1 1d       	adc	r26, r1
    7594:	b1 1d       	adc	r27, r1
    7596:	80 93 e9 2b 	sts	0x2BE9, r24
    759a:	90 93 ea 2b 	sts	0x2BEA, r25
    759e:	a0 93 eb 2b 	sts	0x2BEB, r26
    75a2:	b0 93 ec 2b 	sts	0x2BEC, r27
}
    75a6:	bf 91       	pop	r27
    75a8:	af 91       	pop	r26
    75aa:	9f 91       	pop	r25
    75ac:	8f 91       	pop	r24
    75ae:	0f 90       	pop	r0
    75b0:	09 be       	out	0x39, r0	; 57
    75b2:	0f 90       	pop	r0
    75b4:	08 be       	out	0x38, r0	; 56
    75b6:	0f 90       	pop	r0
    75b8:	0f be       	out	0x3f, r0	; 63
    75ba:	0f 90       	pop	r0
    75bc:	1f 90       	pop	r1
    75be:	18 95       	reti

000075c0 <_Z6millisv>:
{
    ++seconds_count;
}
#endif

unsigned long millis(void)
    75c0:	af 92       	push	r10
    75c2:	bf 92       	push	r11
    75c4:	cf 92       	push	r12
    75c6:	df 92       	push	r13
    75c8:	ef 92       	push	r14
    75ca:	ff 92       	push	r15
    75cc:	0f 93       	push	r16
    75ce:	1f 93       	push	r17
{
    // disable interrupts while we read millis_count or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_count)

    uint8_t oldSREG = SREG; // Save and restore the interrupt enable bit
    75d0:	2f b7       	in	r18, 0x3f	; 63
    cli();
    75d2:	f8 94       	cli
    unsigned long result = seconds_count*1000UL + TIMERB.CNT;
    75d4:	60 91 e9 2b 	lds	r22, 0x2BE9
    75d8:	70 91 ea 2b 	lds	r23, 0x2BEA
    75dc:	80 91 eb 2b 	lds	r24, 0x2BEB
    75e0:	90 91 ec 2b 	lds	r25, 0x2BEC
    75e4:	e0 e4       	ldi	r30, 0x40	; 64
    75e6:	fb e0       	ldi	r31, 0x0B	; 11
    75e8:	e0 a0       	ldd	r14, Z+32	; 0x20
    75ea:	f1 a0       	ldd	r15, Z+33	; 0x21
    SREG = oldSREG;
    75ec:	2f bf       	out	0x3f, r18	; 63

    return result + millis_count;
    75ee:	a0 90 e5 2b 	lds	r10, 0x2BE5
    75f2:	b0 90 e6 2b 	lds	r11, 0x2BE6
    75f6:	c0 90 e7 2b 	lds	r12, 0x2BE7
    75fa:	d0 90 e8 2b 	lds	r13, 0x2BE8
    75fe:	28 ee       	ldi	r18, 0xE8	; 232
    7600:	33 e0       	ldi	r19, 0x03	; 3
    7602:	40 e0       	ldi	r20, 0x00	; 0
    7604:	50 e0       	ldi	r21, 0x00	; 0
    7606:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    760a:	9b 01       	movw	r18, r22
    760c:	ac 01       	movw	r20, r24
    760e:	00 e0       	ldi	r16, 0x00	; 0
    7610:	10 e0       	ldi	r17, 0x00	; 0
    7612:	2e 0d       	add	r18, r14
    7614:	3f 1d       	adc	r19, r15
    7616:	40 1f       	adc	r20, r16
    7618:	51 1f       	adc	r21, r17
    761a:	2a 0d       	add	r18, r10
    761c:	3b 1d       	adc	r19, r11
    761e:	4c 1d       	adc	r20, r12
    7620:	5d 1d       	adc	r21, r13
}
    7622:	b9 01       	movw	r22, r18
    7624:	ca 01       	movw	r24, r20
    7626:	1f 91       	pop	r17
    7628:	0f 91       	pop	r16
    762a:	ff 90       	pop	r15
    762c:	ef 90       	pop	r14
    762e:	df 90       	pop	r13
    7630:	cf 90       	pop	r12
    7632:	bf 90       	pop	r11
    7634:	af 90       	pop	r10
    7636:	08 95       	ret

00007638 <_Z11micros_hugev>:

uint64_t micros_huge(void) {
    7638:	2f 92       	push	r2
    763a:	3f 92       	push	r3
    763c:	4f 92       	push	r4
    763e:	5f 92       	push	r5
    7640:	6f 92       	push	r6
    7642:	7f 92       	push	r7
    7644:	8f 92       	push	r8
    7646:	9f 92       	push	r9
    7648:	af 92       	push	r10
    764a:	bf 92       	push	r11
    764c:	cf 92       	push	r12
    764e:	df 92       	push	r13
    7650:	ef 92       	push	r14
    7652:	ff 92       	push	r15
    7654:	0f 93       	push	r16
    7656:	1f 93       	push	r17
    7658:	df 93       	push	r29
    765a:	cf 93       	push	r28
    765c:	cd b7       	in	r28, 0x3d	; 61
    765e:	de b7       	in	r29, 0x3e	; 62
    7660:	28 97       	sbiw	r28, 0x08	; 8
    7662:	cd bf       	out	0x3d, r28	; 61
    7664:	de bf       	out	0x3e, r29	; 62
    // inconsistent value (e.g. in the middle of a write to rtc_millis)

        // TODO: Will micros and millis be consistent?
        // Are events processed even when interrupts are disabled?
        // If so TIMERB count may be updated even when interrupts are off.
    uint8_t oldSREG = SREG; // Save and restore the interrupt enable bit
    7666:	8f b7       	in	r24, 0x3f	; 63
    cli();
    7668:	f8 94       	cli
    uint64_t result = ((uint64_t)seconds_count)*1000000UL + TIMERB.CNT*1000UL + (TIMERA.CNT>>2);
    766a:	a0 90 e9 2b 	lds	r10, 0x2BE9
    766e:	b0 90 ea 2b 	lds	r11, 0x2BEA
    7672:	c0 90 eb 2b 	lds	r12, 0x2BEB
    7676:	d0 90 ec 2b 	lds	r13, 0x2BEC
    767a:	20 91 60 0b 	lds	r18, 0x0B60
    767e:	30 91 61 0b 	lds	r19, 0x0B61
    7682:	2f 83       	std	Y+7, r18	; 0x07
    7684:	38 87       	std	Y+8, r19	; 0x08
    7686:	20 91 20 0b 	lds	r18, 0x0B20
    768a:	30 91 21 0b 	lds	r19, 0x0B21
    SREG = oldSREG;
    768e:	8f bf       	out	0x3f, r24	; 63
    7690:	36 95       	lsr	r19
    7692:	27 95       	ror	r18
    7694:	36 95       	lsr	r19
    7696:	27 95       	ror	r18
    7698:	19 01       	movw	r2, r18
    769a:	44 24       	eor	r4, r4
    769c:	55 24       	eor	r5, r5
    769e:	66 24       	eor	r6, r6
    76a0:	77 24       	eor	r7, r7
    76a2:	43 01       	movw	r8, r6
    76a4:	95 01       	movw	r18, r10
    76a6:	a6 01       	movw	r20, r12
    76a8:	60 e0       	ldi	r22, 0x00	; 0
    76aa:	70 e0       	ldi	r23, 0x00	; 0
    76ac:	80 e0       	ldi	r24, 0x00	; 0
    76ae:	90 e0       	ldi	r25, 0x00	; 0
    76b0:	a0 e4       	ldi	r26, 0x40	; 64
    76b2:	aa 2e       	mov	r10, r26
    76b4:	f2 e4       	ldi	r31, 0x42	; 66
    76b6:	bf 2e       	mov	r11, r31
    76b8:	ef e0       	ldi	r30, 0x0F	; 15
    76ba:	ce 2e       	mov	r12, r30
    76bc:	dd 24       	eor	r13, r13
    76be:	ee 24       	eor	r14, r14
    76c0:	ff 24       	eor	r15, r15
    76c2:	00 e0       	ldi	r16, 0x00	; 0
    76c4:	10 e0       	ldi	r17, 0x00	; 0
    76c6:	0e 94 2b 41 	call	0x8256	; 0x8256 <__muldi3>
    76ca:	22 0d       	add	r18, r2
    76cc:	2e 83       	std	Y+6, r18	; 0x06
    76ce:	e1 e0       	ldi	r30, 0x01	; 1
    76d0:	22 15       	cp	r18, r2
    76d2:	08 f0       	brcs	.+2      	; 0x76d6 <_Z11micros_hugev+0x9e>
    76d4:	e0 e0       	ldi	r30, 0x00	; 0
    76d6:	33 0d       	add	r19, r3
    76d8:	21 e0       	ldi	r18, 0x01	; 1
    76da:	33 15       	cp	r19, r3
    76dc:	08 f0       	brcs	.+2      	; 0x76e0 <_Z11micros_hugev+0xa8>
    76de:	20 e0       	ldi	r18, 0x00	; 0
    76e0:	e3 0f       	add	r30, r19
    76e2:	e9 83       	std	Y+1, r30	; 0x01
    76e4:	e1 e0       	ldi	r30, 0x01	; 1
    76e6:	a9 81       	ldd	r26, Y+1	; 0x01
    76e8:	a3 17       	cp	r26, r19
    76ea:	08 f0       	brcs	.+2      	; 0x76ee <_Z11micros_hugev+0xb6>
    76ec:	e0 e0       	ldi	r30, 0x00	; 0
    76ee:	2e 2b       	or	r18, r30
    76f0:	31 e0       	ldi	r19, 0x01	; 1
    76f2:	44 15       	cp	r20, r4
    76f4:	08 f0       	brcs	.+2      	; 0x76f8 <_Z11micros_hugev+0xc0>
    76f6:	30 e0       	ldi	r19, 0x00	; 0
    76f8:	24 0f       	add	r18, r20
    76fa:	2a 83       	std	Y+2, r18	; 0x02
    76fc:	21 e0       	ldi	r18, 0x01	; 1
    76fe:	ba 81       	ldd	r27, Y+2	; 0x02
    7700:	b4 17       	cp	r27, r20
    7702:	08 f0       	brcs	.+2      	; 0x7706 <_Z11micros_hugev+0xce>
    7704:	20 e0       	ldi	r18, 0x00	; 0
    7706:	32 2b       	or	r19, r18
    7708:	21 e0       	ldi	r18, 0x01	; 1
    770a:	55 15       	cp	r21, r5
    770c:	08 f0       	brcs	.+2      	; 0x7710 <_Z11micros_hugev+0xd8>
    770e:	20 e0       	ldi	r18, 0x00	; 0
    7710:	35 0f       	add	r19, r21
    7712:	3b 83       	std	Y+3, r19	; 0x03
    7714:	31 e0       	ldi	r19, 0x01	; 1
    7716:	eb 81       	ldd	r30, Y+3	; 0x03
    7718:	e5 17       	cp	r30, r21
    771a:	08 f0       	brcs	.+2      	; 0x771e <_Z11micros_hugev+0xe6>
    771c:	30 e0       	ldi	r19, 0x00	; 0
    771e:	23 2b       	or	r18, r19
    7720:	31 e0       	ldi	r19, 0x01	; 1
    7722:	66 15       	cp	r22, r6
    7724:	08 f0       	brcs	.+2      	; 0x7728 <_Z11micros_hugev+0xf0>
    7726:	30 e0       	ldi	r19, 0x00	; 0
    7728:	26 0f       	add	r18, r22
    772a:	2c 83       	std	Y+4, r18	; 0x04
    772c:	21 e0       	ldi	r18, 0x01	; 1
    772e:	fc 81       	ldd	r31, Y+4	; 0x04
    7730:	f6 17       	cp	r31, r22
    7732:	08 f0       	brcs	.+2      	; 0x7736 <_Z11micros_hugev+0xfe>
    7734:	20 e0       	ldi	r18, 0x00	; 0
    7736:	32 2b       	or	r19, r18
    7738:	21 e0       	ldi	r18, 0x01	; 1
    773a:	77 15       	cp	r23, r7
    773c:	08 f0       	brcs	.+2      	; 0x7740 <_Z11micros_hugev+0x108>
    773e:	20 e0       	ldi	r18, 0x00	; 0
    7740:	37 0f       	add	r19, r23
    7742:	3d 83       	std	Y+5, r19	; 0x05
    7744:	31 e0       	ldi	r19, 0x01	; 1
    7746:	4d 81       	ldd	r20, Y+5	; 0x05
    7748:	47 17       	cp	r20, r23
    774a:	08 f0       	brcs	.+2      	; 0x774e <_Z11micros_hugev+0x116>
    774c:	30 e0       	ldi	r19, 0x00	; 0
    774e:	23 2b       	or	r18, r19
    7750:	31 e0       	ldi	r19, 0x01	; 1
    7752:	88 15       	cp	r24, r8
    7754:	08 f0       	brcs	.+2      	; 0x7758 <_Z11micros_hugev+0x120>
    7756:	30 e0       	ldi	r19, 0x00	; 0
    7758:	92 2e       	mov	r9, r18
    775a:	98 0e       	add	r9, r24
    775c:	21 e0       	ldi	r18, 0x01	; 1
    775e:	98 16       	cp	r9, r24
    7760:	08 f0       	brcs	.+2      	; 0x7764 <_Z11micros_hugev+0x12c>
    7762:	20 e0       	ldi	r18, 0x00	; 0
    7764:	83 2e       	mov	r8, r19
    7766:	82 2a       	or	r8, r18
    7768:	89 0e       	add	r8, r25
    776a:	af 81       	ldd	r26, Y+7	; 0x07
    776c:	b8 85       	ldd	r27, Y+8	; 0x08
    776e:	bd 01       	movw	r22, r26
    7770:	80 e0       	ldi	r24, 0x00	; 0
    7772:	90 e0       	ldi	r25, 0x00	; 0
    7774:	28 ee       	ldi	r18, 0xE8	; 232
    7776:	33 e0       	ldi	r19, 0x03	; 3
    7778:	40 e0       	ldi	r20, 0x00	; 0
    777a:	50 e0       	ldi	r21, 0x00	; 0
    777c:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7780:	5b 01       	movw	r10, r22
    7782:	6c 01       	movw	r12, r24
    7784:	2e 81       	ldd	r18, Y+6	; 0x06
    7786:	26 0f       	add	r18, r22
    7788:	31 e0       	ldi	r19, 0x01	; 1
    778a:	be 81       	ldd	r27, Y+6	; 0x06
    778c:	2b 17       	cp	r18, r27
    778e:	08 f0       	brcs	.+2      	; 0x7792 <_Z11micros_hugev+0x15a>
    7790:	30 e0       	ldi	r19, 0x00	; 0
    7792:	89 81       	ldd	r24, Y+1	; 0x01
    7794:	8b 0d       	add	r24, r11
    7796:	41 e0       	ldi	r20, 0x01	; 1
    7798:	e9 81       	ldd	r30, Y+1	; 0x01
    779a:	8e 17       	cp	r24, r30
    779c:	08 f0       	brcs	.+2      	; 0x77a0 <_Z11micros_hugev+0x168>
    779e:	40 e0       	ldi	r20, 0x00	; 0
    77a0:	38 0f       	add	r19, r24
    77a2:	91 e0       	ldi	r25, 0x01	; 1
    77a4:	38 17       	cp	r19, r24
    77a6:	08 f0       	brcs	.+2      	; 0x77aa <_Z11micros_hugev+0x172>
    77a8:	90 e0       	ldi	r25, 0x00	; 0
    77aa:	49 2b       	or	r20, r25
    77ac:	8a 81       	ldd	r24, Y+2	; 0x02
    77ae:	8c 0d       	add	r24, r12
    77b0:	51 e0       	ldi	r21, 0x01	; 1
    77b2:	fa 81       	ldd	r31, Y+2	; 0x02
    77b4:	8f 17       	cp	r24, r31
    77b6:	08 f0       	brcs	.+2      	; 0x77ba <_Z11micros_hugev+0x182>
    77b8:	50 e0       	ldi	r21, 0x00	; 0
    77ba:	48 0f       	add	r20, r24
    77bc:	91 e0       	ldi	r25, 0x01	; 1
    77be:	48 17       	cp	r20, r24
    77c0:	08 f0       	brcs	.+2      	; 0x77c4 <_Z11micros_hugev+0x18c>
    77c2:	90 e0       	ldi	r25, 0x00	; 0
    77c4:	59 2b       	or	r21, r25
    77c6:	6b 81       	ldd	r22, Y+3	; 0x03
    77c8:	6d 0d       	add	r22, r13
    77ca:	91 e0       	ldi	r25, 0x01	; 1
    77cc:	8b 81       	ldd	r24, Y+3	; 0x03
    77ce:	68 17       	cp	r22, r24
    77d0:	08 f0       	brcs	.+2      	; 0x77d4 <_Z11micros_hugev+0x19c>
    77d2:	90 e0       	ldi	r25, 0x00	; 0
    77d4:	56 0f       	add	r21, r22
    77d6:	81 e0       	ldi	r24, 0x01	; 1
    77d8:	56 17       	cp	r21, r22
    77da:	08 f0       	brcs	.+2      	; 0x77de <_Z11micros_hugev+0x1a6>
    77dc:	80 e0       	ldi	r24, 0x00	; 0
    77de:	69 2f       	mov	r22, r25
    77e0:	68 2b       	or	r22, r24
    77e2:	9c 81       	ldd	r25, Y+4	; 0x04
    77e4:	69 0f       	add	r22, r25
    77e6:	71 e0       	ldi	r23, 0x01	; 1
    77e8:	69 17       	cp	r22, r25
    77ea:	08 f0       	brcs	.+2      	; 0x77ee <_Z11micros_hugev+0x1b6>
    77ec:	70 e0       	ldi	r23, 0x00	; 0
    77ee:	ad 81       	ldd	r26, Y+5	; 0x05
    77f0:	7a 0f       	add	r23, r26
    77f2:	81 e0       	ldi	r24, 0x01	; 1
    77f4:	7a 17       	cp	r23, r26
    77f6:	08 f0       	brcs	.+2      	; 0x77fa <_Z11micros_hugev+0x1c2>
    77f8:	80 e0       	ldi	r24, 0x00	; 0
    77fa:	89 0d       	add	r24, r9
    77fc:	91 e0       	ldi	r25, 0x01	; 1
    77fe:	89 15       	cp	r24, r9
    7800:	08 f0       	brcs	.+2      	; 0x7804 <_Z11micros_hugev+0x1cc>
    7802:	90 e0       	ldi	r25, 0x00	; 0

    return result;
}
    7804:	98 0d       	add	r25, r8
    7806:	28 96       	adiw	r28, 0x08	; 8
    7808:	cd bf       	out	0x3d, r28	; 61
    780a:	de bf       	out	0x3e, r29	; 62
    780c:	cf 91       	pop	r28
    780e:	df 91       	pop	r29
    7810:	1f 91       	pop	r17
    7812:	0f 91       	pop	r16
    7814:	ff 90       	pop	r15
    7816:	ef 90       	pop	r14
    7818:	df 90       	pop	r13
    781a:	cf 90       	pop	r12
    781c:	bf 90       	pop	r11
    781e:	af 90       	pop	r10
    7820:	9f 90       	pop	r9
    7822:	8f 90       	pop	r8
    7824:	7f 90       	pop	r7
    7826:	6f 90       	pop	r6
    7828:	5f 90       	pop	r5
    782a:	4f 90       	pop	r4
    782c:	3f 90       	pop	r3
    782e:	2f 90       	pop	r2
    7830:	08 95       	ret

00007832 <_Z6microsv>:

unsigned long micros(void) {
    7832:	2f 92       	push	r2
    7834:	3f 92       	push	r3
    7836:	4f 92       	push	r4
    7838:	5f 92       	push	r5
    783a:	6f 92       	push	r6
    783c:	7f 92       	push	r7
    783e:	8f 92       	push	r8
    7840:	9f 92       	push	r9
    7842:	af 92       	push	r10
    7844:	bf 92       	push	r11
    7846:	cf 92       	push	r12
    7848:	df 92       	push	r13
    784a:	ef 92       	push	r14
    784c:	ff 92       	push	r15
    784e:	0f 93       	push	r16
    7850:	1f 93       	push	r17
    // inconsistent value (e.g. in the middle of a write to rtc_millis)

        // TODO: Will micros and millis be consistent?
        // Are events processed even when interrupts are disabled?
        // If so TIMERB count may be updated even when interrupts are off.
    uint8_t oldSREG = SREG; // Save and restore the interrupt enable bit
    7852:	2f b7       	in	r18, 0x3f	; 63
    cli();
    7854:	f8 94       	cli
    unsigned long result = seconds_count*1000000UL + millis_count*1000 + TIMERB.CNT*1000UL + (TIMERA.CNT>>2);
    7856:	20 90 e9 2b 	lds	r2, 0x2BE9
    785a:	30 90 ea 2b 	lds	r3, 0x2BEA
    785e:	40 90 eb 2b 	lds	r4, 0x2BEB
    7862:	50 90 ec 2b 	lds	r5, 0x2BEC
    7866:	60 91 e5 2b 	lds	r22, 0x2BE5
    786a:	70 91 e6 2b 	lds	r23, 0x2BE6
    786e:	80 91 e7 2b 	lds	r24, 0x2BE7
    7872:	90 91 e8 2b 	lds	r25, 0x2BE8
    7876:	e0 e4       	ldi	r30, 0x40	; 64
    7878:	fb e0       	ldi	r31, 0x0B	; 11
    787a:	60 a0       	ldd	r6, Z+32	; 0x20
    787c:	71 a0       	ldd	r7, Z+33	; 0x21
    787e:	e0 e0       	ldi	r30, 0x00	; 0
    7880:	fb e0       	ldi	r31, 0x0B	; 11
    7882:	a0 a0       	ldd	r10, Z+32	; 0x20
    7884:	b1 a0       	ldd	r11, Z+33	; 0x21
    SREG = oldSREG;
    7886:	2f bf       	out	0x3f, r18	; 63
    7888:	28 ee       	ldi	r18, 0xE8	; 232
    788a:	33 e0       	ldi	r19, 0x03	; 3
    788c:	40 e0       	ldi	r20, 0x00	; 0
    788e:	50 e0       	ldi	r21, 0x00	; 0
    7890:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7894:	7b 01       	movw	r14, r22
    7896:	8c 01       	movw	r16, r24
    7898:	c2 01       	movw	r24, r4
    789a:	b1 01       	movw	r22, r2
    789c:	20 e4       	ldi	r18, 0x40	; 64
    789e:	32 e4       	ldi	r19, 0x42	; 66
    78a0:	4f e0       	ldi	r20, 0x0F	; 15
    78a2:	50 e0       	ldi	r21, 0x00	; 0
    78a4:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    78a8:	e6 0e       	add	r14, r22
    78aa:	f7 1e       	adc	r15, r23
    78ac:	08 1f       	adc	r16, r24
    78ae:	19 1f       	adc	r17, r25
    78b0:	88 24       	eor	r8, r8
    78b2:	99 24       	eor	r9, r9
    78b4:	c4 01       	movw	r24, r8
    78b6:	b3 01       	movw	r22, r6
    78b8:	28 ee       	ldi	r18, 0xE8	; 232
    78ba:	33 e0       	ldi	r19, 0x03	; 3
    78bc:	40 e0       	ldi	r20, 0x00	; 0
    78be:	50 e0       	ldi	r21, 0x00	; 0
    78c0:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    78c4:	e6 0e       	add	r14, r22
    78c6:	f7 1e       	adc	r15, r23
    78c8:	08 1f       	adc	r16, r24
    78ca:	19 1f       	adc	r17, r25
    78cc:	b6 94       	lsr	r11
    78ce:	a7 94       	ror	r10
    78d0:	b6 94       	lsr	r11
    78d2:	a7 94       	ror	r10
    78d4:	cc 24       	eor	r12, r12
    78d6:	dd 24       	eor	r13, r13
    78d8:	ea 0c       	add	r14, r10
    78da:	fb 1c       	adc	r15, r11
    78dc:	0c 1d       	adc	r16, r12
    78de:	1d 1d       	adc	r17, r13

    return result;
}
    78e0:	b7 01       	movw	r22, r14
    78e2:	c8 01       	movw	r24, r16
    78e4:	1f 91       	pop	r17
    78e6:	0f 91       	pop	r16
    78e8:	ff 90       	pop	r15
    78ea:	ef 90       	pop	r14
    78ec:	df 90       	pop	r13
    78ee:	cf 90       	pop	r12
    78f0:	bf 90       	pop	r11
    78f2:	af 90       	pop	r10
    78f4:	9f 90       	pop	r9
    78f6:	8f 90       	pop	r8
    78f8:	7f 90       	pop	r7
    78fa:	6f 90       	pop	r6
    78fc:	5f 90       	pop	r5
    78fe:	4f 90       	pop	r4
    7900:	3f 90       	pop	r3
    7902:	2f 90       	pop	r2
    7904:	08 95       	ret

00007906 <_Z5delaym>:

void delay(unsigned long ms)
    7906:	2f 92       	push	r2
    7908:	3f 92       	push	r3
    790a:	4f 92       	push	r4
    790c:	5f 92       	push	r5
    790e:	6f 92       	push	r6
    7910:	7f 92       	push	r7
    7912:	8f 92       	push	r8
    7914:	9f 92       	push	r9
    7916:	af 92       	push	r10
    7918:	bf 92       	push	r11
    791a:	cf 92       	push	r12
    791c:	df 92       	push	r13
    791e:	ef 92       	push	r14
    7920:	ff 92       	push	r15
    7922:	0f 93       	push	r16
    7924:	1f 93       	push	r17
    7926:	1b 01       	movw	r2, r22
    7928:	2c 01       	movw	r4, r24
unsigned long millis(void)
{
    // disable interrupts while we read millis_count or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_count)

    uint8_t oldSREG = SREG; // Save and restore the interrupt enable bit
    792a:	ef b7       	in	r30, 0x3f	; 63
    cli();
    792c:	f8 94       	cli
    unsigned long result = seconds_count*1000UL + TIMERB.CNT;
    792e:	60 91 e9 2b 	lds	r22, 0x2BE9
    7932:	70 91 ea 2b 	lds	r23, 0x2BEA
    7936:	80 91 eb 2b 	lds	r24, 0x2BEB
    793a:	90 91 ec 2b 	lds	r25, 0x2BEC
    793e:	20 91 60 0b 	lds	r18, 0x0B60
    7942:	30 91 61 0b 	lds	r19, 0x0B61
    SREG = oldSREG;
    7946:	ef bf       	out	0x3f, r30	; 63

    return result + millis_count;
    7948:	e0 90 e5 2b 	lds	r14, 0x2BE5
    794c:	f0 90 e6 2b 	lds	r15, 0x2BE6
    7950:	00 91 e7 2b 	lds	r16, 0x2BE7
    7954:	10 91 e8 2b 	lds	r17, 0x2BE8
    7958:	40 e0       	ldi	r20, 0x00	; 0
    795a:	50 e0       	ldi	r21, 0x00	; 0
    795c:	66 24       	eor	r6, r6
    795e:	77 24       	eor	r7, r7
    7960:	43 01       	movw	r8, r6
    7962:	62 1a       	sub	r6, r18
    7964:	73 0a       	sbc	r7, r19
    7966:	84 0a       	sbc	r8, r20
    7968:	95 0a       	sbc	r9, r21
    796a:	28 ee       	ldi	r18, 0xE8	; 232
    796c:	33 e0       	ldi	r19, 0x03	; 3
    796e:	40 e0       	ldi	r20, 0x00	; 0
    7970:	50 e0       	ldi	r21, 0x00	; 0
    7972:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7976:	66 1a       	sub	r6, r22
    7978:	77 0a       	sbc	r7, r23
    797a:	88 0a       	sbc	r8, r24
    797c:	99 0a       	sbc	r9, r25
    797e:	6e 18       	sub	r6, r14
    7980:	7f 08       	sbc	r7, r15
    7982:	80 0a       	sbc	r8, r16
    7984:	91 0a       	sbc	r9, r17
unsigned long millis(void)
{
    // disable interrupts while we read millis_count or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_count)

    uint8_t oldSREG = SREG; // Save and restore the interrupt enable bit
    7986:	2f b7       	in	r18, 0x3f	; 63
    cli();
    7988:	f8 94       	cli
    unsigned long result = seconds_count*1000UL + TIMERB.CNT;
    798a:	60 91 e9 2b 	lds	r22, 0x2BE9
    798e:	70 91 ea 2b 	lds	r23, 0x2BEA
    7992:	80 91 eb 2b 	lds	r24, 0x2BEB
    7996:	90 91 ec 2b 	lds	r25, 0x2BEC
    799a:	e0 90 60 0b 	lds	r14, 0x0B60
    799e:	f0 90 61 0b 	lds	r15, 0x0B61
    SREG = oldSREG;
    79a2:	2f bf       	out	0x3f, r18	; 63

    return result + millis_count;
    79a4:	a0 90 e5 2b 	lds	r10, 0x2BE5
    79a8:	b0 90 e6 2b 	lds	r11, 0x2BE6
    79ac:	c0 90 e7 2b 	lds	r12, 0x2BE7
    79b0:	d0 90 e8 2b 	lds	r13, 0x2BE8

void delay(unsigned long ms)
{
    unsigned long start = millis();
    
    while (millis() - start <= ms);
    79b4:	28 ee       	ldi	r18, 0xE8	; 232
    79b6:	33 e0       	ldi	r19, 0x03	; 3
    79b8:	40 e0       	ldi	r20, 0x00	; 0
    79ba:	50 e0       	ldi	r21, 0x00	; 0
    79bc:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    79c0:	00 e0       	ldi	r16, 0x00	; 0
    79c2:	10 e0       	ldi	r17, 0x00	; 0
    79c4:	6e 0d       	add	r22, r14
    79c6:	7f 1d       	adc	r23, r15
    79c8:	80 1f       	adc	r24, r16
    79ca:	91 1f       	adc	r25, r17
    79cc:	6a 0d       	add	r22, r10
    79ce:	7b 1d       	adc	r23, r11
    79d0:	8c 1d       	adc	r24, r12
    79d2:	9d 1d       	adc	r25, r13
    79d4:	66 0d       	add	r22, r6
    79d6:	77 1d       	adc	r23, r7
    79d8:	88 1d       	adc	r24, r8
    79da:	99 1d       	adc	r25, r9
    79dc:	26 16       	cp	r2, r22
    79de:	37 06       	cpc	r3, r23
    79e0:	48 06       	cpc	r4, r24
    79e2:	59 06       	cpc	r5, r25
    79e4:	80 f6       	brcc	.-96     	; 0x7986 <_Z5delaym+0x80>
}
    79e6:	1f 91       	pop	r17
    79e8:	0f 91       	pop	r16
    79ea:	ff 90       	pop	r15
    79ec:	ef 90       	pop	r14
    79ee:	df 90       	pop	r13
    79f0:	cf 90       	pop	r12
    79f2:	bf 90       	pop	r11
    79f4:	af 90       	pop	r10
    79f6:	9f 90       	pop	r9
    79f8:	8f 90       	pop	r8
    79fa:	7f 90       	pop	r7
    79fc:	6f 90       	pop	r6
    79fe:	5f 90       	pop	r5
    7a00:	4f 90       	pop	r4
    7a02:	3f 90       	pop	r3
    7a04:	2f 90       	pop	r2
    7a06:	08 95       	ret

00007a08 <_Z17delayMicrosecondsm>:

/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
void delayMicroseconds(unsigned long us)
    7a08:	af 92       	push	r10
    7a0a:	bf 92       	push	r11
    7a0c:	cf 92       	push	r12
    7a0e:	df 92       	push	r13
    7a10:	ef 92       	push	r14
    7a12:	ff 92       	push	r15
    7a14:	0f 93       	push	r16
    7a16:	1f 93       	push	r17
    7a18:	5b 01       	movw	r10, r22
    7a1a:	6c 01       	movw	r12, r24
{
    unsigned long start = micros();
    7a1c:	0e 94 19 3c 	call	0x7832	; 0x7832 <_Z6microsv>
    7a20:	7b 01       	movw	r14, r22
    7a22:	8c 01       	movw	r16, r24
    
    while (micros() - start <= us);
    7a24:	0e 94 19 3c 	call	0x7832	; 0x7832 <_Z6microsv>
    7a28:	6e 19       	sub	r22, r14
    7a2a:	7f 09       	sbc	r23, r15
    7a2c:	80 0b       	sbc	r24, r16
    7a2e:	91 0b       	sbc	r25, r17
    7a30:	a6 16       	cp	r10, r22
    7a32:	b7 06       	cpc	r11, r23
    7a34:	c8 06       	cpc	r12, r24
    7a36:	d9 06       	cpc	r13, r25
    7a38:	a8 f7       	brcc	.-22     	; 0x7a24 <_Z17delayMicrosecondsm+0x1c>
}
    7a3a:	1f 91       	pop	r17
    7a3c:	0f 91       	pop	r16
    7a3e:	ff 90       	pop	r15
    7a40:	ef 90       	pop	r14
    7a42:	df 90       	pop	r13
    7a44:	cf 90       	pop	r12
    7a46:	bf 90       	pop	r11
    7a48:	af 90       	pop	r10
    7a4a:	08 95       	ret

00007a4c <_Z9breakTimemR12tmElements_t>:
// leap year calulator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+Y)>0) && !((1970+Y)%4) && ( ((1970+Y)%100) || !((1970+Y)%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t time, tmElements_t &tm){
    7a4c:	8f 92       	push	r8
    7a4e:	9f 92       	push	r9
    7a50:	af 92       	push	r10
    7a52:	bf 92       	push	r11
    7a54:	cf 92       	push	r12
    7a56:	df 92       	push	r13
    7a58:	ef 92       	push	r14
    7a5a:	ff 92       	push	r15
    7a5c:	0f 93       	push	r16
    7a5e:	1f 93       	push	r17
    7a60:	cf 93       	push	r28
    7a62:	df 93       	push	r29
    7a64:	7b 01       	movw	r14, r22
    7a66:	8c 01       	movw	r16, r24
    7a68:	ea 01       	movw	r28, r20

  uint8_t year;
  uint8_t month, monthLength;
  unsigned long days;
  
  tm.Second = time % 60;
    7a6a:	2c e3       	ldi	r18, 0x3C	; 60
    7a6c:	30 e0       	ldi	r19, 0x00	; 0
    7a6e:	40 e0       	ldi	r20, 0x00	; 0
    7a70:	50 e0       	ldi	r21, 0x00	; 0
    7a72:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7a76:	68 83       	st	Y, r22
  time /= 60; // now it is minutes
    7a78:	c8 01       	movw	r24, r16
    7a7a:	b7 01       	movw	r22, r14
    7a7c:	2c e3       	ldi	r18, 0x3C	; 60
    7a7e:	30 e0       	ldi	r19, 0x00	; 0
    7a80:	40 e0       	ldi	r20, 0x00	; 0
    7a82:	50 e0       	ldi	r21, 0x00	; 0
    7a84:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7a88:	12 2f       	mov	r17, r18
    7a8a:	03 2f       	mov	r16, r19
    7a8c:	f4 2e       	mov	r15, r20
    7a8e:	e5 2e       	mov	r14, r21
  tm.Minute = time % 60;
    7a90:	62 2f       	mov	r22, r18
    7a92:	73 2f       	mov	r23, r19
    7a94:	84 2f       	mov	r24, r20
    7a96:	95 2f       	mov	r25, r21
    7a98:	2c e3       	ldi	r18, 0x3C	; 60
    7a9a:	30 e0       	ldi	r19, 0x00	; 0
    7a9c:	40 e0       	ldi	r20, 0x00	; 0
    7a9e:	50 e0       	ldi	r21, 0x00	; 0
    7aa0:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7aa4:	69 83       	std	Y+1, r22	; 0x01
  time /= 60; // now it is hours
    7aa6:	61 2f       	mov	r22, r17
    7aa8:	70 2f       	mov	r23, r16
    7aaa:	8f 2d       	mov	r24, r15
    7aac:	9e 2d       	mov	r25, r14
    7aae:	2c e3       	ldi	r18, 0x3C	; 60
    7ab0:	30 e0       	ldi	r19, 0x00	; 0
    7ab2:	40 e0       	ldi	r20, 0x00	; 0
    7ab4:	50 e0       	ldi	r21, 0x00	; 0
    7ab6:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7aba:	12 2f       	mov	r17, r18
    7abc:	03 2f       	mov	r16, r19
    7abe:	f4 2e       	mov	r15, r20
    7ac0:	e5 2e       	mov	r14, r21
  tm.Hour = time % 24;
    7ac2:	62 2f       	mov	r22, r18
    7ac4:	73 2f       	mov	r23, r19
    7ac6:	84 2f       	mov	r24, r20
    7ac8:	95 2f       	mov	r25, r21
    7aca:	28 e1       	ldi	r18, 0x18	; 24
    7acc:	30 e0       	ldi	r19, 0x00	; 0
    7ace:	40 e0       	ldi	r20, 0x00	; 0
    7ad0:	50 e0       	ldi	r21, 0x00	; 0
    7ad2:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7ad6:	6a 83       	std	Y+2, r22	; 0x02
  time /= 24; // now it is days
    7ad8:	61 2f       	mov	r22, r17
    7ada:	70 2f       	mov	r23, r16
    7adc:	8f 2d       	mov	r24, r15
    7ade:	9e 2d       	mov	r25, r14
    7ae0:	28 e1       	ldi	r18, 0x18	; 24
    7ae2:	30 e0       	ldi	r19, 0x00	; 0
    7ae4:	40 e0       	ldi	r20, 0x00	; 0
    7ae6:	50 e0       	ldi	r21, 0x00	; 0
    7ae8:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7aec:	79 01       	movw	r14, r18
    7aee:	8a 01       	movw	r16, r20
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7af0:	c8 01       	movw	r24, r16
    7af2:	b7 01       	movw	r22, r14
    7af4:	6c 5f       	subi	r22, 0xFC	; 252
    7af6:	7f 4f       	sbci	r23, 0xFF	; 255
    7af8:	8f 4f       	sbci	r24, 0xFF	; 255
    7afa:	9f 4f       	sbci	r25, 0xFF	; 255
    7afc:	27 e0       	ldi	r18, 0x07	; 7
    7afe:	30 e0       	ldi	r19, 0x00	; 0
    7b00:	40 e0       	ldi	r20, 0x00	; 0
    7b02:	50 e0       	ldi	r21, 0x00	; 0
    7b04:	0e 94 74 49 	call	0x92e8	; 0x92e8 <__udivmodsi4>
    7b08:	6f 5f       	subi	r22, 0xFF	; 255
    7b0a:	6b 83       	std	Y+3, r22	; 0x03
    7b0c:	20 e0       	ldi	r18, 0x00	; 0
    7b0e:	aa 24       	eor	r10, r10
    7b10:	bb 24       	eor	r11, r11
    7b12:	65 01       	movw	r12, r10
    7b14:	01 c0       	rjmp	.+2      	; 0x7b18 <_Z9breakTimemR12tmElements_t+0xcc>
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
    7b16:	2f 5f       	subi	r18, 0xFF	; 255
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7b18:	82 2e       	mov	r8, r18
    7b1a:	99 24       	eor	r9, r9
    7b1c:	f4 01       	movw	r30, r8
    7b1e:	ee 54       	subi	r30, 0x4E	; 78
    7b20:	f8 4f       	sbci	r31, 0xF8	; 248
    7b22:	cf 01       	movw	r24, r30
    7b24:	83 70       	andi	r24, 0x03	; 3
    7b26:	90 70       	andi	r25, 0x00	; 0
    7b28:	89 2b       	or	r24, r25
    7b2a:	99 f4       	brne	.+38     	; 0x7b52 <_Z9breakTimemR12tmElements_t+0x106>
    7b2c:	cf 01       	movw	r24, r30
    7b2e:	64 e6       	ldi	r22, 0x64	; 100
    7b30:	70 e0       	ldi	r23, 0x00	; 0
    7b32:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7b36:	89 2b       	or	r24, r25
    7b38:	39 f4       	brne	.+14     	; 0x7b48 <_Z9breakTimemR12tmElements_t+0xfc>
    7b3a:	cf 01       	movw	r24, r30
    7b3c:	60 e9       	ldi	r22, 0x90	; 144
    7b3e:	71 e0       	ldi	r23, 0x01	; 1
    7b40:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7b44:	89 2b       	or	r24, r25
    7b46:	29 f4       	brne	.+10     	; 0x7b52 <_Z9breakTimemR12tmElements_t+0x106>
    7b48:	8e e6       	ldi	r24, 0x6E	; 110
    7b4a:	91 e0       	ldi	r25, 0x01	; 1
    7b4c:	a0 e0       	ldi	r26, 0x00	; 0
    7b4e:	b0 e0       	ldi	r27, 0x00	; 0
    7b50:	04 c0       	rjmp	.+8      	; 0x7b5a <_Z9breakTimemR12tmElements_t+0x10e>
    7b52:	8d e6       	ldi	r24, 0x6D	; 109
    7b54:	91 e0       	ldi	r25, 0x01	; 1
    7b56:	a0 e0       	ldi	r26, 0x00	; 0
    7b58:	b0 e0       	ldi	r27, 0x00	; 0
    7b5a:	a8 0e       	add	r10, r24
    7b5c:	b9 1e       	adc	r11, r25
    7b5e:	ca 1e       	adc	r12, r26
    7b60:	db 1e       	adc	r13, r27
    7b62:	c5 01       	movw	r24, r10
    7b64:	a0 e0       	ldi	r26, 0x00	; 0
    7b66:	b0 e0       	ldi	r27, 0x00	; 0
    7b68:	e8 16       	cp	r14, r24
    7b6a:	f9 06       	cpc	r15, r25
    7b6c:	0a 07       	cpc	r16, r26
    7b6e:	1b 07       	cpc	r17, r27
    7b70:	90 f6       	brcc	.-92     	; 0x7b16 <_Z9breakTimemR12tmElements_t+0xca>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    7b72:	2e 83       	std	Y+6, r18	; 0x06
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7b74:	f4 01       	movw	r30, r8
    7b76:	ee 54       	subi	r30, 0x4E	; 78
    7b78:	f8 4f       	sbci	r31, 0xF8	; 248
    7b7a:	83 e0       	ldi	r24, 0x03	; 3
    7b7c:	88 2e       	mov	r8, r24
    7b7e:	91 2c       	mov	r9, r1
    7b80:	8e 22       	and	r8, r30
    7b82:	9f 22       	and	r9, r31
    7b84:	81 14       	cp	r8, r1
    7b86:	91 04       	cpc	r9, r1
    7b88:	99 f4       	brne	.+38     	; 0x7bb0 <_Z9breakTimemR12tmElements_t+0x164>
    7b8a:	cf 01       	movw	r24, r30
    7b8c:	64 e6       	ldi	r22, 0x64	; 100
    7b8e:	70 e0       	ldi	r23, 0x00	; 0
    7b90:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7b94:	89 2b       	or	r24, r25
    7b96:	39 f4       	brne	.+14     	; 0x7ba6 <_Z9breakTimemR12tmElements_t+0x15a>
    7b98:	cf 01       	movw	r24, r30
    7b9a:	60 e9       	ldi	r22, 0x90	; 144
    7b9c:	71 e0       	ldi	r23, 0x01	; 1
    7b9e:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7ba2:	89 2b       	or	r24, r25
    7ba4:	29 f4       	brne	.+10     	; 0x7bb0 <_Z9breakTimemR12tmElements_t+0x164>
    7ba6:	8e e6       	ldi	r24, 0x6E	; 110
    7ba8:	91 e0       	ldi	r25, 0x01	; 1
    7baa:	a0 e0       	ldi	r26, 0x00	; 0
    7bac:	b0 e0       	ldi	r27, 0x00	; 0
    7bae:	04 c0       	rjmp	.+8      	; 0x7bb8 <_Z9breakTimemR12tmElements_t+0x16c>
    7bb0:	8d e6       	ldi	r24, 0x6D	; 109
    7bb2:	91 e0       	ldi	r25, 0x01	; 1
    7bb4:	a0 e0       	ldi	r26, 0x00	; 0
    7bb6:	b0 e0       	ldi	r27, 0x00	; 0
  time  -= days; // now it is days in this year, starting at 0
    7bb8:	a8 1a       	sub	r10, r24
    7bba:	b9 0a       	sbc	r11, r25
    7bbc:	ca 0a       	sbc	r12, r26
    7bbe:	db 0a       	sbc	r13, r27
    7bc0:	98 01       	movw	r18, r16
    7bc2:	87 01       	movw	r16, r14
    7bc4:	0a 19       	sub	r16, r10
    7bc6:	1b 09       	sbc	r17, r11
    7bc8:	2c 09       	sbc	r18, r12
    7bca:	3d 09       	sbc	r19, r13
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7bcc:	cf 01       	movw	r24, r30
    7bce:	64 e6       	ldi	r22, 0x64	; 100
    7bd0:	70 e0       	ldi	r23, 0x00	; 0
    7bd2:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7bd6:	7c 01       	movw	r14, r24
    7bd8:	cf 01       	movw	r24, r30
    7bda:	60 e9       	ldi	r22, 0x90	; 144
    7bdc:	71 e0       	ldi	r23, 0x01	; 1
    7bde:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7be2:	ac 01       	movw	r20, r24
    7be4:	ef e0       	ldi	r30, 0x0F	; 15
    7be6:	f5 e2       	ldi	r31, 0x25	; 37
    7be8:	60 e0       	ldi	r22, 0x00	; 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    7bea:	61 30       	cpi	r22, 0x01	; 1
    7bec:	51 f4       	brne	.+20     	; 0x7c02 <_Z9breakTimemR12tmElements_t+0x1b6>
      if (LEAP_YEAR(year)) {
    7bee:	81 14       	cp	r8, r1
    7bf0:	91 04       	cpc	r9, r1
    7bf2:	49 f4       	brne	.+18     	; 0x7c06 <_Z9breakTimemR12tmElements_t+0x1ba>
    7bf4:	e1 14       	cp	r14, r1
    7bf6:	f1 04       	cpc	r15, r1
    7bf8:	41 f4       	brne	.+16     	; 0x7c0a <_Z9breakTimemR12tmElements_t+0x1be>
    7bfa:	41 15       	cp	r20, r1
    7bfc:	51 05       	cpc	r21, r1
    7bfe:	29 f0       	breq	.+10     	; 0x7c0a <_Z9breakTimemR12tmElements_t+0x1be>
    7c00:	02 c0       	rjmp	.+4      	; 0x7c06 <_Z9breakTimemR12tmElements_t+0x1ba>
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    7c02:	80 81       	ld	r24, Z
    7c04:	03 c0       	rjmp	.+6      	; 0x7c0c <_Z9breakTimemR12tmElements_t+0x1c0>
    7c06:	8c e1       	ldi	r24, 0x1C	; 28
    7c08:	01 c0       	rjmp	.+2      	; 0x7c0c <_Z9breakTimemR12tmElements_t+0x1c0>
    7c0a:	8d e1       	ldi	r24, 0x1D	; 29
    }
    
    if (time >= monthLength) {
    7c0c:	90 e0       	ldi	r25, 0x00	; 0
    7c0e:	a0 e0       	ldi	r26, 0x00	; 0
    7c10:	b0 e0       	ldi	r27, 0x00	; 0
    7c12:	08 17       	cp	r16, r24
    7c14:	19 07       	cpc	r17, r25
    7c16:	2a 07       	cpc	r18, r26
    7c18:	3b 07       	cpc	r19, r27
    7c1a:	40 f0       	brcs	.+16     	; 0x7c2c <_Z9breakTimemR12tmElements_t+0x1e0>
      time -= monthLength;
    7c1c:	08 1b       	sub	r16, r24
    7c1e:	19 0b       	sbc	r17, r25
    7c20:	2a 0b       	sbc	r18, r26
    7c22:	3b 0b       	sbc	r19, r27
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7c24:	6f 5f       	subi	r22, 0xFF	; 255
    7c26:	31 96       	adiw	r30, 0x01	; 1
    7c28:	6c 30       	cpi	r22, 0x0C	; 12
    7c2a:	f9 f6       	brne	.-66     	; 0x7bea <_Z9breakTimemR12tmElements_t+0x19e>
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    7c2c:	6f 5f       	subi	r22, 0xFF	; 255
    7c2e:	6d 83       	std	Y+5, r22	; 0x05
  tm.Day = time + 1;     // day of month
    7c30:	80 2f       	mov	r24, r16
    7c32:	8f 5f       	subi	r24, 0xFF	; 255
    7c34:	8c 83       	std	Y+4, r24	; 0x04
}
    7c36:	df 91       	pop	r29
    7c38:	cf 91       	pop	r28
    7c3a:	1f 91       	pop	r17
    7c3c:	0f 91       	pop	r16
    7c3e:	ff 90       	pop	r15
    7c40:	ef 90       	pop	r14
    7c42:	df 90       	pop	r13
    7c44:	cf 90       	pop	r12
    7c46:	bf 90       	pop	r11
    7c48:	af 90       	pop	r10
    7c4a:	9f 90       	pop	r9
    7c4c:	8f 90       	pop	r8
    7c4e:	08 95       	ret

00007c50 <_Z12refreshCachem>:
static time_t       cacheTime;   // the time the cache was updated
static time_t       syncInterval = 300;  // time sync will be attempted after this many seconds

static int          millisPerSecond = 1000;

void refreshCache( time_t t){
    7c50:	ef 92       	push	r14
    7c52:	ff 92       	push	r15
    7c54:	0f 93       	push	r16
    7c56:	1f 93       	push	r17
    7c58:	7b 01       	movw	r14, r22
    7c5a:	8c 01       	movw	r16, r24
  if( t != cacheTime)
    7c5c:	80 91 03 2c 	lds	r24, 0x2C03
    7c60:	90 91 04 2c 	lds	r25, 0x2C04
    7c64:	a0 91 05 2c 	lds	r26, 0x2C05
    7c68:	b0 91 06 2c 	lds	r27, 0x2C06
    7c6c:	e8 16       	cp	r14, r24
    7c6e:	f9 06       	cpc	r15, r25
    7c70:	0a 07       	cpc	r16, r26
    7c72:	1b 07       	cpc	r17, r27
    7c74:	71 f0       	breq	.+28     	; 0x7c92 <_Z12refreshCachem+0x42>
  {
    breakTime(t, tm); 
    7c76:	c8 01       	movw	r24, r16
    7c78:	b7 01       	movw	r22, r14
    7c7a:	48 ef       	ldi	r20, 0xF8	; 248
    7c7c:	5b e2       	ldi	r21, 0x2B	; 43
    7c7e:	0e 94 26 3d 	call	0x7a4c	; 0x7a4c <_Z9breakTimemR12tmElements_t>
    cacheTime = t; 
    7c82:	e0 92 03 2c 	sts	0x2C03, r14
    7c86:	f0 92 04 2c 	sts	0x2C04, r15
    7c8a:	00 93 05 2c 	sts	0x2C05, r16
    7c8e:	10 93 06 2c 	sts	0x2C06, r17
  }
}
    7c92:	1f 91       	pop	r17
    7c94:	0f 91       	pop	r16
    7c96:	ff 90       	pop	r15
    7c98:	ef 90       	pop	r14
    7c9a:	08 95       	ret

00007c9c <_Z4yearm>:
int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
    7c9c:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
    7ca0:	20 91 fe 2b 	lds	r18, 0x2BFE
    7ca4:	30 e0       	ldi	r19, 0x00	; 0
    7ca6:	2e 54       	subi	r18, 0x4E	; 78
    7ca8:	38 4f       	sbci	r19, 0xF8	; 248
  return tmYearToCalendar(tm.Year);
}
    7caa:	c9 01       	movw	r24, r18
    7cac:	08 95       	ret

00007cae <_Z5monthm>:
int month(){
  return month(now()); 
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
    7cae:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Month;
}
    7cb2:	80 91 fd 2b 	lds	r24, 0x2BFD
    7cb6:	90 e0       	ldi	r25, 0x00	; 0
    7cb8:	08 95       	ret

00007cba <_Z7weekdaym>:
int weekday() {   // Sunday is day 1
  return  weekday(now()); 
}

int weekday(time_t t) {
  refreshCache(t);
    7cba:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Wday;
}
    7cbe:	80 91 fb 2b 	lds	r24, 0x2BFB
    7cc2:	90 e0       	ldi	r25, 0x00	; 0
    7cc4:	08 95       	ret

00007cc6 <_Z3daym>:
int day(){
  return(day(now())); 
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
    7cc6:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Day;
}
    7cca:	80 91 fc 2b 	lds	r24, 0x2BFC
    7cce:	90 e0       	ldi	r25, 0x00	; 0
    7cd0:	08 95       	ret

00007cd2 <_Z6secondm>:
int second() {
  return second(now()); 
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
    7cd2:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Second;
}
    7cd6:	80 91 f8 2b 	lds	r24, 0x2BF8
    7cda:	90 e0       	ldi	r25, 0x00	; 0
    7cdc:	08 95       	ret

00007cde <_Z6minutem>:
int minute() {
  return minute(now()); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
    7cde:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Minute;  
}
    7ce2:	80 91 f9 2b 	lds	r24, 0x2BF9
    7ce6:	90 e0       	ldi	r25, 0x00	; 0
    7ce8:	08 95       	ret

00007cea <_Z12hourFormat12m>:
int hourFormat12() { // the hour now in 12 hour format
  return hourFormat12(now()); 
}

int hourFormat12(time_t t) { // the hour for the given time in 12 hour format
  refreshCache(t);
    7cea:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  if( tm.Hour == 0 )
    7cee:	20 91 fa 2b 	lds	r18, 0x2BFA
    7cf2:	22 23       	and	r18, r18
    7cf4:	19 f4       	brne	.+6      	; 0x7cfc <_Z12hourFormat12m+0x12>
    7cf6:	2c e0       	ldi	r18, 0x0C	; 12
    7cf8:	30 e0       	ldi	r19, 0x00	; 0
    7cfa:	09 c0       	rjmp	.+18     	; 0x7d0e <_Z12hourFormat12m+0x24>
    7cfc:	82 2f       	mov	r24, r18
    7cfe:	90 e0       	ldi	r25, 0x00	; 0
    return 12; // 12 midnight
  else if( tm.Hour  > 12)
    7d00:	2d 30       	cpi	r18, 0x0D	; 13
    7d02:	20 f0       	brcs	.+8      	; 0x7d0c <_Z12hourFormat12m+0x22>
    return tm.Hour - 12 ;
    7d04:	9c 01       	movw	r18, r24
    7d06:	2c 50       	subi	r18, 0x0C	; 12
    7d08:	30 40       	sbci	r19, 0x00	; 0
    7d0a:	01 c0       	rjmp	.+2      	; 0x7d0e <_Z12hourFormat12m+0x24>
  else
    return tm.Hour ;
    7d0c:	9c 01       	movw	r18, r24
}
    7d0e:	c9 01       	movw	r24, r18
    7d10:	08 95       	ret

00007d12 <_Z4hourm>:
int hour() { // the hour now 
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
    7d12:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Hour;  
}
    7d16:	80 91 fa 2b 	lds	r24, 0x2BFA
    7d1a:	90 e0       	ldi	r25, 0x00	; 0
    7d1c:	08 95       	ret

00007d1e <_Z4isPMm>:
int hour() { // the hour now 
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
    7d1e:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
    7d22:	20 e0       	ldi	r18, 0x00	; 0
    7d24:	80 91 fa 2b 	lds	r24, 0x2BFA
    7d28:	90 e0       	ldi	r25, 0x00	; 0
    7d2a:	0c 97       	sbiw	r24, 0x0c	; 12
    7d2c:	0c f0       	brlt	.+2      	; 0x7d30 <_Z4isPMm+0x12>
    7d2e:	21 e0       	ldi	r18, 0x01	; 1
  return isPM(now()); 
}

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}
    7d30:	82 2f       	mov	r24, r18
    7d32:	08 95       	ret

00007d34 <_Z4isAMm>:
uint8_t isAM() { // returns true if time now is AM
  return !isPM(now()); 
}

uint8_t isAM(time_t t) { // returns true if given time is AM
  return !isPM(t);  
    7d34:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <_Z4isPMm>
    7d38:	90 e0       	ldi	r25, 0x00	; 0
    7d3a:	88 23       	and	r24, r24
    7d3c:	09 f4       	brne	.+2      	; 0x7d40 <_Z4isAMm+0xc>
    7d3e:	91 e0       	ldi	r25, 0x01	; 1
}
    7d40:	89 2f       	mov	r24, r25
    7d42:	08 95       	ret

00007d44 <_Z8makeTimeR12tmElements_t>:
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
}

time_t makeTime(tmElements_t &tm){   
    7d44:	4f 92       	push	r4
    7d46:	5f 92       	push	r5
    7d48:	6f 92       	push	r6
    7d4a:	7f 92       	push	r7
    7d4c:	8f 92       	push	r8
    7d4e:	9f 92       	push	r9
    7d50:	af 92       	push	r10
    7d52:	bf 92       	push	r11
    7d54:	cf 92       	push	r12
    7d56:	df 92       	push	r13
    7d58:	ef 92       	push	r14
    7d5a:	ff 92       	push	r15
    7d5c:	0f 93       	push	r16
    7d5e:	1f 93       	push	r17
    7d60:	cf 93       	push	r28
    7d62:	df 93       	push	r29
    7d64:	4c 01       	movw	r8, r24
  
  int i;
  time_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    7d66:	dc 01       	movw	r26, r24
    7d68:	16 96       	adiw	r26, 0x06	; 6
    7d6a:	1c 91       	ld	r17, X
    7d6c:	61 2f       	mov	r22, r17
    7d6e:	70 e0       	ldi	r23, 0x00	; 0
    7d70:	80 e0       	ldi	r24, 0x00	; 0
    7d72:	90 e0       	ldi	r25, 0x00	; 0
    7d74:	20 e8       	ldi	r18, 0x80	; 128
    7d76:	33 e3       	ldi	r19, 0x33	; 51
    7d78:	41 ee       	ldi	r20, 0xE1	; 225
    7d7a:	51 e0       	ldi	r21, 0x01	; 1
    7d7c:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7d80:	5b 01       	movw	r10, r22
    7d82:	6c 01       	movw	r12, r24
    7d84:	22 eb       	ldi	r18, 0xB2	; 178
    7d86:	37 e0       	ldi	r19, 0x07	; 7
  for (i = 0; i < tm.Year; i++) {
    7d88:	e1 2f       	mov	r30, r17
    7d8a:	f0 e0       	ldi	r31, 0x00	; 0
    7d8c:	ee 54       	subi	r30, 0x4E	; 78
    7d8e:	f8 4f       	sbci	r31, 0xF8	; 248
    7d90:	1d c0       	rjmp	.+58     	; 0x7dcc <_Z8makeTimeR12tmElements_t+0x88>
    if (LEAP_YEAR(i)) {
    7d92:	c9 01       	movw	r24, r18
    7d94:	83 70       	andi	r24, 0x03	; 3
    7d96:	90 70       	andi	r25, 0x00	; 0
    7d98:	89 2b       	or	r24, r25
    7d9a:	b1 f4       	brne	.+44     	; 0x7dc8 <_Z8makeTimeR12tmElements_t+0x84>
    7d9c:	c9 01       	movw	r24, r18
    7d9e:	64 e6       	ldi	r22, 0x64	; 100
    7da0:	70 e0       	ldi	r23, 0x00	; 0
    7da2:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7da6:	89 2b       	or	r24, r25
    7da8:	39 f4       	brne	.+14     	; 0x7db8 <_Z8makeTimeR12tmElements_t+0x74>
    7daa:	c9 01       	movw	r24, r18
    7dac:	60 e9       	ldi	r22, 0x90	; 144
    7dae:	71 e0       	ldi	r23, 0x01	; 1
    7db0:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7db4:	89 2b       	or	r24, r25
    7db6:	41 f4       	brne	.+16     	; 0x7dc8 <_Z8makeTimeR12tmElements_t+0x84>
      seconds +=  SECS_PER_DAY;   // add extra days for leap years
    7db8:	80 e8       	ldi	r24, 0x80	; 128
    7dba:	91 e5       	ldi	r25, 0x51	; 81
    7dbc:	a1 e0       	ldi	r26, 0x01	; 1
    7dbe:	b0 e0       	ldi	r27, 0x00	; 0
    7dc0:	a8 0e       	add	r10, r24
    7dc2:	b9 1e       	adc	r11, r25
    7dc4:	ca 1e       	adc	r12, r26
    7dc6:	db 1e       	adc	r13, r27
    7dc8:	2f 5f       	subi	r18, 0xFF	; 255
    7dca:	3f 4f       	sbci	r19, 0xFF	; 255
  int i;
  time_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    7dcc:	2e 17       	cp	r18, r30
    7dce:	3f 07       	cpc	r19, r31
    7dd0:	01 f7       	brne	.-64     	; 0x7d92 <_Z8makeTimeR12tmElements_t+0x4e>
      seconds +=  SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    7dd2:	d4 01       	movw	r26, r8
    7dd4:	15 96       	adiw	r26, 0x05	; 5
    7dd6:	8c 91       	ld	r24, X
    7dd8:	48 2e       	mov	r4, r24
    7dda:	55 24       	eor	r5, r5
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    7ddc:	c9 01       	movw	r24, r18
    7dde:	64 e6       	ldi	r22, 0x64	; 100
    7de0:	70 e0       	ldi	r23, 0x00	; 0
    7de2:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7de6:	7c 01       	movw	r14, r24
    7de8:	c9 01       	movw	r24, r18
    7dea:	60 e9       	ldi	r22, 0x90	; 144
    7dec:	71 e0       	ldi	r23, 0x01	; 1
    7dee:	0e 94 61 49 	call	0x92c2	; 0x92c2 <__divmodhi4>
    7df2:	8c 01       	movw	r16, r24
    7df4:	c1 e0       	ldi	r28, 0x01	; 1
    7df6:	d0 e0       	ldi	r29, 0x00	; 0
    7df8:	93 e0       	ldi	r25, 0x03	; 3
    7dfa:	69 2e       	mov	r6, r25
    7dfc:	71 2c       	mov	r7, r1
    7dfe:	62 22       	and	r6, r18
    7e00:	73 22       	and	r7, r19
    7e02:	27 c0       	rjmp	.+78     	; 0x7e52 <_Z8makeTimeR12tmElements_t+0x10e>
    7e04:	c2 30       	cpi	r28, 0x02	; 2
    7e06:	d1 05       	cpc	r29, r1
    7e08:	91 f4       	brne	.+36     	; 0x7e2e <_Z8makeTimeR12tmElements_t+0xea>
    7e0a:	61 14       	cp	r6, r1
    7e0c:	71 04       	cpc	r7, r1
    7e0e:	79 f4       	brne	.+30     	; 0x7e2e <_Z8makeTimeR12tmElements_t+0xea>
    7e10:	e1 14       	cp	r14, r1
    7e12:	f1 04       	cpc	r15, r1
    7e14:	19 f4       	brne	.+6      	; 0x7e1c <_Z8makeTimeR12tmElements_t+0xd8>
    7e16:	01 15       	cp	r16, r1
    7e18:	11 05       	cpc	r17, r1
    7e1a:	49 f4       	brne	.+18     	; 0x7e2e <_Z8makeTimeR12tmElements_t+0xea>
      seconds += SECS_PER_DAY * 29;
    7e1c:	80 e8       	ldi	r24, 0x80	; 128
    7e1e:	9b e3       	ldi	r25, 0x3B	; 59
    7e20:	a6 e2       	ldi	r26, 0x26	; 38
    7e22:	b0 e0       	ldi	r27, 0x00	; 0
    7e24:	a8 0e       	add	r10, r24
    7e26:	b9 1e       	adc	r11, r25
    7e28:	ca 1e       	adc	r12, r26
    7e2a:	db 1e       	adc	r13, r27
    7e2c:	11 c0       	rjmp	.+34     	; 0x7e50 <_Z8makeTimeR12tmElements_t+0x10c>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    7e2e:	fe 01       	movw	r30, r28
    7e30:	e2 5f       	subi	r30, 0xF2	; 242
    7e32:	fa 4d       	sbci	r31, 0xDA	; 218
    7e34:	60 81       	ld	r22, Z
    7e36:	70 e0       	ldi	r23, 0x00	; 0
    7e38:	80 e0       	ldi	r24, 0x00	; 0
    7e3a:	90 e0       	ldi	r25, 0x00	; 0
    7e3c:	20 e8       	ldi	r18, 0x80	; 128
    7e3e:	31 e5       	ldi	r19, 0x51	; 81
    7e40:	41 e0       	ldi	r20, 0x01	; 1
    7e42:	50 e0       	ldi	r21, 0x00	; 0
    7e44:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7e48:	a6 0e       	add	r10, r22
    7e4a:	b7 1e       	adc	r11, r23
    7e4c:	c8 1e       	adc	r12, r24
    7e4e:	d9 1e       	adc	r13, r25
      seconds +=  SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    7e50:	21 96       	adiw	r28, 0x01	; 1
    7e52:	c4 15       	cp	r28, r4
    7e54:	d5 05       	cpc	r29, r5
    7e56:	b4 f2       	brlt	.-84     	; 0x7e04 <_Z8makeTimeR12tmElements_t+0xc0>
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    }
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
    7e58:	d4 01       	movw	r26, r8
    7e5a:	12 96       	adiw	r26, 0x02	; 2
    7e5c:	6c 91       	ld	r22, X
    7e5e:	70 e0       	ldi	r23, 0x00	; 0
    7e60:	80 e0       	ldi	r24, 0x00	; 0
    7e62:	90 e0       	ldi	r25, 0x00	; 0
    7e64:	20 e1       	ldi	r18, 0x10	; 16
    7e66:	3e e0       	ldi	r19, 0x0E	; 14
    7e68:	40 e0       	ldi	r20, 0x00	; 0
    7e6a:	50 e0       	ldi	r21, 0x00	; 0
    7e6c:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7e70:	7b 01       	movw	r14, r22
    7e72:	8c 01       	movw	r16, r24
    7e74:	f4 01       	movw	r30, r8
    7e76:	61 81       	ldd	r22, Z+1	; 0x01
    7e78:	70 e0       	ldi	r23, 0x00	; 0
    7e7a:	80 e0       	ldi	r24, 0x00	; 0
    7e7c:	90 e0       	ldi	r25, 0x00	; 0
    7e7e:	2c e3       	ldi	r18, 0x3C	; 60
    7e80:	30 e0       	ldi	r19, 0x00	; 0
    7e82:	40 e0       	ldi	r20, 0x00	; 0
    7e84:	50 e0       	ldi	r21, 0x00	; 0
    7e86:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7e8a:	e6 0e       	add	r14, r22
    7e8c:	f7 1e       	adc	r15, r23
    7e8e:	08 1f       	adc	r16, r24
    7e90:	19 1f       	adc	r17, r25
  seconds+= tm.Hour * SECS_PER_HOUR;
    7e92:	d4 01       	movw	r26, r8
    7e94:	8c 91       	ld	r24, X
    7e96:	e8 0e       	add	r14, r24
    7e98:	f1 1c       	adc	r15, r1
    7e9a:	01 1d       	adc	r16, r1
    7e9c:	11 1d       	adc	r17, r1
  seconds+= tm.Minute * SECS_PER_MIN;
    7e9e:	14 96       	adiw	r26, 0x04	; 4
    7ea0:	6c 91       	ld	r22, X
    7ea2:	70 e0       	ldi	r23, 0x00	; 0
    7ea4:	61 50       	subi	r22, 0x01	; 1
    7ea6:	70 40       	sbci	r23, 0x00	; 0
    7ea8:	88 27       	eor	r24, r24
    7eaa:	77 fd       	sbrc	r23, 7
    7eac:	80 95       	com	r24
    7eae:	98 2f       	mov	r25, r24
    7eb0:	20 e8       	ldi	r18, 0x80	; 128
    7eb2:	31 e5       	ldi	r19, 0x51	; 81
    7eb4:	41 e0       	ldi	r20, 0x01	; 1
    7eb6:	50 e0       	ldi	r21, 0x00	; 0
    7eb8:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    7ebc:	e6 0e       	add	r14, r22
    7ebe:	f7 1e       	adc	r15, r23
    7ec0:	08 1f       	adc	r16, r24
    7ec2:	19 1f       	adc	r17, r25
    7ec4:	ea 0c       	add	r14, r10
    7ec6:	fb 1c       	adc	r15, r11
    7ec8:	0c 1d       	adc	r16, r12
    7eca:	1d 1d       	adc	r17, r13
  seconds+= tm.Second;
  return seconds; 
}
    7ecc:	b7 01       	movw	r22, r14
    7ece:	c8 01       	movw	r24, r16
    7ed0:	df 91       	pop	r29
    7ed2:	cf 91       	pop	r28
    7ed4:	1f 91       	pop	r17
    7ed6:	0f 91       	pop	r16
    7ed8:	ff 90       	pop	r15
    7eda:	ef 90       	pop	r14
    7edc:	df 90       	pop	r13
    7ede:	cf 90       	pop	r12
    7ee0:	bf 90       	pop	r11
    7ee2:	af 90       	pop	r10
    7ee4:	9f 90       	pop	r9
    7ee6:	8f 90       	pop	r8
    7ee8:	7f 90       	pop	r7
    7eea:	6f 90       	pop	r6
    7eec:	5f 90       	pop	r5
    7eee:	4f 90       	pop	r4
    7ef0:	08 95       	ret

00007ef2 <_Z10adjustTimel>:
  tm.Second = sec;
  setTime(makeTime(tm));
}

void adjustTime(long adjustment){
  sysTime += adjustment;
    7ef2:	20 91 ef 2b 	lds	r18, 0x2BEF
    7ef6:	30 91 f0 2b 	lds	r19, 0x2BF0
    7efa:	40 91 f1 2b 	lds	r20, 0x2BF1
    7efe:	50 91 f2 2b 	lds	r21, 0x2BF2
    7f02:	26 0f       	add	r18, r22
    7f04:	37 1f       	adc	r19, r23
    7f06:	48 1f       	adc	r20, r24
    7f08:	59 1f       	adc	r21, r25
    7f0a:	20 93 ef 2b 	sts	0x2BEF, r18
    7f0e:	30 93 f0 2b 	sts	0x2BF0, r19
    7f12:	40 93 f1 2b 	sts	0x2BF1, r20
    7f16:	50 93 f2 2b 	sts	0x2BF2, r21
}
    7f1a:	08 95       	ret

00007f1c <_Z10timeStatusv>:

timeStatus_t timeStatus(){ // indicates if time has been set and recently synchronized
  return Status;
}
    7f1c:	80 91 f7 2b 	lds	r24, 0x2BF7
    7f20:	08 95       	ret

00007f22 <_Z15setSyncIntervalm>:
  nextSyncTime = sysTime;
  now(); // this will sync the clock
}

void setSyncInterval(time_t interval){ // set the number of seconds between re-sync
  syncInterval = interval;
    7f22:	60 93 0b 25 	sts	0x250B, r22
    7f26:	70 93 0c 25 	sts	0x250C, r23
    7f2a:	80 93 0d 25 	sts	0x250D, r24
    7f2e:	90 93 0e 25 	sts	0x250E, r25
}
    7f32:	08 95       	ret

00007f34 <_Z7setTimem>:
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = t;  
    7f34:	60 93 ef 2b 	sts	0x2BEF, r22
    7f38:	70 93 f0 2b 	sts	0x2BF0, r23
    7f3c:	80 93 f1 2b 	sts	0x2BF1, r24
    7f40:	90 93 f2 2b 	sts	0x2BF2, r25
  nextSyncTime = t + syncInterval;
    7f44:	20 91 0b 25 	lds	r18, 0x250B
    7f48:	30 91 0c 25 	lds	r19, 0x250C
    7f4c:	40 91 0d 25 	lds	r20, 0x250D
    7f50:	50 91 0e 25 	lds	r21, 0x250E
    7f54:	26 0f       	add	r18, r22
    7f56:	37 1f       	adc	r19, r23
    7f58:	48 1f       	adc	r20, r24
    7f5a:	59 1f       	adc	r21, r25
    7f5c:	20 93 f3 2b 	sts	0x2BF3, r18
    7f60:	30 93 f4 2b 	sts	0x2BF4, r19
    7f64:	40 93 f5 2b 	sts	0x2BF5, r20
    7f68:	50 93 f6 2b 	sts	0x2BF6, r21
  Status = timeSet; 
    7f6c:	82 e0       	ldi	r24, 0x02	; 2
    7f6e:	80 93 f7 2b 	sts	0x2BF7, r24
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    7f72:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    7f76:	60 93 ff 2b 	sts	0x2BFF, r22
    7f7a:	70 93 00 2c 	sts	0x2C00, r23
    7f7e:	80 93 01 2c 	sts	0x2C01, r24
    7f82:	90 93 02 2c 	sts	0x2C02, r25
} 
    7f86:	08 95       	ret

00007f88 <_Z7setTimeiiiiii>:

void  setTime(int hr,int min,int sec,int dy, int mnth, int yr){
    7f88:	ef 92       	push	r14
    7f8a:	ff 92       	push	r15
    7f8c:	0f 93       	push	r16
    7f8e:	f7 01       	movw	r30, r14
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 //it is converted to years since 1970
  if( yr > 99)
    7f90:	e4 36       	cpi	r30, 0x64	; 100
    7f92:	f1 05       	cpc	r31, r1
    7f94:	1c f0       	brlt	.+6      	; 0x7f9c <_Z7setTimeiiiiii+0x14>
      yr = yr - 1970;
    7f96:	e2 5b       	subi	r30, 0xB2	; 178
    7f98:	f7 40       	sbci	r31, 0x07	; 7
    7f9a:	01 c0       	rjmp	.+2      	; 0x7f9e <_Z7setTimeiiiiii+0x16>
  else
      yr += 30;  
    7f9c:	7e 96       	adiw	r30, 0x1e	; 30
  tm.Year = yr;
    7f9e:	e0 93 fe 2b 	sts	0x2BFE, r30
  tm.Month = mnth;
    7fa2:	00 93 fd 2b 	sts	0x2BFD, r16
  tm.Day = dy;
    7fa6:	20 93 fc 2b 	sts	0x2BFC, r18
  tm.Hour = hr;
    7faa:	80 93 fa 2b 	sts	0x2BFA, r24
  tm.Minute = min;
    7fae:	60 93 f9 2b 	sts	0x2BF9, r22
  tm.Second = sec;
    7fb2:	40 93 f8 2b 	sts	0x2BF8, r20
  setTime(makeTime(tm));
    7fb6:	88 ef       	ldi	r24, 0xF8	; 248
    7fb8:	9b e2       	ldi	r25, 0x2B	; 43
    7fba:	0e 94 a2 3e 	call	0x7d44	; 0x7d44 <_Z8makeTimeR12tmElements_t>
    7fbe:	0e 94 9a 3f 	call	0x7f34	; 0x7f34 <_Z7setTimem>
}
    7fc2:	0f 91       	pop	r16
    7fc4:	ff 90       	pop	r15
    7fc6:	ef 90       	pop	r14
    7fc8:	08 95       	ret

00007fca <_Z3nowi>:
    }
  }  
  return sysTime;
}

time_t now(int MillisPerSec){
    7fca:	af 92       	push	r10
    7fcc:	bf 92       	push	r11
    7fce:	cf 92       	push	r12
    7fd0:	df 92       	push	r13
    7fd2:	ef 92       	push	r14
    7fd4:	ff 92       	push	r15
    7fd6:	0f 93       	push	r16
    7fd8:	1f 93       	push	r17
  while( millis() - prevMillis >= MillisPerSec){
    7fda:	5c 01       	movw	r10, r24
    7fdc:	cc 24       	eor	r12, r12
    7fde:	b7 fc       	sbrc	r11, 7
    7fe0:	c0 94       	com	r12
    7fe2:	dc 2c       	mov	r13, r12
    7fe4:	18 c0       	rjmp	.+48     	; 0x8016 <_Z3nowi+0x4c>
    sysTime++;
    7fe6:	2f 5f       	subi	r18, 0xFF	; 255
    7fe8:	3f 4f       	sbci	r19, 0xFF	; 255
    7fea:	4f 4f       	sbci	r20, 0xFF	; 255
    7fec:	5f 4f       	sbci	r21, 0xFF	; 255
    7fee:	20 93 ef 2b 	sts	0x2BEF, r18
    7ff2:	30 93 f0 2b 	sts	0x2BF0, r19
    7ff6:	40 93 f1 2b 	sts	0x2BF1, r20
    7ffa:	50 93 f2 2b 	sts	0x2BF2, r21
    prevMillis += MillisPerSec;
    7ffe:	ea 0c       	add	r14, r10
    8000:	fb 1c       	adc	r15, r11
    8002:	0c 1d       	adc	r16, r12
    8004:	1d 1d       	adc	r17, r13
    8006:	e0 92 ff 2b 	sts	0x2BFF, r14
    800a:	f0 92 00 2c 	sts	0x2C00, r15
    800e:	00 93 01 2c 	sts	0x2C01, r16
    8012:	10 93 02 2c 	sts	0x2C02, r17
  }  
  return sysTime;
}

time_t now(int MillisPerSec){
  while( millis() - prevMillis >= MillisPerSec){
    8016:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    801a:	e0 90 ff 2b 	lds	r14, 0x2BFF
    801e:	f0 90 00 2c 	lds	r15, 0x2C00
    8022:	00 91 01 2c 	lds	r16, 0x2C01
    8026:	10 91 02 2c 	lds	r17, 0x2C02
    802a:	6e 19       	sub	r22, r14
    802c:	7f 09       	sbc	r23, r15
    802e:	80 0b       	sbc	r24, r16
    8030:	91 0b       	sbc	r25, r17
    8032:	20 91 ef 2b 	lds	r18, 0x2BEF
    8036:	30 91 f0 2b 	lds	r19, 0x2BF0
    803a:	40 91 f1 2b 	lds	r20, 0x2BF1
    803e:	50 91 f2 2b 	lds	r21, 0x2BF2
    8042:	6a 15       	cp	r22, r10
    8044:	7b 05       	cpc	r23, r11
    8046:	8c 05       	cpc	r24, r12
    8048:	9d 05       	cpc	r25, r13
    804a:	68 f6       	brcc	.-102    	; 0x7fe6 <_Z3nowi+0x1c>
    prevMillis += MillisPerSec;
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif	
  }
  if(nextSyncTime <= sysTime){
    804c:	80 91 f3 2b 	lds	r24, 0x2BF3
    8050:	90 91 f4 2b 	lds	r25, 0x2BF4
    8054:	a0 91 f5 2b 	lds	r26, 0x2BF5
    8058:	b0 91 f6 2b 	lds	r27, 0x2BF6
    805c:	28 17       	cp	r18, r24
    805e:	39 07       	cpc	r19, r25
    8060:	4a 07       	cpc	r20, r26
    8062:	5b 07       	cpc	r21, r27
    8064:	b0 f0       	brcs	.+44     	; 0x8092 <_Z3nowi+0xc8>
	if(getTimePtr != 0){
    8066:	e0 91 ed 2b 	lds	r30, 0x2BED
    806a:	f0 91 ee 2b 	lds	r31, 0x2BEE
    806e:	30 97       	sbiw	r30, 0x00	; 0
    8070:	81 f0       	breq	.+32     	; 0x8092 <_Z3nowi+0xc8>
	  time_t t = getTimePtr();
    8072:	19 95       	eicall
      if( t != 0)
    8074:	61 15       	cp	r22, r1
    8076:	71 05       	cpc	r23, r1
    8078:	81 05       	cpc	r24, r1
    807a:	91 05       	cpc	r25, r1
    807c:	19 f0       	breq	.+6      	; 0x8084 <_Z3nowi+0xba>
        setTime(t);
    807e:	0e 94 9a 3f 	call	0x7f34	; 0x7f34 <_Z7setTimem>
    8082:	07 c0       	rjmp	.+14     	; 0x8092 <_Z3nowi+0xc8>
      else
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;        
    8084:	90 e0       	ldi	r25, 0x00	; 0
    8086:	80 91 f7 2b 	lds	r24, 0x2BF7
    808a:	81 11       	cpse	r24, r1
    808c:	91 e0       	ldi	r25, 0x01	; 1
    808e:	90 93 f7 2b 	sts	0x2BF7, r25
    8092:	60 91 ef 2b 	lds	r22, 0x2BEF
    8096:	70 91 f0 2b 	lds	r23, 0x2BF0
    }
  }  
  return sysTime;
}
    809a:	80 91 f1 2b 	lds	r24, 0x2BF1
    809e:	90 91 f2 2b 	lds	r25, 0x2BF2
    80a2:	1f 91       	pop	r17
    80a4:	0f 91       	pop	r16
    80a6:	ff 90       	pop	r15
    80a8:	ef 90       	pop	r14
    80aa:	df 90       	pop	r13
    80ac:	cf 90       	pop	r12
    80ae:	bf 90       	pop	r11
    80b0:	af 90       	pop	r10
    80b2:	08 95       	ret

000080b4 <_Z3nowv>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif

time_t now() {
    return now(millisPerSecond);
    80b4:	88 ee       	ldi	r24, 0xE8	; 232
    80b6:	93 e0       	ldi	r25, 0x03	; 3
    80b8:	0e 94 e5 3f 	call	0x7fca	; 0x7fca <_Z3nowi>
}
    80bc:	08 95       	ret

000080be <_Z15setSyncProviderPFmvE>:
timeStatus_t timeStatus(){ // indicates if time has been set and recently synchronized
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    80be:	80 93 ed 2b 	sts	0x2BED, r24
    80c2:	90 93 ee 2b 	sts	0x2BEE, r25
  nextSyncTime = sysTime;
    80c6:	80 91 ef 2b 	lds	r24, 0x2BEF
    80ca:	90 91 f0 2b 	lds	r25, 0x2BF0
    80ce:	a0 91 f1 2b 	lds	r26, 0x2BF1
    80d2:	b0 91 f2 2b 	lds	r27, 0x2BF2
    80d6:	80 93 f3 2b 	sts	0x2BF3, r24
    80da:	90 93 f4 2b 	sts	0x2BF4, r25
    80de:	a0 93 f5 2b 	sts	0x2BF5, r26
    80e2:	b0 93 f6 2b 	sts	0x2BF6, r27
  now(); // this will sync the clock
    80e6:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}
    80ea:	08 95       	ret

000080ec <_Z4yearv>:
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    80ec:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
    80f0:	0e 94 4e 3e 	call	0x7c9c	; 0x7c9c <_Z4yearm>
}
    80f4:	08 95       	ret

000080f6 <_Z5monthv>:
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
  return month(now()); 
    80f6:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
    80fa:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    80fe:	80 91 fd 2b 	lds	r24, 0x2BFD
    8102:	90 e0       	ldi	r25, 0x00	; 0
    8104:	08 95       	ret

00008106 <_Z7weekdayv>:
  refreshCache(t);
  return tm.Day;
}

int weekday() {   // Sunday is day 1
  return  weekday(now()); 
    8106:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}

int weekday(time_t t) {
  refreshCache(t);
    810a:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Day;
}

int weekday() {   // Sunday is day 1
  return  weekday(now()); 
}
    810e:	80 91 fb 2b 	lds	r24, 0x2BFB
    8112:	90 e0       	ldi	r25, 0x00	; 0
    8114:	08 95       	ret

00008116 <_Z3dayv>:
  refreshCache(t);
  return tm.Second;
}

int day(){
  return(day(now())); 
    8116:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
    811a:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    811e:	80 91 fc 2b 	lds	r24, 0x2BFC
    8122:	90 e0       	ldi	r25, 0x00	; 0
    8124:	08 95       	ret

00008126 <_Z6secondv>:
  refreshCache(t);
  return tm.Minute;  
}

int second() {
  return second(now()); 
    8126:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
    812a:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    812e:	80 91 f8 2b 	lds	r24, 0x2BF8
    8132:	90 e0       	ldi	r25, 0x00	; 0
    8134:	08 95       	ret

00008136 <_Z6minutev>:
uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
    8136:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
    813a:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    813e:	80 91 f9 2b 	lds	r24, 0x2BF9
    8142:	90 e0       	ldi	r25, 0x00	; 0
    8144:	08 95       	ret

00008146 <_Z4isPMv>:
uint8_t isAM(time_t t) { // returns true if given time is AM
  return !isPM(t);  
}

uint8_t isPM() { // returns true if PM
  return isPM(now()); 
    8146:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
    814a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <_Z4isPMm>
}
    814e:	08 95       	ret

00008150 <_Z4isAMv>:
  else
    return tm.Hour ;
}

uint8_t isAM() { // returns true if time now is AM
  return !isPM(now()); 
    8150:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
    8154:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <_Z4isPMm>
    8158:	90 e0       	ldi	r25, 0x00	; 0
    815a:	88 23       	and	r24, r24
    815c:	09 f4       	brne	.+2      	; 0x8160 <_Z4isAMv+0x10>
    815e:	91 e0       	ldi	r25, 0x01	; 1
}
    8160:	89 2f       	mov	r24, r25
    8162:	08 95       	ret

00008164 <_Z12hourFormat12v>:
  refreshCache(t);
  return tm.Hour;  
}

int hourFormat12() { // the hour now in 12 hour format
  return hourFormat12(now()); 
    8164:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
    8168:	0e 94 75 3e 	call	0x7cea	; 0x7cea <_Z12hourFormat12m>
}
    816c:	08 95       	ret

0000816e <_Z4hourv>:
    cacheTime = t; 
  }
}

int hour() { // the hour now 
  return hour(now()); 
    816e:	0e 94 5a 40 	call	0x80b4	; 0x80b4 <_Z3nowv>
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
    8172:	0e 94 28 3e 	call	0x7c50	; 0x7c50 <_Z12refreshCachem>
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    8176:	80 91 fa 2b 	lds	r24, 0x2BFA
    817a:	90 e0       	ldi	r25, 0x00	; 0
    817c:	08 95       	ret

0000817e <_Z6nowoldv>:

time_t now() {
    return now(millisPerSecond);
}

time_t nowold(){
    817e:	ef 92       	push	r14
    8180:	ff 92       	push	r15
    8182:	0f 93       	push	r16
    8184:	1f 93       	push	r17
    8186:	1c c0       	rjmp	.+56     	; 0x81c0 <_Z6nowoldv+0x42>
  while( millis() - prevMillis >= 1000){      
    sysTime++;
    8188:	2f 5f       	subi	r18, 0xFF	; 255
    818a:	3f 4f       	sbci	r19, 0xFF	; 255
    818c:	4f 4f       	sbci	r20, 0xFF	; 255
    818e:	5f 4f       	sbci	r21, 0xFF	; 255
    8190:	20 93 ef 2b 	sts	0x2BEF, r18
    8194:	30 93 f0 2b 	sts	0x2BF0, r19
    8198:	40 93 f1 2b 	sts	0x2BF1, r20
    819c:	50 93 f2 2b 	sts	0x2BF2, r21
    prevMillis += 1000;	
    81a0:	88 ee       	ldi	r24, 0xE8	; 232
    81a2:	93 e0       	ldi	r25, 0x03	; 3
    81a4:	a0 e0       	ldi	r26, 0x00	; 0
    81a6:	b0 e0       	ldi	r27, 0x00	; 0
    81a8:	e8 0e       	add	r14, r24
    81aa:	f9 1e       	adc	r15, r25
    81ac:	0a 1f       	adc	r16, r26
    81ae:	1b 1f       	adc	r17, r27
    81b0:	e0 92 ff 2b 	sts	0x2BFF, r14
    81b4:	f0 92 00 2c 	sts	0x2C00, r15
    81b8:	00 93 01 2c 	sts	0x2C01, r16
    81bc:	10 93 02 2c 	sts	0x2C02, r17
time_t now() {
    return now(millisPerSecond);
}

time_t nowold(){
  while( millis() - prevMillis >= 1000){      
    81c0:	0e 94 e0 3a 	call	0x75c0	; 0x75c0 <_Z6millisv>
    81c4:	e0 90 ff 2b 	lds	r14, 0x2BFF
    81c8:	f0 90 00 2c 	lds	r15, 0x2C00
    81cc:	00 91 01 2c 	lds	r16, 0x2C01
    81d0:	10 91 02 2c 	lds	r17, 0x2C02
    81d4:	6e 19       	sub	r22, r14
    81d6:	7f 09       	sbc	r23, r15
    81d8:	80 0b       	sbc	r24, r16
    81da:	91 0b       	sbc	r25, r17
    81dc:	20 91 ef 2b 	lds	r18, 0x2BEF
    81e0:	30 91 f0 2b 	lds	r19, 0x2BF0
    81e4:	40 91 f1 2b 	lds	r20, 0x2BF1
    81e8:	50 91 f2 2b 	lds	r21, 0x2BF2
    81ec:	68 5e       	subi	r22, 0xE8	; 232
    81ee:	73 40       	sbci	r23, 0x03	; 3
    81f0:	80 40       	sbci	r24, 0x00	; 0
    81f2:	90 40       	sbci	r25, 0x00	; 0
    81f4:	48 f6       	brcc	.-110    	; 0x8188 <_Z6nowoldv+0xa>
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif	
  }
  if(nextSyncTime <= sysTime){
    81f6:	80 91 f3 2b 	lds	r24, 0x2BF3
    81fa:	90 91 f4 2b 	lds	r25, 0x2BF4
    81fe:	a0 91 f5 2b 	lds	r26, 0x2BF5
    8202:	b0 91 f6 2b 	lds	r27, 0x2BF6
    8206:	28 17       	cp	r18, r24
    8208:	39 07       	cpc	r19, r25
    820a:	4a 07       	cpc	r20, r26
    820c:	5b 07       	cpc	r21, r27
    820e:	b0 f0       	brcs	.+44     	; 0x823c <_Z6nowoldv+0xbe>
	if(getTimePtr != 0){
    8210:	e0 91 ed 2b 	lds	r30, 0x2BED
    8214:	f0 91 ee 2b 	lds	r31, 0x2BEE
    8218:	30 97       	sbiw	r30, 0x00	; 0
    821a:	81 f0       	breq	.+32     	; 0x823c <_Z6nowoldv+0xbe>
	  time_t t = getTimePtr();
    821c:	19 95       	eicall
      if( t != 0)
    821e:	61 15       	cp	r22, r1
    8220:	71 05       	cpc	r23, r1
    8222:	81 05       	cpc	r24, r1
    8224:	91 05       	cpc	r25, r1
    8226:	19 f0       	breq	.+6      	; 0x822e <_Z6nowoldv+0xb0>
        setTime(t);
    8228:	0e 94 9a 3f 	call	0x7f34	; 0x7f34 <_Z7setTimem>
    822c:	07 c0       	rjmp	.+14     	; 0x823c <_Z6nowoldv+0xbe>
      else
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;        
    822e:	90 e0       	ldi	r25, 0x00	; 0
    8230:	80 91 f7 2b 	lds	r24, 0x2BF7
    8234:	81 11       	cpse	r24, r1
    8236:	91 e0       	ldi	r25, 0x01	; 1
    8238:	90 93 f7 2b 	sts	0x2BF7, r25
    823c:	60 91 ef 2b 	lds	r22, 0x2BEF
    8240:	70 91 f0 2b 	lds	r23, 0x2BF0
    }
  }  
  return sysTime;
}
    8244:	80 91 f1 2b 	lds	r24, 0x2BF1
    8248:	90 91 f2 2b 	lds	r25, 0x2BF2
    824c:	1f 91       	pop	r17
    824e:	0f 91       	pop	r16
    8250:	ff 90       	pop	r15
    8252:	ef 90       	pop	r14
    8254:	08 95       	ret

00008256 <__muldi3>:
    8256:	a0 e3       	ldi	r26, 0x30	; 48
    8258:	b0 e0       	ldi	r27, 0x00	; 0
    825a:	e1 e3       	ldi	r30, 0x31	; 49
    825c:	f1 e4       	ldi	r31, 0x41	; 65
    825e:	0c 94 b1 49 	jmp	0x9362	; 0x9362 <__prologue_saves__>
    8262:	a8 e0       	ldi	r26, 0x08	; 8
    8264:	4e 01       	movw	r8, r28
    8266:	08 94       	sec
    8268:	81 1c       	adc	r8, r1
    826a:	91 1c       	adc	r9, r1
    826c:	f4 01       	movw	r30, r8
    826e:	ba 2f       	mov	r27, r26
    8270:	11 92       	st	Z+, r1
    8272:	ba 95       	dec	r27
    8274:	e9 f7       	brne	.-6      	; 0x8270 <__muldi3+0x1a>
    8276:	29 83       	std	Y+1, r18	; 0x01
    8278:	3a 83       	std	Y+2, r19	; 0x02
    827a:	4b 83       	std	Y+3, r20	; 0x03
    827c:	5c 83       	std	Y+4, r21	; 0x04
    827e:	6d 83       	std	Y+5, r22	; 0x05
    8280:	7e 83       	std	Y+6, r23	; 0x06
    8282:	8f 83       	std	Y+7, r24	; 0x07
    8284:	98 87       	std	Y+8, r25	; 0x08
    8286:	ce 01       	movw	r24, r28
    8288:	09 96       	adiw	r24, 0x09	; 9
    828a:	fc 01       	movw	r30, r24
    828c:	11 92       	st	Z+, r1
    828e:	aa 95       	dec	r26
    8290:	e9 f7       	brne	.-6      	; 0x828c <__muldi3+0x36>
    8292:	a9 86       	std	Y+9, r10	; 0x09
    8294:	ba 86       	std	Y+10, r11	; 0x0a
    8296:	cb 86       	std	Y+11, r12	; 0x0b
    8298:	dc 86       	std	Y+12, r13	; 0x0c
    829a:	ed 86       	std	Y+13, r14	; 0x0d
    829c:	fe 86       	std	Y+14, r15	; 0x0e
    829e:	0f 87       	std	Y+15, r16	; 0x0f
    82a0:	18 8b       	std	Y+16, r17	; 0x10
    82a2:	29 81       	ldd	r18, Y+1	; 0x01
    82a4:	3a 81       	ldd	r19, Y+2	; 0x02
    82a6:	4b 81       	ldd	r20, Y+3	; 0x03
    82a8:	5c 81       	ldd	r21, Y+4	; 0x04
    82aa:	2d a7       	std	Y+45, r18	; 0x2d
    82ac:	3e a7       	std	Y+46, r19	; 0x2e
    82ae:	4f a7       	std	Y+47, r20	; 0x2f
    82b0:	58 ab       	std	Y+48, r21	; 0x30
    82b2:	79 01       	movw	r14, r18
    82b4:	8a 01       	movw	r16, r20
    82b6:	8f ef       	ldi	r24, 0xFF	; 255
    82b8:	9f ef       	ldi	r25, 0xFF	; 255
    82ba:	a0 e0       	ldi	r26, 0x00	; 0
    82bc:	b0 e0       	ldi	r27, 0x00	; 0
    82be:	e8 22       	and	r14, r24
    82c0:	f9 22       	and	r15, r25
    82c2:	0a 23       	and	r16, r26
    82c4:	1b 23       	and	r17, r27
    82c6:	1a 01       	movw	r2, r20
    82c8:	44 24       	eor	r4, r4
    82ca:	55 24       	eor	r5, r5
    82cc:	29 85       	ldd	r18, Y+9	; 0x09
    82ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    82d0:	4b 85       	ldd	r20, Y+11	; 0x0b
    82d2:	5c 85       	ldd	r21, Y+12	; 0x0c
    82d4:	29 a7       	std	Y+41, r18	; 0x29
    82d6:	3a a7       	std	Y+42, r19	; 0x2a
    82d8:	4b a7       	std	Y+43, r20	; 0x2b
    82da:	5c a7       	std	Y+44, r21	; 0x2c
    82dc:	59 01       	movw	r10, r18
    82de:	6a 01       	movw	r12, r20
    82e0:	a8 22       	and	r10, r24
    82e2:	b9 22       	and	r11, r25
    82e4:	ca 22       	and	r12, r26
    82e6:	db 22       	and	r13, r27
    82e8:	3a 01       	movw	r6, r20
    82ea:	88 24       	eor	r8, r8
    82ec:	99 24       	eor	r9, r9
    82ee:	c6 01       	movw	r24, r12
    82f0:	b5 01       	movw	r22, r10
    82f2:	a8 01       	movw	r20, r16
    82f4:	97 01       	movw	r18, r14
    82f6:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    82fa:	6d a3       	std	Y+37, r22	; 0x25
    82fc:	7e a3       	std	Y+38, r23	; 0x26
    82fe:	8f a3       	std	Y+39, r24	; 0x27
    8300:	98 a7       	std	Y+40, r25	; 0x28
    8302:	c4 01       	movw	r24, r8
    8304:	b3 01       	movw	r22, r6
    8306:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    830a:	69 a3       	std	Y+33, r22	; 0x21
    830c:	7a a3       	std	Y+34, r23	; 0x22
    830e:	8b a3       	std	Y+35, r24	; 0x23
    8310:	9c a3       	std	Y+36, r25	; 0x24
    8312:	c6 01       	movw	r24, r12
    8314:	b5 01       	movw	r22, r10
    8316:	a2 01       	movw	r20, r4
    8318:	91 01       	movw	r18, r2
    831a:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    831e:	7b 01       	movw	r14, r22
    8320:	8c 01       	movw	r16, r24
    8322:	c4 01       	movw	r24, r8
    8324:	b3 01       	movw	r22, r6
    8326:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    832a:	5b 01       	movw	r10, r22
    832c:	6c 01       	movw	r12, r24
    832e:	89 a1       	ldd	r24, Y+33	; 0x21
    8330:	9a a1       	ldd	r25, Y+34	; 0x22
    8332:	ab a1       	ldd	r26, Y+35	; 0x23
    8334:	bc a1       	ldd	r27, Y+36	; 0x24
    8336:	8e 0d       	add	r24, r14
    8338:	9f 1d       	adc	r25, r15
    833a:	a0 1f       	adc	r26, r16
    833c:	b1 1f       	adc	r27, r17
    833e:	89 a3       	std	Y+33, r24	; 0x21
    8340:	9a a3       	std	Y+34, r25	; 0x22
    8342:	ab a3       	std	Y+35, r26	; 0x23
    8344:	bc a3       	std	Y+36, r27	; 0x24
    8346:	2d a1       	ldd	r18, Y+37	; 0x25
    8348:	3e a1       	ldd	r19, Y+38	; 0x26
    834a:	4f a1       	ldd	r20, Y+39	; 0x27
    834c:	58 a5       	ldd	r21, Y+40	; 0x28
    834e:	ca 01       	movw	r24, r20
    8350:	aa 27       	eor	r26, r26
    8352:	bb 27       	eor	r27, r27
    8354:	29 a1       	ldd	r18, Y+33	; 0x21
    8356:	3a a1       	ldd	r19, Y+34	; 0x22
    8358:	4b a1       	ldd	r20, Y+35	; 0x23
    835a:	5c a1       	ldd	r21, Y+36	; 0x24
    835c:	28 0f       	add	r18, r24
    835e:	39 1f       	adc	r19, r25
    8360:	4a 1f       	adc	r20, r26
    8362:	5b 1f       	adc	r21, r27
    8364:	29 a3       	std	Y+33, r18	; 0x21
    8366:	3a a3       	std	Y+34, r19	; 0x22
    8368:	4b a3       	std	Y+35, r20	; 0x23
    836a:	5c a3       	std	Y+36, r21	; 0x24
    836c:	2e 15       	cp	r18, r14
    836e:	3f 05       	cpc	r19, r15
    8370:	40 07       	cpc	r20, r16
    8372:	51 07       	cpc	r21, r17
    8374:	40 f4       	brcc	.+16     	; 0x8386 <__muldi3+0x130>
    8376:	80 e0       	ldi	r24, 0x00	; 0
    8378:	90 e0       	ldi	r25, 0x00	; 0
    837a:	a1 e0       	ldi	r26, 0x01	; 1
    837c:	b0 e0       	ldi	r27, 0x00	; 0
    837e:	a8 0e       	add	r10, r24
    8380:	b9 1e       	adc	r11, r25
    8382:	ca 1e       	adc	r12, r26
    8384:	db 1e       	adc	r13, r27
    8386:	89 a1       	ldd	r24, Y+33	; 0x21
    8388:	9a a1       	ldd	r25, Y+34	; 0x22
    838a:	ab a1       	ldd	r26, Y+35	; 0x23
    838c:	bc a1       	ldd	r27, Y+36	; 0x24
    838e:	9d 01       	movw	r18, r26
    8390:	44 27       	eor	r20, r20
    8392:	55 27       	eor	r21, r21
    8394:	2a 0d       	add	r18, r10
    8396:	3b 1d       	adc	r19, r11
    8398:	4c 1d       	adc	r20, r12
    839a:	5d 1d       	adc	r21, r13
    839c:	2d 8f       	std	Y+29, r18	; 0x1d
    839e:	3e 8f       	std	Y+30, r19	; 0x1e
    83a0:	4f 8f       	std	Y+31, r20	; 0x1f
    83a2:	58 a3       	std	Y+32, r21	; 0x20
    83a4:	6c 01       	movw	r12, r24
    83a6:	bb 24       	eor	r11, r11
    83a8:	aa 24       	eor	r10, r10
    83aa:	8d a1       	ldd	r24, Y+37	; 0x25
    83ac:	9e a1       	ldd	r25, Y+38	; 0x26
    83ae:	af a1       	ldd	r26, Y+39	; 0x27
    83b0:	b8 a5       	ldd	r27, Y+40	; 0x28
    83b2:	a0 70       	andi	r26, 0x00	; 0
    83b4:	b0 70       	andi	r27, 0x00	; 0
    83b6:	a8 0e       	add	r10, r24
    83b8:	b9 1e       	adc	r11, r25
    83ba:	ca 1e       	adc	r12, r26
    83bc:	db 1e       	adc	r13, r27
    83be:	a9 8e       	std	Y+25, r10	; 0x19
    83c0:	ba 8e       	std	Y+26, r11	; 0x1a
    83c2:	cb 8e       	std	Y+27, r12	; 0x1b
    83c4:	dc 8e       	std	Y+28, r13	; 0x1c
    83c6:	9a 8c       	ldd	r9, Y+26	; 0x1a
    83c8:	8b 8c       	ldd	r8, Y+27	; 0x1b
    83ca:	7c 8c       	ldd	r7, Y+28	; 0x1c
    83cc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    83ce:	6f 8d       	ldd	r22, Y+31	; 0x1f
    83d0:	78 a1       	ldd	r23, Y+32	; 0x20
    83d2:	fe 01       	movw	r30, r28
    83d4:	71 96       	adiw	r30, 0x11	; 17
    83d6:	88 e0       	ldi	r24, 0x08	; 8
    83d8:	df 01       	movw	r26, r30
    83da:	1d 92       	st	X+, r1
    83dc:	8a 95       	dec	r24
    83de:	e9 f7       	brne	.-6      	; 0x83da <__muldi3+0x184>
    83e0:	2d 8b       	std	Y+21, r18	; 0x15
    83e2:	9e 8b       	std	Y+22, r25	; 0x16
    83e4:	6f 8b       	std	Y+23, r22	; 0x17
    83e6:	78 8f       	std	Y+24, r23	; 0x18
    83e8:	2d 85       	ldd	r18, Y+13	; 0x0d
    83ea:	3e 85       	ldd	r19, Y+14	; 0x0e
    83ec:	4f 85       	ldd	r20, Y+15	; 0x0f
    83ee:	58 89       	ldd	r21, Y+16	; 0x10
    83f0:	6d a5       	ldd	r22, Y+45	; 0x2d
    83f2:	7e a5       	ldd	r23, Y+46	; 0x2e
    83f4:	8f a5       	ldd	r24, Y+47	; 0x2f
    83f6:	98 a9       	ldd	r25, Y+48	; 0x30
    83f8:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    83fc:	7b 01       	movw	r14, r22
    83fe:	8c 01       	movw	r16, r24
    8400:	2d 81       	ldd	r18, Y+5	; 0x05
    8402:	3e 81       	ldd	r19, Y+6	; 0x06
    8404:	4f 81       	ldd	r20, Y+7	; 0x07
    8406:	58 85       	ldd	r21, Y+8	; 0x08
    8408:	69 a5       	ldd	r22, Y+41	; 0x29
    840a:	7a a5       	ldd	r23, Y+42	; 0x2a
    840c:	8b a5       	ldd	r24, Y+43	; 0x2b
    840e:	9c a5       	ldd	r25, Y+44	; 0x2c
    8410:	0e 94 22 49 	call	0x9244	; 0x9244 <__mulsi3>
    8414:	e6 0e       	add	r14, r22
    8416:	f7 1e       	adc	r15, r23
    8418:	08 1f       	adc	r16, r24
    841a:	19 1f       	adc	r17, r25
    841c:	6d 89       	ldd	r22, Y+21	; 0x15
    841e:	7e 89       	ldd	r23, Y+22	; 0x16
    8420:	8f 89       	ldd	r24, Y+23	; 0x17
    8422:	98 8d       	ldd	r25, Y+24	; 0x18
    8424:	6e 0d       	add	r22, r14
    8426:	7f 1d       	adc	r23, r15
    8428:	80 1f       	adc	r24, r16
    842a:	91 1f       	adc	r25, r17
    842c:	6d 8b       	std	Y+21, r22	; 0x15
    842e:	7e 8b       	std	Y+22, r23	; 0x16
    8430:	8f 8b       	std	Y+23, r24	; 0x17
    8432:	98 8f       	std	Y+24, r25	; 0x18
    8434:	ee 89       	ldd	r30, Y+22	; 0x16
    8436:	2a 2d       	mov	r18, r10
    8438:	39 2d       	mov	r19, r9
    843a:	48 2d       	mov	r20, r8
    843c:	57 2d       	mov	r21, r7
    843e:	7e 2f       	mov	r23, r30
    8440:	8f 89       	ldd	r24, Y+23	; 0x17
    8442:	98 8d       	ldd	r25, Y+24	; 0x18
    8444:	e0 96       	adiw	r28, 0x30	; 48
    8446:	e2 e1       	ldi	r30, 0x12	; 18
    8448:	0c 94 cd 49 	jmp	0x939a	; 0x939a <__epilogue_restores__>

0000844c <__fixunssfsi>:
    844c:	ef 92       	push	r14
    844e:	ff 92       	push	r15
    8450:	0f 93       	push	r16
    8452:	1f 93       	push	r17
    8454:	7b 01       	movw	r14, r22
    8456:	8c 01       	movw	r16, r24
    8458:	20 e0       	ldi	r18, 0x00	; 0
    845a:	30 e0       	ldi	r19, 0x00	; 0
    845c:	40 e0       	ldi	r20, 0x00	; 0
    845e:	5f e4       	ldi	r21, 0x4F	; 79
    8460:	0e 94 a2 45 	call	0x8b44	; 0x8b44 <__gesf2>
    8464:	88 23       	and	r24, r24
    8466:	8c f0       	brlt	.+34     	; 0x848a <__fixunssfsi+0x3e>
    8468:	c8 01       	movw	r24, r16
    846a:	b7 01       	movw	r22, r14
    846c:	20 e0       	ldi	r18, 0x00	; 0
    846e:	30 e0       	ldi	r19, 0x00	; 0
    8470:	40 e0       	ldi	r20, 0x00	; 0
    8472:	5f e4       	ldi	r21, 0x4F	; 79
    8474:	0e 94 9e 43 	call	0x873c	; 0x873c <__subsf3>
    8478:	0e 94 60 46 	call	0x8cc0	; 0x8cc0 <__fixsfsi>
    847c:	9b 01       	movw	r18, r22
    847e:	ac 01       	movw	r20, r24
    8480:	20 50       	subi	r18, 0x00	; 0
    8482:	30 40       	sbci	r19, 0x00	; 0
    8484:	40 40       	sbci	r20, 0x00	; 0
    8486:	50 48       	sbci	r21, 0x80	; 128
    8488:	06 c0       	rjmp	.+12     	; 0x8496 <__fixunssfsi+0x4a>
    848a:	c8 01       	movw	r24, r16
    848c:	b7 01       	movw	r22, r14
    848e:	0e 94 60 46 	call	0x8cc0	; 0x8cc0 <__fixsfsi>
    8492:	9b 01       	movw	r18, r22
    8494:	ac 01       	movw	r20, r24
    8496:	b9 01       	movw	r22, r18
    8498:	ca 01       	movw	r24, r20
    849a:	1f 91       	pop	r17
    849c:	0f 91       	pop	r16
    849e:	ff 90       	pop	r15
    84a0:	ef 90       	pop	r14
    84a2:	08 95       	ret

000084a4 <_fpadd_parts>:
    84a4:	a0 e0       	ldi	r26, 0x00	; 0
    84a6:	b0 e0       	ldi	r27, 0x00	; 0
    84a8:	e8 e5       	ldi	r30, 0x58	; 88
    84aa:	f2 e4       	ldi	r31, 0x42	; 66
    84ac:	0c 94 b1 49 	jmp	0x9362	; 0x9362 <__prologue_saves__>
    84b0:	dc 01       	movw	r26, r24
    84b2:	2b 01       	movw	r4, r22
    84b4:	fa 01       	movw	r30, r20
    84b6:	9c 91       	ld	r25, X
    84b8:	92 30       	cpi	r25, 0x02	; 2
    84ba:	08 f4       	brcc	.+2      	; 0x84be <_fpadd_parts+0x1a>
    84bc:	39 c1       	rjmp	.+626    	; 0x8730 <_fpadd_parts+0x28c>
    84be:	eb 01       	movw	r28, r22
    84c0:	88 81       	ld	r24, Y
    84c2:	82 30       	cpi	r24, 0x02	; 2
    84c4:	08 f4       	brcc	.+2      	; 0x84c8 <_fpadd_parts+0x24>
    84c6:	33 c1       	rjmp	.+614    	; 0x872e <_fpadd_parts+0x28a>
    84c8:	94 30       	cpi	r25, 0x04	; 4
    84ca:	69 f4       	brne	.+26     	; 0x84e6 <_fpadd_parts+0x42>
    84cc:	84 30       	cpi	r24, 0x04	; 4
    84ce:	09 f0       	breq	.+2      	; 0x84d2 <_fpadd_parts+0x2e>
    84d0:	2f c1       	rjmp	.+606    	; 0x8730 <_fpadd_parts+0x28c>
    84d2:	11 96       	adiw	r26, 0x01	; 1
    84d4:	9c 91       	ld	r25, X
    84d6:	11 97       	sbiw	r26, 0x01	; 1
    84d8:	89 81       	ldd	r24, Y+1	; 0x01
    84da:	98 17       	cp	r25, r24
    84dc:	09 f4       	brne	.+2      	; 0x84e0 <_fpadd_parts+0x3c>
    84de:	28 c1       	rjmp	.+592    	; 0x8730 <_fpadd_parts+0x28c>
    84e0:	ab e1       	ldi	r26, 0x1B	; 27
    84e2:	b5 e2       	ldi	r27, 0x25	; 37
    84e4:	25 c1       	rjmp	.+586    	; 0x8730 <_fpadd_parts+0x28c>
    84e6:	84 30       	cpi	r24, 0x04	; 4
    84e8:	09 f4       	brne	.+2      	; 0x84ec <_fpadd_parts+0x48>
    84ea:	21 c1       	rjmp	.+578    	; 0x872e <_fpadd_parts+0x28a>
    84ec:	82 30       	cpi	r24, 0x02	; 2
    84ee:	a9 f4       	brne	.+42     	; 0x851a <_fpadd_parts+0x76>
    84f0:	92 30       	cpi	r25, 0x02	; 2
    84f2:	09 f0       	breq	.+2      	; 0x84f6 <_fpadd_parts+0x52>
    84f4:	1d c1       	rjmp	.+570    	; 0x8730 <_fpadd_parts+0x28c>
    84f6:	9a 01       	movw	r18, r20
    84f8:	ad 01       	movw	r20, r26
    84fa:	88 e0       	ldi	r24, 0x08	; 8
    84fc:	ea 01       	movw	r28, r20
    84fe:	09 90       	ld	r0, Y+
    8500:	ae 01       	movw	r20, r28
    8502:	e9 01       	movw	r28, r18
    8504:	09 92       	st	Y+, r0
    8506:	9e 01       	movw	r18, r28
    8508:	81 50       	subi	r24, 0x01	; 1
    850a:	c1 f7       	brne	.-16     	; 0x84fc <_fpadd_parts+0x58>
    850c:	e2 01       	movw	r28, r4
    850e:	89 81       	ldd	r24, Y+1	; 0x01
    8510:	11 96       	adiw	r26, 0x01	; 1
    8512:	9c 91       	ld	r25, X
    8514:	89 23       	and	r24, r25
    8516:	81 83       	std	Z+1, r24	; 0x01
    8518:	08 c1       	rjmp	.+528    	; 0x872a <_fpadd_parts+0x286>
    851a:	92 30       	cpi	r25, 0x02	; 2
    851c:	09 f4       	brne	.+2      	; 0x8520 <_fpadd_parts+0x7c>
    851e:	07 c1       	rjmp	.+526    	; 0x872e <_fpadd_parts+0x28a>
    8520:	12 96       	adiw	r26, 0x02	; 2
    8522:	2d 90       	ld	r2, X+
    8524:	3c 90       	ld	r3, X
    8526:	13 97       	sbiw	r26, 0x03	; 3
    8528:	eb 01       	movw	r28, r22
    852a:	8a 81       	ldd	r24, Y+2	; 0x02
    852c:	9b 81       	ldd	r25, Y+3	; 0x03
    852e:	14 96       	adiw	r26, 0x04	; 4
    8530:	ad 90       	ld	r10, X+
    8532:	bd 90       	ld	r11, X+
    8534:	cd 90       	ld	r12, X+
    8536:	dc 90       	ld	r13, X
    8538:	17 97       	sbiw	r26, 0x07	; 7
    853a:	ec 80       	ldd	r14, Y+4	; 0x04
    853c:	fd 80       	ldd	r15, Y+5	; 0x05
    853e:	0e 81       	ldd	r16, Y+6	; 0x06
    8540:	1f 81       	ldd	r17, Y+7	; 0x07
    8542:	91 01       	movw	r18, r2
    8544:	28 1b       	sub	r18, r24
    8546:	39 0b       	sbc	r19, r25
    8548:	b9 01       	movw	r22, r18
    854a:	37 ff       	sbrs	r19, 7
    854c:	04 c0       	rjmp	.+8      	; 0x8556 <_fpadd_parts+0xb2>
    854e:	66 27       	eor	r22, r22
    8550:	77 27       	eor	r23, r23
    8552:	62 1b       	sub	r22, r18
    8554:	73 0b       	sbc	r23, r19
    8556:	60 32       	cpi	r22, 0x20	; 32
    8558:	71 05       	cpc	r23, r1
    855a:	0c f0       	brlt	.+2      	; 0x855e <_fpadd_parts+0xba>
    855c:	61 c0       	rjmp	.+194    	; 0x8620 <_fpadd_parts+0x17c>
    855e:	12 16       	cp	r1, r18
    8560:	13 06       	cpc	r1, r19
    8562:	6c f5       	brge	.+90     	; 0x85be <_fpadd_parts+0x11a>
    8564:	37 01       	movw	r6, r14
    8566:	48 01       	movw	r8, r16
    8568:	06 2e       	mov	r0, r22
    856a:	04 c0       	rjmp	.+8      	; 0x8574 <_fpadd_parts+0xd0>
    856c:	96 94       	lsr	r9
    856e:	87 94       	ror	r8
    8570:	77 94       	ror	r7
    8572:	67 94       	ror	r6
    8574:	0a 94       	dec	r0
    8576:	d2 f7       	brpl	.-12     	; 0x856c <_fpadd_parts+0xc8>
    8578:	21 e0       	ldi	r18, 0x01	; 1
    857a:	30 e0       	ldi	r19, 0x00	; 0
    857c:	40 e0       	ldi	r20, 0x00	; 0
    857e:	50 e0       	ldi	r21, 0x00	; 0
    8580:	04 c0       	rjmp	.+8      	; 0x858a <_fpadd_parts+0xe6>
    8582:	22 0f       	add	r18, r18
    8584:	33 1f       	adc	r19, r19
    8586:	44 1f       	adc	r20, r20
    8588:	55 1f       	adc	r21, r21
    858a:	6a 95       	dec	r22
    858c:	d2 f7       	brpl	.-12     	; 0x8582 <_fpadd_parts+0xde>
    858e:	21 50       	subi	r18, 0x01	; 1
    8590:	30 40       	sbci	r19, 0x00	; 0
    8592:	40 40       	sbci	r20, 0x00	; 0
    8594:	50 40       	sbci	r21, 0x00	; 0
    8596:	2e 21       	and	r18, r14
    8598:	3f 21       	and	r19, r15
    859a:	40 23       	and	r20, r16
    859c:	51 23       	and	r21, r17
    859e:	21 15       	cp	r18, r1
    85a0:	31 05       	cpc	r19, r1
    85a2:	41 05       	cpc	r20, r1
    85a4:	51 05       	cpc	r21, r1
    85a6:	21 f0       	breq	.+8      	; 0x85b0 <_fpadd_parts+0x10c>
    85a8:	21 e0       	ldi	r18, 0x01	; 1
    85aa:	30 e0       	ldi	r19, 0x00	; 0
    85ac:	40 e0       	ldi	r20, 0x00	; 0
    85ae:	50 e0       	ldi	r21, 0x00	; 0
    85b0:	79 01       	movw	r14, r18
    85b2:	8a 01       	movw	r16, r20
    85b4:	e6 28       	or	r14, r6
    85b6:	f7 28       	or	r15, r7
    85b8:	08 29       	or	r16, r8
    85ba:	19 29       	or	r17, r9
    85bc:	3c c0       	rjmp	.+120    	; 0x8636 <_fpadd_parts+0x192>
    85be:	23 2b       	or	r18, r19
    85c0:	d1 f1       	breq	.+116    	; 0x8636 <_fpadd_parts+0x192>
    85c2:	26 0e       	add	r2, r22
    85c4:	37 1e       	adc	r3, r23
    85c6:	35 01       	movw	r6, r10
    85c8:	46 01       	movw	r8, r12
    85ca:	06 2e       	mov	r0, r22
    85cc:	04 c0       	rjmp	.+8      	; 0x85d6 <_fpadd_parts+0x132>
    85ce:	96 94       	lsr	r9
    85d0:	87 94       	ror	r8
    85d2:	77 94       	ror	r7
    85d4:	67 94       	ror	r6
    85d6:	0a 94       	dec	r0
    85d8:	d2 f7       	brpl	.-12     	; 0x85ce <_fpadd_parts+0x12a>
    85da:	21 e0       	ldi	r18, 0x01	; 1
    85dc:	30 e0       	ldi	r19, 0x00	; 0
    85de:	40 e0       	ldi	r20, 0x00	; 0
    85e0:	50 e0       	ldi	r21, 0x00	; 0
    85e2:	04 c0       	rjmp	.+8      	; 0x85ec <_fpadd_parts+0x148>
    85e4:	22 0f       	add	r18, r18
    85e6:	33 1f       	adc	r19, r19
    85e8:	44 1f       	adc	r20, r20
    85ea:	55 1f       	adc	r21, r21
    85ec:	6a 95       	dec	r22
    85ee:	d2 f7       	brpl	.-12     	; 0x85e4 <_fpadd_parts+0x140>
    85f0:	21 50       	subi	r18, 0x01	; 1
    85f2:	30 40       	sbci	r19, 0x00	; 0
    85f4:	40 40       	sbci	r20, 0x00	; 0
    85f6:	50 40       	sbci	r21, 0x00	; 0
    85f8:	2a 21       	and	r18, r10
    85fa:	3b 21       	and	r19, r11
    85fc:	4c 21       	and	r20, r12
    85fe:	5d 21       	and	r21, r13
    8600:	21 15       	cp	r18, r1
    8602:	31 05       	cpc	r19, r1
    8604:	41 05       	cpc	r20, r1
    8606:	51 05       	cpc	r21, r1
    8608:	21 f0       	breq	.+8      	; 0x8612 <_fpadd_parts+0x16e>
    860a:	21 e0       	ldi	r18, 0x01	; 1
    860c:	30 e0       	ldi	r19, 0x00	; 0
    860e:	40 e0       	ldi	r20, 0x00	; 0
    8610:	50 e0       	ldi	r21, 0x00	; 0
    8612:	59 01       	movw	r10, r18
    8614:	6a 01       	movw	r12, r20
    8616:	a6 28       	or	r10, r6
    8618:	b7 28       	or	r11, r7
    861a:	c8 28       	or	r12, r8
    861c:	d9 28       	or	r13, r9
    861e:	0b c0       	rjmp	.+22     	; 0x8636 <_fpadd_parts+0x192>
    8620:	82 15       	cp	r24, r2
    8622:	93 05       	cpc	r25, r3
    8624:	2c f0       	brlt	.+10     	; 0x8630 <_fpadd_parts+0x18c>
    8626:	1c 01       	movw	r2, r24
    8628:	aa 24       	eor	r10, r10
    862a:	bb 24       	eor	r11, r11
    862c:	65 01       	movw	r12, r10
    862e:	03 c0       	rjmp	.+6      	; 0x8636 <_fpadd_parts+0x192>
    8630:	ee 24       	eor	r14, r14
    8632:	ff 24       	eor	r15, r15
    8634:	87 01       	movw	r16, r14
    8636:	11 96       	adiw	r26, 0x01	; 1
    8638:	9c 91       	ld	r25, X
    863a:	d2 01       	movw	r26, r4
    863c:	11 96       	adiw	r26, 0x01	; 1
    863e:	8c 91       	ld	r24, X
    8640:	98 17       	cp	r25, r24
    8642:	09 f4       	brne	.+2      	; 0x8646 <_fpadd_parts+0x1a2>
    8644:	45 c0       	rjmp	.+138    	; 0x86d0 <_fpadd_parts+0x22c>
    8646:	99 23       	and	r25, r25
    8648:	39 f0       	breq	.+14     	; 0x8658 <_fpadd_parts+0x1b4>
    864a:	a8 01       	movw	r20, r16
    864c:	97 01       	movw	r18, r14
    864e:	2a 19       	sub	r18, r10
    8650:	3b 09       	sbc	r19, r11
    8652:	4c 09       	sbc	r20, r12
    8654:	5d 09       	sbc	r21, r13
    8656:	06 c0       	rjmp	.+12     	; 0x8664 <_fpadd_parts+0x1c0>
    8658:	a6 01       	movw	r20, r12
    865a:	95 01       	movw	r18, r10
    865c:	2e 19       	sub	r18, r14
    865e:	3f 09       	sbc	r19, r15
    8660:	40 0b       	sbc	r20, r16
    8662:	51 0b       	sbc	r21, r17
    8664:	57 fd       	sbrc	r21, 7
    8666:	08 c0       	rjmp	.+16     	; 0x8678 <_fpadd_parts+0x1d4>
    8668:	11 82       	std	Z+1, r1	; 0x01
    866a:	22 82       	std	Z+2, r2	; 0x02
    866c:	33 82       	std	Z+3, r3	; 0x03
    866e:	24 83       	std	Z+4, r18	; 0x04
    8670:	35 83       	std	Z+5, r19	; 0x05
    8672:	46 83       	std	Z+6, r20	; 0x06
    8674:	57 83       	std	Z+7, r21	; 0x07
    8676:	1d c0       	rjmp	.+58     	; 0x86b2 <_fpadd_parts+0x20e>
    8678:	81 e0       	ldi	r24, 0x01	; 1
    867a:	81 83       	std	Z+1, r24	; 0x01
    867c:	22 82       	std	Z+2, r2	; 0x02
    867e:	33 82       	std	Z+3, r3	; 0x03
    8680:	88 27       	eor	r24, r24
    8682:	99 27       	eor	r25, r25
    8684:	dc 01       	movw	r26, r24
    8686:	82 1b       	sub	r24, r18
    8688:	93 0b       	sbc	r25, r19
    868a:	a4 0b       	sbc	r26, r20
    868c:	b5 0b       	sbc	r27, r21
    868e:	84 83       	std	Z+4, r24	; 0x04
    8690:	95 83       	std	Z+5, r25	; 0x05
    8692:	a6 83       	std	Z+6, r26	; 0x06
    8694:	b7 83       	std	Z+7, r27	; 0x07
    8696:	0d c0       	rjmp	.+26     	; 0x86b2 <_fpadd_parts+0x20e>
    8698:	22 0f       	add	r18, r18
    869a:	33 1f       	adc	r19, r19
    869c:	44 1f       	adc	r20, r20
    869e:	55 1f       	adc	r21, r21
    86a0:	24 83       	std	Z+4, r18	; 0x04
    86a2:	35 83       	std	Z+5, r19	; 0x05
    86a4:	46 83       	std	Z+6, r20	; 0x06
    86a6:	57 83       	std	Z+7, r21	; 0x07
    86a8:	82 81       	ldd	r24, Z+2	; 0x02
    86aa:	93 81       	ldd	r25, Z+3	; 0x03
    86ac:	01 97       	sbiw	r24, 0x01	; 1
    86ae:	82 83       	std	Z+2, r24	; 0x02
    86b0:	93 83       	std	Z+3, r25	; 0x03
    86b2:	24 81       	ldd	r18, Z+4	; 0x04
    86b4:	35 81       	ldd	r19, Z+5	; 0x05
    86b6:	46 81       	ldd	r20, Z+6	; 0x06
    86b8:	57 81       	ldd	r21, Z+7	; 0x07
    86ba:	da 01       	movw	r26, r20
    86bc:	c9 01       	movw	r24, r18
    86be:	01 97       	sbiw	r24, 0x01	; 1
    86c0:	a1 09       	sbc	r26, r1
    86c2:	b1 09       	sbc	r27, r1
    86c4:	8f 5f       	subi	r24, 0xFF	; 255
    86c6:	9f 4f       	sbci	r25, 0xFF	; 255
    86c8:	af 4f       	sbci	r26, 0xFF	; 255
    86ca:	bf 43       	sbci	r27, 0x3F	; 63
    86cc:	28 f3       	brcs	.-54     	; 0x8698 <_fpadd_parts+0x1f4>
    86ce:	0b c0       	rjmp	.+22     	; 0x86e6 <_fpadd_parts+0x242>
    86d0:	91 83       	std	Z+1, r25	; 0x01
    86d2:	22 82       	std	Z+2, r2	; 0x02
    86d4:	33 82       	std	Z+3, r3	; 0x03
    86d6:	ea 0c       	add	r14, r10
    86d8:	fb 1c       	adc	r15, r11
    86da:	0c 1d       	adc	r16, r12
    86dc:	1d 1d       	adc	r17, r13
    86de:	e4 82       	std	Z+4, r14	; 0x04
    86e0:	f5 82       	std	Z+5, r15	; 0x05
    86e2:	06 83       	std	Z+6, r16	; 0x06
    86e4:	17 83       	std	Z+7, r17	; 0x07
    86e6:	83 e0       	ldi	r24, 0x03	; 3
    86e8:	80 83       	st	Z, r24
    86ea:	24 81       	ldd	r18, Z+4	; 0x04
    86ec:	35 81       	ldd	r19, Z+5	; 0x05
    86ee:	46 81       	ldd	r20, Z+6	; 0x06
    86f0:	57 81       	ldd	r21, Z+7	; 0x07
    86f2:	57 ff       	sbrs	r21, 7
    86f4:	1a c0       	rjmp	.+52     	; 0x872a <_fpadd_parts+0x286>
    86f6:	c9 01       	movw	r24, r18
    86f8:	aa 27       	eor	r26, r26
    86fa:	97 fd       	sbrc	r25, 7
    86fc:	a0 95       	com	r26
    86fe:	ba 2f       	mov	r27, r26
    8700:	81 70       	andi	r24, 0x01	; 1
    8702:	90 70       	andi	r25, 0x00	; 0
    8704:	a0 70       	andi	r26, 0x00	; 0
    8706:	b0 70       	andi	r27, 0x00	; 0
    8708:	56 95       	lsr	r21
    870a:	47 95       	ror	r20
    870c:	37 95       	ror	r19
    870e:	27 95       	ror	r18
    8710:	82 2b       	or	r24, r18
    8712:	93 2b       	or	r25, r19
    8714:	a4 2b       	or	r26, r20
    8716:	b5 2b       	or	r27, r21
    8718:	84 83       	std	Z+4, r24	; 0x04
    871a:	95 83       	std	Z+5, r25	; 0x05
    871c:	a6 83       	std	Z+6, r26	; 0x06
    871e:	b7 83       	std	Z+7, r27	; 0x07
    8720:	82 81       	ldd	r24, Z+2	; 0x02
    8722:	93 81       	ldd	r25, Z+3	; 0x03
    8724:	01 96       	adiw	r24, 0x01	; 1
    8726:	82 83       	std	Z+2, r24	; 0x02
    8728:	93 83       	std	Z+3, r25	; 0x03
    872a:	df 01       	movw	r26, r30
    872c:	01 c0       	rjmp	.+2      	; 0x8730 <_fpadd_parts+0x28c>
    872e:	d2 01       	movw	r26, r4
    8730:	cd 01       	movw	r24, r26
    8732:	cd b7       	in	r28, 0x3d	; 61
    8734:	de b7       	in	r29, 0x3e	; 62
    8736:	e2 e1       	ldi	r30, 0x12	; 18
    8738:	0c 94 cd 49 	jmp	0x939a	; 0x939a <__epilogue_restores__>

0000873c <__subsf3>:
    873c:	a0 e2       	ldi	r26, 0x20	; 32
    873e:	b0 e0       	ldi	r27, 0x00	; 0
    8740:	e4 ea       	ldi	r30, 0xA4	; 164
    8742:	f3 e4       	ldi	r31, 0x43	; 67
    8744:	0c 94 bd 49 	jmp	0x937a	; 0x937a <__prologue_saves__+0x18>
    8748:	69 83       	std	Y+1, r22	; 0x01
    874a:	7a 83       	std	Y+2, r23	; 0x02
    874c:	8b 83       	std	Y+3, r24	; 0x03
    874e:	9c 83       	std	Y+4, r25	; 0x04
    8750:	2d 83       	std	Y+5, r18	; 0x05
    8752:	3e 83       	std	Y+6, r19	; 0x06
    8754:	4f 83       	std	Y+7, r20	; 0x07
    8756:	58 87       	std	Y+8, r21	; 0x08
    8758:	e9 e0       	ldi	r30, 0x09	; 9
    875a:	ee 2e       	mov	r14, r30
    875c:	f1 2c       	mov	r15, r1
    875e:	ec 0e       	add	r14, r28
    8760:	fd 1e       	adc	r15, r29
    8762:	ce 01       	movw	r24, r28
    8764:	01 96       	adiw	r24, 0x01	; 1
    8766:	b7 01       	movw	r22, r14
    8768:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    876c:	8e 01       	movw	r16, r28
    876e:	0f 5e       	subi	r16, 0xEF	; 239
    8770:	1f 4f       	sbci	r17, 0xFF	; 255
    8772:	ce 01       	movw	r24, r28
    8774:	05 96       	adiw	r24, 0x05	; 5
    8776:	b8 01       	movw	r22, r16
    8778:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    877c:	8a 89       	ldd	r24, Y+18	; 0x12
    877e:	91 e0       	ldi	r25, 0x01	; 1
    8780:	89 27       	eor	r24, r25
    8782:	8a 8b       	std	Y+18, r24	; 0x12
    8784:	c7 01       	movw	r24, r14
    8786:	b8 01       	movw	r22, r16
    8788:	ae 01       	movw	r20, r28
    878a:	47 5e       	subi	r20, 0xE7	; 231
    878c:	5f 4f       	sbci	r21, 0xFF	; 255
    878e:	0e 94 52 42 	call	0x84a4	; 0x84a4 <_fpadd_parts>
    8792:	0e 94 7c 47 	call	0x8ef8	; 0x8ef8 <__pack_f>
    8796:	a0 96       	adiw	r28, 0x20	; 32
    8798:	e6 e0       	ldi	r30, 0x06	; 6
    879a:	0c 94 d9 49 	jmp	0x93b2	; 0x93b2 <__epilogue_restores__+0x18>

0000879e <__addsf3>:
    879e:	a0 e2       	ldi	r26, 0x20	; 32
    87a0:	b0 e0       	ldi	r27, 0x00	; 0
    87a2:	e5 ed       	ldi	r30, 0xD5	; 213
    87a4:	f3 e4       	ldi	r31, 0x43	; 67
    87a6:	0c 94 bd 49 	jmp	0x937a	; 0x937a <__prologue_saves__+0x18>
    87aa:	69 83       	std	Y+1, r22	; 0x01
    87ac:	7a 83       	std	Y+2, r23	; 0x02
    87ae:	8b 83       	std	Y+3, r24	; 0x03
    87b0:	9c 83       	std	Y+4, r25	; 0x04
    87b2:	2d 83       	std	Y+5, r18	; 0x05
    87b4:	3e 83       	std	Y+6, r19	; 0x06
    87b6:	4f 83       	std	Y+7, r20	; 0x07
    87b8:	58 87       	std	Y+8, r21	; 0x08
    87ba:	f9 e0       	ldi	r31, 0x09	; 9
    87bc:	ef 2e       	mov	r14, r31
    87be:	f1 2c       	mov	r15, r1
    87c0:	ec 0e       	add	r14, r28
    87c2:	fd 1e       	adc	r15, r29
    87c4:	ce 01       	movw	r24, r28
    87c6:	01 96       	adiw	r24, 0x01	; 1
    87c8:	b7 01       	movw	r22, r14
    87ca:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    87ce:	8e 01       	movw	r16, r28
    87d0:	0f 5e       	subi	r16, 0xEF	; 239
    87d2:	1f 4f       	sbci	r17, 0xFF	; 255
    87d4:	ce 01       	movw	r24, r28
    87d6:	05 96       	adiw	r24, 0x05	; 5
    87d8:	b8 01       	movw	r22, r16
    87da:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    87de:	c7 01       	movw	r24, r14
    87e0:	b8 01       	movw	r22, r16
    87e2:	ae 01       	movw	r20, r28
    87e4:	47 5e       	subi	r20, 0xE7	; 231
    87e6:	5f 4f       	sbci	r21, 0xFF	; 255
    87e8:	0e 94 52 42 	call	0x84a4	; 0x84a4 <_fpadd_parts>
    87ec:	0e 94 7c 47 	call	0x8ef8	; 0x8ef8 <__pack_f>
    87f0:	a0 96       	adiw	r28, 0x20	; 32
    87f2:	e6 e0       	ldi	r30, 0x06	; 6
    87f4:	0c 94 d9 49 	jmp	0x93b2	; 0x93b2 <__epilogue_restores__+0x18>

000087f8 <__mulsf3>:
    87f8:	a0 e2       	ldi	r26, 0x20	; 32
    87fa:	b0 e0       	ldi	r27, 0x00	; 0
    87fc:	e2 e0       	ldi	r30, 0x02	; 2
    87fe:	f4 e4       	ldi	r31, 0x44	; 68
    8800:	0c 94 b1 49 	jmp	0x9362	; 0x9362 <__prologue_saves__>
    8804:	69 83       	std	Y+1, r22	; 0x01
    8806:	7a 83       	std	Y+2, r23	; 0x02
    8808:	8b 83       	std	Y+3, r24	; 0x03
    880a:	9c 83       	std	Y+4, r25	; 0x04
    880c:	2d 83       	std	Y+5, r18	; 0x05
    880e:	3e 83       	std	Y+6, r19	; 0x06
    8810:	4f 83       	std	Y+7, r20	; 0x07
    8812:	58 87       	std	Y+8, r21	; 0x08
    8814:	ce 01       	movw	r24, r28
    8816:	01 96       	adiw	r24, 0x01	; 1
    8818:	be 01       	movw	r22, r28
    881a:	67 5f       	subi	r22, 0xF7	; 247
    881c:	7f 4f       	sbci	r23, 0xFF	; 255
    881e:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8822:	ce 01       	movw	r24, r28
    8824:	05 96       	adiw	r24, 0x05	; 5
    8826:	be 01       	movw	r22, r28
    8828:	6f 5e       	subi	r22, 0xEF	; 239
    882a:	7f 4f       	sbci	r23, 0xFF	; 255
    882c:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8830:	99 85       	ldd	r25, Y+9	; 0x09
    8832:	92 30       	cpi	r25, 0x02	; 2
    8834:	88 f0       	brcs	.+34     	; 0x8858 <__mulsf3+0x60>
    8836:	89 89       	ldd	r24, Y+17	; 0x11
    8838:	82 30       	cpi	r24, 0x02	; 2
    883a:	c8 f0       	brcs	.+50     	; 0x886e <__mulsf3+0x76>
    883c:	94 30       	cpi	r25, 0x04	; 4
    883e:	19 f4       	brne	.+6      	; 0x8846 <__mulsf3+0x4e>
    8840:	82 30       	cpi	r24, 0x02	; 2
    8842:	51 f4       	brne	.+20     	; 0x8858 <__mulsf3+0x60>
    8844:	04 c0       	rjmp	.+8      	; 0x884e <__mulsf3+0x56>
    8846:	84 30       	cpi	r24, 0x04	; 4
    8848:	29 f4       	brne	.+10     	; 0x8854 <__mulsf3+0x5c>
    884a:	92 30       	cpi	r25, 0x02	; 2
    884c:	81 f4       	brne	.+32     	; 0x886e <__mulsf3+0x76>
    884e:	8b e1       	ldi	r24, 0x1B	; 27
    8850:	95 e2       	ldi	r25, 0x25	; 37
    8852:	c6 c0       	rjmp	.+396    	; 0x89e0 <__mulsf3+0x1e8>
    8854:	92 30       	cpi	r25, 0x02	; 2
    8856:	49 f4       	brne	.+18     	; 0x886a <__mulsf3+0x72>
    8858:	20 e0       	ldi	r18, 0x00	; 0
    885a:	9a 85       	ldd	r25, Y+10	; 0x0a
    885c:	8a 89       	ldd	r24, Y+18	; 0x12
    885e:	98 13       	cpse	r25, r24
    8860:	21 e0       	ldi	r18, 0x01	; 1
    8862:	2a 87       	std	Y+10, r18	; 0x0a
    8864:	ce 01       	movw	r24, r28
    8866:	09 96       	adiw	r24, 0x09	; 9
    8868:	bb c0       	rjmp	.+374    	; 0x89e0 <__mulsf3+0x1e8>
    886a:	82 30       	cpi	r24, 0x02	; 2
    886c:	49 f4       	brne	.+18     	; 0x8880 <__mulsf3+0x88>
    886e:	20 e0       	ldi	r18, 0x00	; 0
    8870:	9a 85       	ldd	r25, Y+10	; 0x0a
    8872:	8a 89       	ldd	r24, Y+18	; 0x12
    8874:	98 13       	cpse	r25, r24
    8876:	21 e0       	ldi	r18, 0x01	; 1
    8878:	2a 8b       	std	Y+18, r18	; 0x12
    887a:	ce 01       	movw	r24, r28
    887c:	41 96       	adiw	r24, 0x11	; 17
    887e:	b0 c0       	rjmp	.+352    	; 0x89e0 <__mulsf3+0x1e8>
    8880:	2d 84       	ldd	r2, Y+13	; 0x0d
    8882:	3e 84       	ldd	r3, Y+14	; 0x0e
    8884:	4f 84       	ldd	r4, Y+15	; 0x0f
    8886:	58 88       	ldd	r5, Y+16	; 0x10
    8888:	6d 88       	ldd	r6, Y+21	; 0x15
    888a:	7e 88       	ldd	r7, Y+22	; 0x16
    888c:	8f 88       	ldd	r8, Y+23	; 0x17
    888e:	98 8c       	ldd	r9, Y+24	; 0x18
    8890:	ee 24       	eor	r14, r14
    8892:	ff 24       	eor	r15, r15
    8894:	87 01       	movw	r16, r14
    8896:	aa 24       	eor	r10, r10
    8898:	bb 24       	eor	r11, r11
    889a:	65 01       	movw	r12, r10
    889c:	40 e0       	ldi	r20, 0x00	; 0
    889e:	50 e0       	ldi	r21, 0x00	; 0
    88a0:	60 e0       	ldi	r22, 0x00	; 0
    88a2:	70 e0       	ldi	r23, 0x00	; 0
    88a4:	e0 e0       	ldi	r30, 0x00	; 0
    88a6:	f0 e0       	ldi	r31, 0x00	; 0
    88a8:	c1 01       	movw	r24, r2
    88aa:	81 70       	andi	r24, 0x01	; 1
    88ac:	90 70       	andi	r25, 0x00	; 0
    88ae:	89 2b       	or	r24, r25
    88b0:	e9 f0       	breq	.+58     	; 0x88ec <__mulsf3+0xf4>
    88b2:	e6 0c       	add	r14, r6
    88b4:	f7 1c       	adc	r15, r7
    88b6:	08 1d       	adc	r16, r8
    88b8:	19 1d       	adc	r17, r9
    88ba:	9a 01       	movw	r18, r20
    88bc:	ab 01       	movw	r20, r22
    88be:	2a 0d       	add	r18, r10
    88c0:	3b 1d       	adc	r19, r11
    88c2:	4c 1d       	adc	r20, r12
    88c4:	5d 1d       	adc	r21, r13
    88c6:	80 e0       	ldi	r24, 0x00	; 0
    88c8:	90 e0       	ldi	r25, 0x00	; 0
    88ca:	a0 e0       	ldi	r26, 0x00	; 0
    88cc:	b0 e0       	ldi	r27, 0x00	; 0
    88ce:	e6 14       	cp	r14, r6
    88d0:	f7 04       	cpc	r15, r7
    88d2:	08 05       	cpc	r16, r8
    88d4:	19 05       	cpc	r17, r9
    88d6:	20 f4       	brcc	.+8      	; 0x88e0 <__mulsf3+0xe8>
    88d8:	81 e0       	ldi	r24, 0x01	; 1
    88da:	90 e0       	ldi	r25, 0x00	; 0
    88dc:	a0 e0       	ldi	r26, 0x00	; 0
    88de:	b0 e0       	ldi	r27, 0x00	; 0
    88e0:	ba 01       	movw	r22, r20
    88e2:	a9 01       	movw	r20, r18
    88e4:	48 0f       	add	r20, r24
    88e6:	59 1f       	adc	r21, r25
    88e8:	6a 1f       	adc	r22, r26
    88ea:	7b 1f       	adc	r23, r27
    88ec:	aa 0c       	add	r10, r10
    88ee:	bb 1c       	adc	r11, r11
    88f0:	cc 1c       	adc	r12, r12
    88f2:	dd 1c       	adc	r13, r13
    88f4:	97 fe       	sbrs	r9, 7
    88f6:	08 c0       	rjmp	.+16     	; 0x8908 <__mulsf3+0x110>
    88f8:	81 e0       	ldi	r24, 0x01	; 1
    88fa:	90 e0       	ldi	r25, 0x00	; 0
    88fc:	a0 e0       	ldi	r26, 0x00	; 0
    88fe:	b0 e0       	ldi	r27, 0x00	; 0
    8900:	a8 2a       	or	r10, r24
    8902:	b9 2a       	or	r11, r25
    8904:	ca 2a       	or	r12, r26
    8906:	db 2a       	or	r13, r27
    8908:	31 96       	adiw	r30, 0x01	; 1
    890a:	e0 32       	cpi	r30, 0x20	; 32
    890c:	f1 05       	cpc	r31, r1
    890e:	49 f0       	breq	.+18     	; 0x8922 <__mulsf3+0x12a>
    8910:	66 0c       	add	r6, r6
    8912:	77 1c       	adc	r7, r7
    8914:	88 1c       	adc	r8, r8
    8916:	99 1c       	adc	r9, r9
    8918:	56 94       	lsr	r5
    891a:	47 94       	ror	r4
    891c:	37 94       	ror	r3
    891e:	27 94       	ror	r2
    8920:	c3 cf       	rjmp	.-122    	; 0x88a8 <__mulsf3+0xb0>
    8922:	fa 85       	ldd	r31, Y+10	; 0x0a
    8924:	ea 89       	ldd	r30, Y+18	; 0x12
    8926:	2b 89       	ldd	r18, Y+19	; 0x13
    8928:	3c 89       	ldd	r19, Y+20	; 0x14
    892a:	8b 85       	ldd	r24, Y+11	; 0x0b
    892c:	9c 85       	ldd	r25, Y+12	; 0x0c
    892e:	28 0f       	add	r18, r24
    8930:	39 1f       	adc	r19, r25
    8932:	2e 5f       	subi	r18, 0xFE	; 254
    8934:	3f 4f       	sbci	r19, 0xFF	; 255
    8936:	17 c0       	rjmp	.+46     	; 0x8966 <__mulsf3+0x16e>
    8938:	ca 01       	movw	r24, r20
    893a:	81 70       	andi	r24, 0x01	; 1
    893c:	90 70       	andi	r25, 0x00	; 0
    893e:	89 2b       	or	r24, r25
    8940:	61 f0       	breq	.+24     	; 0x895a <__mulsf3+0x162>
    8942:	16 95       	lsr	r17
    8944:	07 95       	ror	r16
    8946:	f7 94       	ror	r15
    8948:	e7 94       	ror	r14
    894a:	80 e0       	ldi	r24, 0x00	; 0
    894c:	90 e0       	ldi	r25, 0x00	; 0
    894e:	a0 e0       	ldi	r26, 0x00	; 0
    8950:	b0 e8       	ldi	r27, 0x80	; 128
    8952:	e8 2a       	or	r14, r24
    8954:	f9 2a       	or	r15, r25
    8956:	0a 2b       	or	r16, r26
    8958:	1b 2b       	or	r17, r27
    895a:	76 95       	lsr	r23
    895c:	67 95       	ror	r22
    895e:	57 95       	ror	r21
    8960:	47 95       	ror	r20
    8962:	2f 5f       	subi	r18, 0xFF	; 255
    8964:	3f 4f       	sbci	r19, 0xFF	; 255
    8966:	77 fd       	sbrc	r23, 7
    8968:	e7 cf       	rjmp	.-50     	; 0x8938 <__mulsf3+0x140>
    896a:	0c c0       	rjmp	.+24     	; 0x8984 <__mulsf3+0x18c>
    896c:	44 0f       	add	r20, r20
    896e:	55 1f       	adc	r21, r21
    8970:	66 1f       	adc	r22, r22
    8972:	77 1f       	adc	r23, r23
    8974:	17 fd       	sbrc	r17, 7
    8976:	41 60       	ori	r20, 0x01	; 1
    8978:	ee 0c       	add	r14, r14
    897a:	ff 1c       	adc	r15, r15
    897c:	00 1f       	adc	r16, r16
    897e:	11 1f       	adc	r17, r17
    8980:	21 50       	subi	r18, 0x01	; 1
    8982:	30 40       	sbci	r19, 0x00	; 0
    8984:	40 30       	cpi	r20, 0x00	; 0
    8986:	90 e0       	ldi	r25, 0x00	; 0
    8988:	59 07       	cpc	r21, r25
    898a:	90 e0       	ldi	r25, 0x00	; 0
    898c:	69 07       	cpc	r22, r25
    898e:	90 e4       	ldi	r25, 0x40	; 64
    8990:	79 07       	cpc	r23, r25
    8992:	60 f3       	brcs	.-40     	; 0x896c <__mulsf3+0x174>
    8994:	2b 8f       	std	Y+27, r18	; 0x1b
    8996:	3c 8f       	std	Y+28, r19	; 0x1c
    8998:	db 01       	movw	r26, r22
    899a:	ca 01       	movw	r24, r20
    899c:	8f 77       	andi	r24, 0x7F	; 127
    899e:	90 70       	andi	r25, 0x00	; 0
    89a0:	a0 70       	andi	r26, 0x00	; 0
    89a2:	b0 70       	andi	r27, 0x00	; 0
    89a4:	80 34       	cpi	r24, 0x40	; 64
    89a6:	91 05       	cpc	r25, r1
    89a8:	a1 05       	cpc	r26, r1
    89aa:	b1 05       	cpc	r27, r1
    89ac:	61 f4       	brne	.+24     	; 0x89c6 <__mulsf3+0x1ce>
    89ae:	47 fd       	sbrc	r20, 7
    89b0:	0a c0       	rjmp	.+20     	; 0x89c6 <__mulsf3+0x1ce>
    89b2:	e1 14       	cp	r14, r1
    89b4:	f1 04       	cpc	r15, r1
    89b6:	01 05       	cpc	r16, r1
    89b8:	11 05       	cpc	r17, r1
    89ba:	29 f0       	breq	.+10     	; 0x89c6 <__mulsf3+0x1ce>
    89bc:	40 5c       	subi	r20, 0xC0	; 192
    89be:	5f 4f       	sbci	r21, 0xFF	; 255
    89c0:	6f 4f       	sbci	r22, 0xFF	; 255
    89c2:	7f 4f       	sbci	r23, 0xFF	; 255
    89c4:	40 78       	andi	r20, 0x80	; 128
    89c6:	1a 8e       	std	Y+26, r1	; 0x1a
    89c8:	fe 17       	cp	r31, r30
    89ca:	11 f0       	breq	.+4      	; 0x89d0 <__mulsf3+0x1d8>
    89cc:	81 e0       	ldi	r24, 0x01	; 1
    89ce:	8a 8f       	std	Y+26, r24	; 0x1a
    89d0:	4d 8f       	std	Y+29, r20	; 0x1d
    89d2:	5e 8f       	std	Y+30, r21	; 0x1e
    89d4:	6f 8f       	std	Y+31, r22	; 0x1f
    89d6:	78 a3       	std	Y+32, r23	; 0x20
    89d8:	83 e0       	ldi	r24, 0x03	; 3
    89da:	89 8f       	std	Y+25, r24	; 0x19
    89dc:	ce 01       	movw	r24, r28
    89de:	49 96       	adiw	r24, 0x19	; 25
    89e0:	0e 94 7c 47 	call	0x8ef8	; 0x8ef8 <__pack_f>
    89e4:	a0 96       	adiw	r28, 0x20	; 32
    89e6:	e2 e1       	ldi	r30, 0x12	; 18
    89e8:	0c 94 cd 49 	jmp	0x939a	; 0x939a <__epilogue_restores__>

000089ec <__divsf3>:
    89ec:	a8 e1       	ldi	r26, 0x18	; 24
    89ee:	b0 e0       	ldi	r27, 0x00	; 0
    89f0:	ec ef       	ldi	r30, 0xFC	; 252
    89f2:	f4 e4       	ldi	r31, 0x44	; 68
    89f4:	0c 94 b9 49 	jmp	0x9372	; 0x9372 <__prologue_saves__+0x10>
    89f8:	69 83       	std	Y+1, r22	; 0x01
    89fa:	7a 83       	std	Y+2, r23	; 0x02
    89fc:	8b 83       	std	Y+3, r24	; 0x03
    89fe:	9c 83       	std	Y+4, r25	; 0x04
    8a00:	2d 83       	std	Y+5, r18	; 0x05
    8a02:	3e 83       	std	Y+6, r19	; 0x06
    8a04:	4f 83       	std	Y+7, r20	; 0x07
    8a06:	58 87       	std	Y+8, r21	; 0x08
    8a08:	b9 e0       	ldi	r27, 0x09	; 9
    8a0a:	eb 2e       	mov	r14, r27
    8a0c:	f1 2c       	mov	r15, r1
    8a0e:	ec 0e       	add	r14, r28
    8a10:	fd 1e       	adc	r15, r29
    8a12:	ce 01       	movw	r24, r28
    8a14:	01 96       	adiw	r24, 0x01	; 1
    8a16:	b7 01       	movw	r22, r14
    8a18:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8a1c:	8e 01       	movw	r16, r28
    8a1e:	0f 5e       	subi	r16, 0xEF	; 239
    8a20:	1f 4f       	sbci	r17, 0xFF	; 255
    8a22:	ce 01       	movw	r24, r28
    8a24:	05 96       	adiw	r24, 0x05	; 5
    8a26:	b8 01       	movw	r22, r16
    8a28:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8a2c:	29 85       	ldd	r18, Y+9	; 0x09
    8a2e:	22 30       	cpi	r18, 0x02	; 2
    8a30:	08 f4       	brcc	.+2      	; 0x8a34 <__divsf3+0x48>
    8a32:	7e c0       	rjmp	.+252    	; 0x8b30 <__divsf3+0x144>
    8a34:	39 89       	ldd	r19, Y+17	; 0x11
    8a36:	32 30       	cpi	r19, 0x02	; 2
    8a38:	10 f4       	brcc	.+4      	; 0x8a3e <__divsf3+0x52>
    8a3a:	b8 01       	movw	r22, r16
    8a3c:	7c c0       	rjmp	.+248    	; 0x8b36 <__divsf3+0x14a>
    8a3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    8a40:	9a 89       	ldd	r25, Y+18	; 0x12
    8a42:	89 27       	eor	r24, r25
    8a44:	8a 87       	std	Y+10, r24	; 0x0a
    8a46:	24 30       	cpi	r18, 0x04	; 4
    8a48:	11 f0       	breq	.+4      	; 0x8a4e <__divsf3+0x62>
    8a4a:	22 30       	cpi	r18, 0x02	; 2
    8a4c:	31 f4       	brne	.+12     	; 0x8a5a <__divsf3+0x6e>
    8a4e:	23 17       	cp	r18, r19
    8a50:	09 f0       	breq	.+2      	; 0x8a54 <__divsf3+0x68>
    8a52:	6e c0       	rjmp	.+220    	; 0x8b30 <__divsf3+0x144>
    8a54:	6b e1       	ldi	r22, 0x1B	; 27
    8a56:	75 e2       	ldi	r23, 0x25	; 37
    8a58:	6e c0       	rjmp	.+220    	; 0x8b36 <__divsf3+0x14a>
    8a5a:	34 30       	cpi	r19, 0x04	; 4
    8a5c:	39 f4       	brne	.+14     	; 0x8a6c <__divsf3+0x80>
    8a5e:	1d 86       	std	Y+13, r1	; 0x0d
    8a60:	1e 86       	std	Y+14, r1	; 0x0e
    8a62:	1f 86       	std	Y+15, r1	; 0x0f
    8a64:	18 8a       	std	Y+16, r1	; 0x10
    8a66:	1b 86       	std	Y+11, r1	; 0x0b
    8a68:	1c 86       	std	Y+12, r1	; 0x0c
    8a6a:	04 c0       	rjmp	.+8      	; 0x8a74 <__divsf3+0x88>
    8a6c:	32 30       	cpi	r19, 0x02	; 2
    8a6e:	21 f4       	brne	.+8      	; 0x8a78 <__divsf3+0x8c>
    8a70:	84 e0       	ldi	r24, 0x04	; 4
    8a72:	89 87       	std	Y+9, r24	; 0x09
    8a74:	b7 01       	movw	r22, r14
    8a76:	5f c0       	rjmp	.+190    	; 0x8b36 <__divsf3+0x14a>
    8a78:	2b 85       	ldd	r18, Y+11	; 0x0b
    8a7a:	3c 85       	ldd	r19, Y+12	; 0x0c
    8a7c:	8b 89       	ldd	r24, Y+19	; 0x13
    8a7e:	9c 89       	ldd	r25, Y+20	; 0x14
    8a80:	28 1b       	sub	r18, r24
    8a82:	39 0b       	sbc	r19, r25
    8a84:	2b 87       	std	Y+11, r18	; 0x0b
    8a86:	3c 87       	std	Y+12, r19	; 0x0c
    8a88:	ed 84       	ldd	r14, Y+13	; 0x0d
    8a8a:	fe 84       	ldd	r15, Y+14	; 0x0e
    8a8c:	0f 85       	ldd	r16, Y+15	; 0x0f
    8a8e:	18 89       	ldd	r17, Y+16	; 0x10
    8a90:	ad 88       	ldd	r10, Y+21	; 0x15
    8a92:	be 88       	ldd	r11, Y+22	; 0x16
    8a94:	cf 88       	ldd	r12, Y+23	; 0x17
    8a96:	d8 8c       	ldd	r13, Y+24	; 0x18
    8a98:	ea 14       	cp	r14, r10
    8a9a:	fb 04       	cpc	r15, r11
    8a9c:	0c 05       	cpc	r16, r12
    8a9e:	1d 05       	cpc	r17, r13
    8aa0:	40 f4       	brcc	.+16     	; 0x8ab2 <__divsf3+0xc6>
    8aa2:	ee 0c       	add	r14, r14
    8aa4:	ff 1c       	adc	r15, r15
    8aa6:	00 1f       	adc	r16, r16
    8aa8:	11 1f       	adc	r17, r17
    8aaa:	21 50       	subi	r18, 0x01	; 1
    8aac:	30 40       	sbci	r19, 0x00	; 0
    8aae:	2b 87       	std	Y+11, r18	; 0x0b
    8ab0:	3c 87       	std	Y+12, r19	; 0x0c
    8ab2:	20 e0       	ldi	r18, 0x00	; 0
    8ab4:	30 e0       	ldi	r19, 0x00	; 0
    8ab6:	40 e0       	ldi	r20, 0x00	; 0
    8ab8:	50 e0       	ldi	r21, 0x00	; 0
    8aba:	80 e0       	ldi	r24, 0x00	; 0
    8abc:	90 e0       	ldi	r25, 0x00	; 0
    8abe:	a0 e0       	ldi	r26, 0x00	; 0
    8ac0:	b0 e4       	ldi	r27, 0x40	; 64
    8ac2:	60 e0       	ldi	r22, 0x00	; 0
    8ac4:	70 e0       	ldi	r23, 0x00	; 0
    8ac6:	ea 14       	cp	r14, r10
    8ac8:	fb 04       	cpc	r15, r11
    8aca:	0c 05       	cpc	r16, r12
    8acc:	1d 05       	cpc	r17, r13
    8ace:	40 f0       	brcs	.+16     	; 0x8ae0 <__divsf3+0xf4>
    8ad0:	28 2b       	or	r18, r24
    8ad2:	39 2b       	or	r19, r25
    8ad4:	4a 2b       	or	r20, r26
    8ad6:	5b 2b       	or	r21, r27
    8ad8:	ea 18       	sub	r14, r10
    8ada:	fb 08       	sbc	r15, r11
    8adc:	0c 09       	sbc	r16, r12
    8ade:	1d 09       	sbc	r17, r13
    8ae0:	b6 95       	lsr	r27
    8ae2:	a7 95       	ror	r26
    8ae4:	97 95       	ror	r25
    8ae6:	87 95       	ror	r24
    8ae8:	ee 0c       	add	r14, r14
    8aea:	ff 1c       	adc	r15, r15
    8aec:	00 1f       	adc	r16, r16
    8aee:	11 1f       	adc	r17, r17
    8af0:	6f 5f       	subi	r22, 0xFF	; 255
    8af2:	7f 4f       	sbci	r23, 0xFF	; 255
    8af4:	6f 31       	cpi	r22, 0x1F	; 31
    8af6:	71 05       	cpc	r23, r1
    8af8:	31 f7       	brne	.-52     	; 0x8ac6 <__divsf3+0xda>
    8afa:	da 01       	movw	r26, r20
    8afc:	c9 01       	movw	r24, r18
    8afe:	8f 77       	andi	r24, 0x7F	; 127
    8b00:	90 70       	andi	r25, 0x00	; 0
    8b02:	a0 70       	andi	r26, 0x00	; 0
    8b04:	b0 70       	andi	r27, 0x00	; 0
    8b06:	80 34       	cpi	r24, 0x40	; 64
    8b08:	91 05       	cpc	r25, r1
    8b0a:	a1 05       	cpc	r26, r1
    8b0c:	b1 05       	cpc	r27, r1
    8b0e:	61 f4       	brne	.+24     	; 0x8b28 <__divsf3+0x13c>
    8b10:	27 fd       	sbrc	r18, 7
    8b12:	0a c0       	rjmp	.+20     	; 0x8b28 <__divsf3+0x13c>
    8b14:	e1 14       	cp	r14, r1
    8b16:	f1 04       	cpc	r15, r1
    8b18:	01 05       	cpc	r16, r1
    8b1a:	11 05       	cpc	r17, r1
    8b1c:	29 f0       	breq	.+10     	; 0x8b28 <__divsf3+0x13c>
    8b1e:	20 5c       	subi	r18, 0xC0	; 192
    8b20:	3f 4f       	sbci	r19, 0xFF	; 255
    8b22:	4f 4f       	sbci	r20, 0xFF	; 255
    8b24:	5f 4f       	sbci	r21, 0xFF	; 255
    8b26:	20 78       	andi	r18, 0x80	; 128
    8b28:	2d 87       	std	Y+13, r18	; 0x0d
    8b2a:	3e 87       	std	Y+14, r19	; 0x0e
    8b2c:	4f 87       	std	Y+15, r20	; 0x0f
    8b2e:	58 8b       	std	Y+16, r21	; 0x10
    8b30:	be 01       	movw	r22, r28
    8b32:	67 5f       	subi	r22, 0xF7	; 247
    8b34:	7f 4f       	sbci	r23, 0xFF	; 255
    8b36:	cb 01       	movw	r24, r22
    8b38:	0e 94 7c 47 	call	0x8ef8	; 0x8ef8 <__pack_f>
    8b3c:	68 96       	adiw	r28, 0x18	; 24
    8b3e:	ea e0       	ldi	r30, 0x0A	; 10
    8b40:	0c 94 d5 49 	jmp	0x93aa	; 0x93aa <__epilogue_restores__+0x10>

00008b44 <__gesf2>:
    8b44:	a8 e1       	ldi	r26, 0x18	; 24
    8b46:	b0 e0       	ldi	r27, 0x00	; 0
    8b48:	e8 ea       	ldi	r30, 0xA8	; 168
    8b4a:	f5 e4       	ldi	r31, 0x45	; 69
    8b4c:	0c 94 bd 49 	jmp	0x937a	; 0x937a <__prologue_saves__+0x18>
    8b50:	69 83       	std	Y+1, r22	; 0x01
    8b52:	7a 83       	std	Y+2, r23	; 0x02
    8b54:	8b 83       	std	Y+3, r24	; 0x03
    8b56:	9c 83       	std	Y+4, r25	; 0x04
    8b58:	2d 83       	std	Y+5, r18	; 0x05
    8b5a:	3e 83       	std	Y+6, r19	; 0x06
    8b5c:	4f 83       	std	Y+7, r20	; 0x07
    8b5e:	58 87       	std	Y+8, r21	; 0x08
    8b60:	89 e0       	ldi	r24, 0x09	; 9
    8b62:	e8 2e       	mov	r14, r24
    8b64:	f1 2c       	mov	r15, r1
    8b66:	ec 0e       	add	r14, r28
    8b68:	fd 1e       	adc	r15, r29
    8b6a:	ce 01       	movw	r24, r28
    8b6c:	01 96       	adiw	r24, 0x01	; 1
    8b6e:	b7 01       	movw	r22, r14
    8b70:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8b74:	8e 01       	movw	r16, r28
    8b76:	0f 5e       	subi	r16, 0xEF	; 239
    8b78:	1f 4f       	sbci	r17, 0xFF	; 255
    8b7a:	ce 01       	movw	r24, r28
    8b7c:	05 96       	adiw	r24, 0x05	; 5
    8b7e:	b8 01       	movw	r22, r16
    8b80:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8b84:	89 85       	ldd	r24, Y+9	; 0x09
    8b86:	82 30       	cpi	r24, 0x02	; 2
    8b88:	40 f0       	brcs	.+16     	; 0x8b9a <__gesf2+0x56>
    8b8a:	89 89       	ldd	r24, Y+17	; 0x11
    8b8c:	82 30       	cpi	r24, 0x02	; 2
    8b8e:	28 f0       	brcs	.+10     	; 0x8b9a <__gesf2+0x56>
    8b90:	c7 01       	movw	r24, r14
    8b92:	b8 01       	movw	r22, r16
    8b94:	0e 94 c9 48 	call	0x9192	; 0x9192 <__fpcmp_parts_f>
    8b98:	01 c0       	rjmp	.+2      	; 0x8b9c <__gesf2+0x58>
    8b9a:	8f ef       	ldi	r24, 0xFF	; 255
    8b9c:	68 96       	adiw	r28, 0x18	; 24
    8b9e:	e6 e0       	ldi	r30, 0x06	; 6
    8ba0:	0c 94 d9 49 	jmp	0x93b2	; 0x93b2 <__epilogue_restores__+0x18>

00008ba4 <__ltsf2>:
    8ba4:	a8 e1       	ldi	r26, 0x18	; 24
    8ba6:	b0 e0       	ldi	r27, 0x00	; 0
    8ba8:	e8 ed       	ldi	r30, 0xD8	; 216
    8baa:	f5 e4       	ldi	r31, 0x45	; 69
    8bac:	0c 94 bd 49 	jmp	0x937a	; 0x937a <__prologue_saves__+0x18>
    8bb0:	69 83       	std	Y+1, r22	; 0x01
    8bb2:	7a 83       	std	Y+2, r23	; 0x02
    8bb4:	8b 83       	std	Y+3, r24	; 0x03
    8bb6:	9c 83       	std	Y+4, r25	; 0x04
    8bb8:	2d 83       	std	Y+5, r18	; 0x05
    8bba:	3e 83       	std	Y+6, r19	; 0x06
    8bbc:	4f 83       	std	Y+7, r20	; 0x07
    8bbe:	58 87       	std	Y+8, r21	; 0x08
    8bc0:	89 e0       	ldi	r24, 0x09	; 9
    8bc2:	e8 2e       	mov	r14, r24
    8bc4:	f1 2c       	mov	r15, r1
    8bc6:	ec 0e       	add	r14, r28
    8bc8:	fd 1e       	adc	r15, r29
    8bca:	ce 01       	movw	r24, r28
    8bcc:	01 96       	adiw	r24, 0x01	; 1
    8bce:	b7 01       	movw	r22, r14
    8bd0:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8bd4:	8e 01       	movw	r16, r28
    8bd6:	0f 5e       	subi	r16, 0xEF	; 239
    8bd8:	1f 4f       	sbci	r17, 0xFF	; 255
    8bda:	ce 01       	movw	r24, r28
    8bdc:	05 96       	adiw	r24, 0x05	; 5
    8bde:	b8 01       	movw	r22, r16
    8be0:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8be4:	89 85       	ldd	r24, Y+9	; 0x09
    8be6:	82 30       	cpi	r24, 0x02	; 2
    8be8:	40 f0       	brcs	.+16     	; 0x8bfa <__ltsf2+0x56>
    8bea:	89 89       	ldd	r24, Y+17	; 0x11
    8bec:	82 30       	cpi	r24, 0x02	; 2
    8bee:	28 f0       	brcs	.+10     	; 0x8bfa <__ltsf2+0x56>
    8bf0:	c7 01       	movw	r24, r14
    8bf2:	b8 01       	movw	r22, r16
    8bf4:	0e 94 c9 48 	call	0x9192	; 0x9192 <__fpcmp_parts_f>
    8bf8:	01 c0       	rjmp	.+2      	; 0x8bfc <__ltsf2+0x58>
    8bfa:	81 e0       	ldi	r24, 0x01	; 1
    8bfc:	68 96       	adiw	r28, 0x18	; 24
    8bfe:	e6 e0       	ldi	r30, 0x06	; 6
    8c00:	0c 94 d9 49 	jmp	0x93b2	; 0x93b2 <__epilogue_restores__+0x18>

00008c04 <__floatsisf>:
    8c04:	a8 e0       	ldi	r26, 0x08	; 8
    8c06:	b0 e0       	ldi	r27, 0x00	; 0
    8c08:	e8 e0       	ldi	r30, 0x08	; 8
    8c0a:	f6 e4       	ldi	r31, 0x46	; 70
    8c0c:	0c 94 ba 49 	jmp	0x9374	; 0x9374 <__prologue_saves__+0x12>
    8c10:	9b 01       	movw	r18, r22
    8c12:	ac 01       	movw	r20, r24
    8c14:	83 e0       	ldi	r24, 0x03	; 3
    8c16:	89 83       	std	Y+1, r24	; 0x01
    8c18:	da 01       	movw	r26, r20
    8c1a:	c9 01       	movw	r24, r18
    8c1c:	88 27       	eor	r24, r24
    8c1e:	b7 fd       	sbrc	r27, 7
    8c20:	83 95       	inc	r24
    8c22:	99 27       	eor	r25, r25
    8c24:	aa 27       	eor	r26, r26
    8c26:	bb 27       	eor	r27, r27
    8c28:	b8 2e       	mov	r11, r24
    8c2a:	21 15       	cp	r18, r1
    8c2c:	31 05       	cpc	r19, r1
    8c2e:	41 05       	cpc	r20, r1
    8c30:	51 05       	cpc	r21, r1
    8c32:	19 f4       	brne	.+6      	; 0x8c3a <__floatsisf+0x36>
    8c34:	82 e0       	ldi	r24, 0x02	; 2
    8c36:	89 83       	std	Y+1, r24	; 0x01
    8c38:	3a c0       	rjmp	.+116    	; 0x8cae <__floatsisf+0xaa>
    8c3a:	88 23       	and	r24, r24
    8c3c:	a9 f0       	breq	.+42     	; 0x8c68 <__floatsisf+0x64>
    8c3e:	20 30       	cpi	r18, 0x00	; 0
    8c40:	80 e0       	ldi	r24, 0x00	; 0
    8c42:	38 07       	cpc	r19, r24
    8c44:	80 e0       	ldi	r24, 0x00	; 0
    8c46:	48 07       	cpc	r20, r24
    8c48:	80 e8       	ldi	r24, 0x80	; 128
    8c4a:	58 07       	cpc	r21, r24
    8c4c:	29 f4       	brne	.+10     	; 0x8c58 <__floatsisf+0x54>
    8c4e:	60 e0       	ldi	r22, 0x00	; 0
    8c50:	70 e0       	ldi	r23, 0x00	; 0
    8c52:	80 e0       	ldi	r24, 0x00	; 0
    8c54:	9f ec       	ldi	r25, 0xCF	; 207
    8c56:	30 c0       	rjmp	.+96     	; 0x8cb8 <__floatsisf+0xb4>
    8c58:	ee 24       	eor	r14, r14
    8c5a:	ff 24       	eor	r15, r15
    8c5c:	87 01       	movw	r16, r14
    8c5e:	e2 1a       	sub	r14, r18
    8c60:	f3 0a       	sbc	r15, r19
    8c62:	04 0b       	sbc	r16, r20
    8c64:	15 0b       	sbc	r17, r21
    8c66:	02 c0       	rjmp	.+4      	; 0x8c6c <__floatsisf+0x68>
    8c68:	79 01       	movw	r14, r18
    8c6a:	8a 01       	movw	r16, r20
    8c6c:	8e e1       	ldi	r24, 0x1E	; 30
    8c6e:	c8 2e       	mov	r12, r24
    8c70:	d1 2c       	mov	r13, r1
    8c72:	cb 82       	std	Y+3, r12	; 0x03
    8c74:	dc 82       	std	Y+4, r13	; 0x04
    8c76:	ed 82       	std	Y+5, r14	; 0x05
    8c78:	fe 82       	std	Y+6, r15	; 0x06
    8c7a:	0f 83       	std	Y+7, r16	; 0x07
    8c7c:	18 87       	std	Y+8, r17	; 0x08
    8c7e:	c8 01       	movw	r24, r16
    8c80:	b7 01       	movw	r22, r14
    8c82:	0e 94 2d 47 	call	0x8e5a	; 0x8e5a <__clzsi2>
    8c86:	01 97       	sbiw	r24, 0x01	; 1
    8c88:	18 16       	cp	r1, r24
    8c8a:	19 06       	cpc	r1, r25
    8c8c:	84 f4       	brge	.+32     	; 0x8cae <__floatsisf+0xaa>
    8c8e:	08 2e       	mov	r0, r24
    8c90:	04 c0       	rjmp	.+8      	; 0x8c9a <__floatsisf+0x96>
    8c92:	ee 0c       	add	r14, r14
    8c94:	ff 1c       	adc	r15, r15
    8c96:	00 1f       	adc	r16, r16
    8c98:	11 1f       	adc	r17, r17
    8c9a:	0a 94       	dec	r0
    8c9c:	d2 f7       	brpl	.-12     	; 0x8c92 <__floatsisf+0x8e>
    8c9e:	ed 82       	std	Y+5, r14	; 0x05
    8ca0:	fe 82       	std	Y+6, r15	; 0x06
    8ca2:	0f 83       	std	Y+7, r16	; 0x07
    8ca4:	18 87       	std	Y+8, r17	; 0x08
    8ca6:	c8 1a       	sub	r12, r24
    8ca8:	d9 0a       	sbc	r13, r25
    8caa:	cb 82       	std	Y+3, r12	; 0x03
    8cac:	dc 82       	std	Y+4, r13	; 0x04
    8cae:	ba 82       	std	Y+2, r11	; 0x02
    8cb0:	ce 01       	movw	r24, r28
    8cb2:	01 96       	adiw	r24, 0x01	; 1
    8cb4:	0e 94 7c 47 	call	0x8ef8	; 0x8ef8 <__pack_f>
    8cb8:	28 96       	adiw	r28, 0x08	; 8
    8cba:	e9 e0       	ldi	r30, 0x09	; 9
    8cbc:	0c 94 d6 49 	jmp	0x93ac	; 0x93ac <__epilogue_restores__+0x12>

00008cc0 <__fixsfsi>:
    8cc0:	ac e0       	ldi	r26, 0x0C	; 12
    8cc2:	b0 e0       	ldi	r27, 0x00	; 0
    8cc4:	e6 e6       	ldi	r30, 0x66	; 102
    8cc6:	f6 e4       	ldi	r31, 0x46	; 70
    8cc8:	0c 94 c1 49 	jmp	0x9382	; 0x9382 <__prologue_saves__+0x20>
    8ccc:	69 83       	std	Y+1, r22	; 0x01
    8cce:	7a 83       	std	Y+2, r23	; 0x02
    8cd0:	8b 83       	std	Y+3, r24	; 0x03
    8cd2:	9c 83       	std	Y+4, r25	; 0x04
    8cd4:	ce 01       	movw	r24, r28
    8cd6:	01 96       	adiw	r24, 0x01	; 1
    8cd8:	be 01       	movw	r22, r28
    8cda:	6b 5f       	subi	r22, 0xFB	; 251
    8cdc:	7f 4f       	sbci	r23, 0xFF	; 255
    8cde:	0e 94 51 48 	call	0x90a2	; 0x90a2 <__unpack_f>
    8ce2:	8d 81       	ldd	r24, Y+5	; 0x05
    8ce4:	82 30       	cpi	r24, 0x02	; 2
    8ce6:	61 f1       	breq	.+88     	; 0x8d40 <__fixsfsi+0x80>
    8ce8:	82 30       	cpi	r24, 0x02	; 2
    8cea:	50 f1       	brcs	.+84     	; 0x8d40 <__fixsfsi+0x80>
    8cec:	84 30       	cpi	r24, 0x04	; 4
    8cee:	21 f4       	brne	.+8      	; 0x8cf8 <__fixsfsi+0x38>
    8cf0:	8e 81       	ldd	r24, Y+6	; 0x06
    8cf2:	88 23       	and	r24, r24
    8cf4:	51 f1       	breq	.+84     	; 0x8d4a <__fixsfsi+0x8a>
    8cf6:	2e c0       	rjmp	.+92     	; 0x8d54 <__fixsfsi+0x94>
    8cf8:	2f 81       	ldd	r18, Y+7	; 0x07
    8cfa:	38 85       	ldd	r19, Y+8	; 0x08
    8cfc:	37 fd       	sbrc	r19, 7
    8cfe:	20 c0       	rjmp	.+64     	; 0x8d40 <__fixsfsi+0x80>
    8d00:	6e 81       	ldd	r22, Y+6	; 0x06
    8d02:	2f 31       	cpi	r18, 0x1F	; 31
    8d04:	31 05       	cpc	r19, r1
    8d06:	1c f0       	brlt	.+6      	; 0x8d0e <__fixsfsi+0x4e>
    8d08:	66 23       	and	r22, r22
    8d0a:	f9 f0       	breq	.+62     	; 0x8d4a <__fixsfsi+0x8a>
    8d0c:	23 c0       	rjmp	.+70     	; 0x8d54 <__fixsfsi+0x94>
    8d0e:	8e e1       	ldi	r24, 0x1E	; 30
    8d10:	90 e0       	ldi	r25, 0x00	; 0
    8d12:	82 1b       	sub	r24, r18
    8d14:	93 0b       	sbc	r25, r19
    8d16:	29 85       	ldd	r18, Y+9	; 0x09
    8d18:	3a 85       	ldd	r19, Y+10	; 0x0a
    8d1a:	4b 85       	ldd	r20, Y+11	; 0x0b
    8d1c:	5c 85       	ldd	r21, Y+12	; 0x0c
    8d1e:	04 c0       	rjmp	.+8      	; 0x8d28 <__fixsfsi+0x68>
    8d20:	56 95       	lsr	r21
    8d22:	47 95       	ror	r20
    8d24:	37 95       	ror	r19
    8d26:	27 95       	ror	r18
    8d28:	8a 95       	dec	r24
    8d2a:	d2 f7       	brpl	.-12     	; 0x8d20 <__fixsfsi+0x60>
    8d2c:	66 23       	and	r22, r22
    8d2e:	b1 f0       	breq	.+44     	; 0x8d5c <__fixsfsi+0x9c>
    8d30:	50 95       	com	r21
    8d32:	40 95       	com	r20
    8d34:	30 95       	com	r19
    8d36:	21 95       	neg	r18
    8d38:	3f 4f       	sbci	r19, 0xFF	; 255
    8d3a:	4f 4f       	sbci	r20, 0xFF	; 255
    8d3c:	5f 4f       	sbci	r21, 0xFF	; 255
    8d3e:	0e c0       	rjmp	.+28     	; 0x8d5c <__fixsfsi+0x9c>
    8d40:	20 e0       	ldi	r18, 0x00	; 0
    8d42:	30 e0       	ldi	r19, 0x00	; 0
    8d44:	40 e0       	ldi	r20, 0x00	; 0
    8d46:	50 e0       	ldi	r21, 0x00	; 0
    8d48:	09 c0       	rjmp	.+18     	; 0x8d5c <__fixsfsi+0x9c>
    8d4a:	2f ef       	ldi	r18, 0xFF	; 255
    8d4c:	3f ef       	ldi	r19, 0xFF	; 255
    8d4e:	4f ef       	ldi	r20, 0xFF	; 255
    8d50:	5f e7       	ldi	r21, 0x7F	; 127
    8d52:	04 c0       	rjmp	.+8      	; 0x8d5c <__fixsfsi+0x9c>
    8d54:	20 e0       	ldi	r18, 0x00	; 0
    8d56:	30 e0       	ldi	r19, 0x00	; 0
    8d58:	40 e0       	ldi	r20, 0x00	; 0
    8d5a:	50 e8       	ldi	r21, 0x80	; 128
    8d5c:	b9 01       	movw	r22, r18
    8d5e:	ca 01       	movw	r24, r20
    8d60:	2c 96       	adiw	r28, 0x0c	; 12
    8d62:	e2 e0       	ldi	r30, 0x02	; 2
    8d64:	0c 94 dd 49 	jmp	0x93ba	; 0x93ba <__epilogue_restores__+0x20>

00008d68 <__floatunsisf>:
    8d68:	a8 e0       	ldi	r26, 0x08	; 8
    8d6a:	b0 e0       	ldi	r27, 0x00	; 0
    8d6c:	ea eb       	ldi	r30, 0xBA	; 186
    8d6e:	f6 e4       	ldi	r31, 0x46	; 70
    8d70:	0c 94 b9 49 	jmp	0x9372	; 0x9372 <__prologue_saves__+0x10>
    8d74:	7b 01       	movw	r14, r22
    8d76:	8c 01       	movw	r16, r24
    8d78:	61 15       	cp	r22, r1
    8d7a:	71 05       	cpc	r23, r1
    8d7c:	81 05       	cpc	r24, r1
    8d7e:	91 05       	cpc	r25, r1
    8d80:	19 f4       	brne	.+6      	; 0x8d88 <__floatunsisf+0x20>
    8d82:	82 e0       	ldi	r24, 0x02	; 2
    8d84:	89 83       	std	Y+1, r24	; 0x01
    8d86:	60 c0       	rjmp	.+192    	; 0x8e48 <__floatunsisf+0xe0>
    8d88:	83 e0       	ldi	r24, 0x03	; 3
    8d8a:	89 83       	std	Y+1, r24	; 0x01
    8d8c:	8e e1       	ldi	r24, 0x1E	; 30
    8d8e:	c8 2e       	mov	r12, r24
    8d90:	d1 2c       	mov	r13, r1
    8d92:	cb 82       	std	Y+3, r12	; 0x03
    8d94:	dc 82       	std	Y+4, r13	; 0x04
    8d96:	ed 82       	std	Y+5, r14	; 0x05
    8d98:	fe 82       	std	Y+6, r15	; 0x06
    8d9a:	0f 83       	std	Y+7, r16	; 0x07
    8d9c:	18 87       	std	Y+8, r17	; 0x08
    8d9e:	c8 01       	movw	r24, r16
    8da0:	b7 01       	movw	r22, r14
    8da2:	0e 94 2d 47 	call	0x8e5a	; 0x8e5a <__clzsi2>
    8da6:	fc 01       	movw	r30, r24
    8da8:	31 97       	sbiw	r30, 0x01	; 1
    8daa:	f7 ff       	sbrs	r31, 7
    8dac:	3b c0       	rjmp	.+118    	; 0x8e24 <__floatunsisf+0xbc>
    8dae:	22 27       	eor	r18, r18
    8db0:	33 27       	eor	r19, r19
    8db2:	2e 1b       	sub	r18, r30
    8db4:	3f 0b       	sbc	r19, r31
    8db6:	57 01       	movw	r10, r14
    8db8:	68 01       	movw	r12, r16
    8dba:	02 2e       	mov	r0, r18
    8dbc:	04 c0       	rjmp	.+8      	; 0x8dc6 <__floatunsisf+0x5e>
    8dbe:	d6 94       	lsr	r13
    8dc0:	c7 94       	ror	r12
    8dc2:	b7 94       	ror	r11
    8dc4:	a7 94       	ror	r10
    8dc6:	0a 94       	dec	r0
    8dc8:	d2 f7       	brpl	.-12     	; 0x8dbe <__floatunsisf+0x56>
    8dca:	40 e0       	ldi	r20, 0x00	; 0
    8dcc:	50 e0       	ldi	r21, 0x00	; 0
    8dce:	60 e0       	ldi	r22, 0x00	; 0
    8dd0:	70 e0       	ldi	r23, 0x00	; 0
    8dd2:	81 e0       	ldi	r24, 0x01	; 1
    8dd4:	90 e0       	ldi	r25, 0x00	; 0
    8dd6:	a0 e0       	ldi	r26, 0x00	; 0
    8dd8:	b0 e0       	ldi	r27, 0x00	; 0
    8dda:	04 c0       	rjmp	.+8      	; 0x8de4 <__floatunsisf+0x7c>
    8ddc:	88 0f       	add	r24, r24
    8dde:	99 1f       	adc	r25, r25
    8de0:	aa 1f       	adc	r26, r26
    8de2:	bb 1f       	adc	r27, r27
    8de4:	2a 95       	dec	r18
    8de6:	d2 f7       	brpl	.-12     	; 0x8ddc <__floatunsisf+0x74>
    8de8:	01 97       	sbiw	r24, 0x01	; 1
    8dea:	a1 09       	sbc	r26, r1
    8dec:	b1 09       	sbc	r27, r1
    8dee:	8e 21       	and	r24, r14
    8df0:	9f 21       	and	r25, r15
    8df2:	a0 23       	and	r26, r16
    8df4:	b1 23       	and	r27, r17
    8df6:	00 97       	sbiw	r24, 0x00	; 0
    8df8:	a1 05       	cpc	r26, r1
    8dfa:	b1 05       	cpc	r27, r1
    8dfc:	21 f0       	breq	.+8      	; 0x8e06 <__floatunsisf+0x9e>
    8dfe:	41 e0       	ldi	r20, 0x01	; 1
    8e00:	50 e0       	ldi	r21, 0x00	; 0
    8e02:	60 e0       	ldi	r22, 0x00	; 0
    8e04:	70 e0       	ldi	r23, 0x00	; 0
    8e06:	4a 29       	or	r20, r10
    8e08:	5b 29       	or	r21, r11
    8e0a:	6c 29       	or	r22, r12
    8e0c:	7d 29       	or	r23, r13
    8e0e:	4d 83       	std	Y+5, r20	; 0x05
    8e10:	5e 83       	std	Y+6, r21	; 0x06
    8e12:	6f 83       	std	Y+7, r22	; 0x07
    8e14:	78 87       	std	Y+8, r23	; 0x08
    8e16:	8e e1       	ldi	r24, 0x1E	; 30
    8e18:	90 e0       	ldi	r25, 0x00	; 0
    8e1a:	8e 1b       	sub	r24, r30
    8e1c:	9f 0b       	sbc	r25, r31
    8e1e:	8b 83       	std	Y+3, r24	; 0x03
    8e20:	9c 83       	std	Y+4, r25	; 0x04
    8e22:	12 c0       	rjmp	.+36     	; 0x8e48 <__floatunsisf+0xe0>
    8e24:	30 97       	sbiw	r30, 0x00	; 0
    8e26:	81 f0       	breq	.+32     	; 0x8e48 <__floatunsisf+0xe0>
    8e28:	0e 2e       	mov	r0, r30
    8e2a:	04 c0       	rjmp	.+8      	; 0x8e34 <__floatunsisf+0xcc>
    8e2c:	ee 0c       	add	r14, r14
    8e2e:	ff 1c       	adc	r15, r15
    8e30:	00 1f       	adc	r16, r16
    8e32:	11 1f       	adc	r17, r17
    8e34:	0a 94       	dec	r0
    8e36:	d2 f7       	brpl	.-12     	; 0x8e2c <__floatunsisf+0xc4>
    8e38:	ed 82       	std	Y+5, r14	; 0x05
    8e3a:	fe 82       	std	Y+6, r15	; 0x06
    8e3c:	0f 83       	std	Y+7, r16	; 0x07
    8e3e:	18 87       	std	Y+8, r17	; 0x08
    8e40:	ce 1a       	sub	r12, r30
    8e42:	df 0a       	sbc	r13, r31
    8e44:	cb 82       	std	Y+3, r12	; 0x03
    8e46:	dc 82       	std	Y+4, r13	; 0x04
    8e48:	1a 82       	std	Y+2, r1	; 0x02
    8e4a:	ce 01       	movw	r24, r28
    8e4c:	01 96       	adiw	r24, 0x01	; 1
    8e4e:	0e 94 7c 47 	call	0x8ef8	; 0x8ef8 <__pack_f>
    8e52:	28 96       	adiw	r28, 0x08	; 8
    8e54:	ea e0       	ldi	r30, 0x0A	; 10
    8e56:	0c 94 d5 49 	jmp	0x93aa	; 0x93aa <__epilogue_restores__+0x10>

00008e5a <__clzsi2>:
    8e5a:	ef 92       	push	r14
    8e5c:	ff 92       	push	r15
    8e5e:	0f 93       	push	r16
    8e60:	1f 93       	push	r17
    8e62:	7b 01       	movw	r14, r22
    8e64:	8c 01       	movw	r16, r24
    8e66:	80 e0       	ldi	r24, 0x00	; 0
    8e68:	e8 16       	cp	r14, r24
    8e6a:	80 e0       	ldi	r24, 0x00	; 0
    8e6c:	f8 06       	cpc	r15, r24
    8e6e:	81 e0       	ldi	r24, 0x01	; 1
    8e70:	08 07       	cpc	r16, r24
    8e72:	80 e0       	ldi	r24, 0x00	; 0
    8e74:	18 07       	cpc	r17, r24
    8e76:	88 f4       	brcc	.+34     	; 0x8e9a <__clzsi2+0x40>
    8e78:	8f ef       	ldi	r24, 0xFF	; 255
    8e7a:	e8 16       	cp	r14, r24
    8e7c:	f1 04       	cpc	r15, r1
    8e7e:	01 05       	cpc	r16, r1
    8e80:	11 05       	cpc	r17, r1
    8e82:	31 f0       	breq	.+12     	; 0x8e90 <__clzsi2+0x36>
    8e84:	28 f0       	brcs	.+10     	; 0x8e90 <__clzsi2+0x36>
    8e86:	88 e0       	ldi	r24, 0x08	; 8
    8e88:	90 e0       	ldi	r25, 0x00	; 0
    8e8a:	a0 e0       	ldi	r26, 0x00	; 0
    8e8c:	b0 e0       	ldi	r27, 0x00	; 0
    8e8e:	17 c0       	rjmp	.+46     	; 0x8ebe <__clzsi2+0x64>
    8e90:	80 e0       	ldi	r24, 0x00	; 0
    8e92:	90 e0       	ldi	r25, 0x00	; 0
    8e94:	a0 e0       	ldi	r26, 0x00	; 0
    8e96:	b0 e0       	ldi	r27, 0x00	; 0
    8e98:	12 c0       	rjmp	.+36     	; 0x8ebe <__clzsi2+0x64>
    8e9a:	80 e0       	ldi	r24, 0x00	; 0
    8e9c:	e8 16       	cp	r14, r24
    8e9e:	80 e0       	ldi	r24, 0x00	; 0
    8ea0:	f8 06       	cpc	r15, r24
    8ea2:	80 e0       	ldi	r24, 0x00	; 0
    8ea4:	08 07       	cpc	r16, r24
    8ea6:	81 e0       	ldi	r24, 0x01	; 1
    8ea8:	18 07       	cpc	r17, r24
    8eaa:	28 f0       	brcs	.+10     	; 0x8eb6 <__clzsi2+0x5c>
    8eac:	88 e1       	ldi	r24, 0x18	; 24
    8eae:	90 e0       	ldi	r25, 0x00	; 0
    8eb0:	a0 e0       	ldi	r26, 0x00	; 0
    8eb2:	b0 e0       	ldi	r27, 0x00	; 0
    8eb4:	04 c0       	rjmp	.+8      	; 0x8ebe <__clzsi2+0x64>
    8eb6:	80 e1       	ldi	r24, 0x10	; 16
    8eb8:	90 e0       	ldi	r25, 0x00	; 0
    8eba:	a0 e0       	ldi	r26, 0x00	; 0
    8ebc:	b0 e0       	ldi	r27, 0x00	; 0
    8ebe:	20 e2       	ldi	r18, 0x20	; 32
    8ec0:	30 e0       	ldi	r19, 0x00	; 0
    8ec2:	40 e0       	ldi	r20, 0x00	; 0
    8ec4:	50 e0       	ldi	r21, 0x00	; 0
    8ec6:	28 1b       	sub	r18, r24
    8ec8:	39 0b       	sbc	r19, r25
    8eca:	4a 0b       	sbc	r20, r26
    8ecc:	5b 0b       	sbc	r21, r27
    8ece:	04 c0       	rjmp	.+8      	; 0x8ed8 <__clzsi2+0x7e>
    8ed0:	16 95       	lsr	r17
    8ed2:	07 95       	ror	r16
    8ed4:	f7 94       	ror	r15
    8ed6:	e7 94       	ror	r14
    8ed8:	8a 95       	dec	r24
    8eda:	d2 f7       	brpl	.-12     	; 0x8ed0 <__clzsi2+0x76>
    8edc:	f7 01       	movw	r30, r14
    8ede:	ed 5d       	subi	r30, 0xDD	; 221
    8ee0:	fa 4d       	sbci	r31, 0xDA	; 218
    8ee2:	80 81       	ld	r24, Z
    8ee4:	28 1b       	sub	r18, r24
    8ee6:	31 09       	sbc	r19, r1
    8ee8:	41 09       	sbc	r20, r1
    8eea:	51 09       	sbc	r21, r1
    8eec:	c9 01       	movw	r24, r18
    8eee:	1f 91       	pop	r17
    8ef0:	0f 91       	pop	r16
    8ef2:	ff 90       	pop	r15
    8ef4:	ef 90       	pop	r14
    8ef6:	08 95       	ret

00008ef8 <__pack_f>:
    8ef8:	df 92       	push	r13
    8efa:	ef 92       	push	r14
    8efc:	ff 92       	push	r15
    8efe:	0f 93       	push	r16
    8f00:	1f 93       	push	r17
    8f02:	fc 01       	movw	r30, r24
    8f04:	e4 80       	ldd	r14, Z+4	; 0x04
    8f06:	f5 80       	ldd	r15, Z+5	; 0x05
    8f08:	06 81       	ldd	r16, Z+6	; 0x06
    8f0a:	17 81       	ldd	r17, Z+7	; 0x07
    8f0c:	d1 80       	ldd	r13, Z+1	; 0x01
    8f0e:	80 81       	ld	r24, Z
    8f10:	82 30       	cpi	r24, 0x02	; 2
    8f12:	48 f4       	brcc	.+18     	; 0x8f26 <__pack_f+0x2e>
    8f14:	80 e0       	ldi	r24, 0x00	; 0
    8f16:	90 e0       	ldi	r25, 0x00	; 0
    8f18:	a0 e1       	ldi	r26, 0x10	; 16
    8f1a:	b0 e0       	ldi	r27, 0x00	; 0
    8f1c:	e8 2a       	or	r14, r24
    8f1e:	f9 2a       	or	r15, r25
    8f20:	0a 2b       	or	r16, r26
    8f22:	1b 2b       	or	r17, r27
    8f24:	a5 c0       	rjmp	.+330    	; 0x9070 <__pack_f+0x178>
    8f26:	84 30       	cpi	r24, 0x04	; 4
    8f28:	09 f4       	brne	.+2      	; 0x8f2c <__pack_f+0x34>
    8f2a:	9f c0       	rjmp	.+318    	; 0x906a <__pack_f+0x172>
    8f2c:	82 30       	cpi	r24, 0x02	; 2
    8f2e:	21 f4       	brne	.+8      	; 0x8f38 <__pack_f+0x40>
    8f30:	ee 24       	eor	r14, r14
    8f32:	ff 24       	eor	r15, r15
    8f34:	87 01       	movw	r16, r14
    8f36:	05 c0       	rjmp	.+10     	; 0x8f42 <__pack_f+0x4a>
    8f38:	e1 14       	cp	r14, r1
    8f3a:	f1 04       	cpc	r15, r1
    8f3c:	01 05       	cpc	r16, r1
    8f3e:	11 05       	cpc	r17, r1
    8f40:	19 f4       	brne	.+6      	; 0x8f48 <__pack_f+0x50>
    8f42:	e0 e0       	ldi	r30, 0x00	; 0
    8f44:	f0 e0       	ldi	r31, 0x00	; 0
    8f46:	96 c0       	rjmp	.+300    	; 0x9074 <__pack_f+0x17c>
    8f48:	62 81       	ldd	r22, Z+2	; 0x02
    8f4a:	73 81       	ldd	r23, Z+3	; 0x03
    8f4c:	9f ef       	ldi	r25, 0xFF	; 255
    8f4e:	62 38       	cpi	r22, 0x82	; 130
    8f50:	79 07       	cpc	r23, r25
    8f52:	0c f0       	brlt	.+2      	; 0x8f56 <__pack_f+0x5e>
    8f54:	5b c0       	rjmp	.+182    	; 0x900c <__pack_f+0x114>
    8f56:	22 e8       	ldi	r18, 0x82	; 130
    8f58:	3f ef       	ldi	r19, 0xFF	; 255
    8f5a:	26 1b       	sub	r18, r22
    8f5c:	37 0b       	sbc	r19, r23
    8f5e:	2a 31       	cpi	r18, 0x1A	; 26
    8f60:	31 05       	cpc	r19, r1
    8f62:	2c f0       	brlt	.+10     	; 0x8f6e <__pack_f+0x76>
    8f64:	20 e0       	ldi	r18, 0x00	; 0
    8f66:	30 e0       	ldi	r19, 0x00	; 0
    8f68:	40 e0       	ldi	r20, 0x00	; 0
    8f6a:	50 e0       	ldi	r21, 0x00	; 0
    8f6c:	2a c0       	rjmp	.+84     	; 0x8fc2 <__pack_f+0xca>
    8f6e:	b8 01       	movw	r22, r16
    8f70:	a7 01       	movw	r20, r14
    8f72:	02 2e       	mov	r0, r18
    8f74:	04 c0       	rjmp	.+8      	; 0x8f7e <__pack_f+0x86>
    8f76:	76 95       	lsr	r23
    8f78:	67 95       	ror	r22
    8f7a:	57 95       	ror	r21
    8f7c:	47 95       	ror	r20
    8f7e:	0a 94       	dec	r0
    8f80:	d2 f7       	brpl	.-12     	; 0x8f76 <__pack_f+0x7e>
    8f82:	81 e0       	ldi	r24, 0x01	; 1
    8f84:	90 e0       	ldi	r25, 0x00	; 0
    8f86:	a0 e0       	ldi	r26, 0x00	; 0
    8f88:	b0 e0       	ldi	r27, 0x00	; 0
    8f8a:	04 c0       	rjmp	.+8      	; 0x8f94 <__pack_f+0x9c>
    8f8c:	88 0f       	add	r24, r24
    8f8e:	99 1f       	adc	r25, r25
    8f90:	aa 1f       	adc	r26, r26
    8f92:	bb 1f       	adc	r27, r27
    8f94:	2a 95       	dec	r18
    8f96:	d2 f7       	brpl	.-12     	; 0x8f8c <__pack_f+0x94>
    8f98:	01 97       	sbiw	r24, 0x01	; 1
    8f9a:	a1 09       	sbc	r26, r1
    8f9c:	b1 09       	sbc	r27, r1
    8f9e:	8e 21       	and	r24, r14
    8fa0:	9f 21       	and	r25, r15
    8fa2:	a0 23       	and	r26, r16
    8fa4:	b1 23       	and	r27, r17
    8fa6:	00 97       	sbiw	r24, 0x00	; 0
    8fa8:	a1 05       	cpc	r26, r1
    8faa:	b1 05       	cpc	r27, r1
    8fac:	21 f0       	breq	.+8      	; 0x8fb6 <__pack_f+0xbe>
    8fae:	81 e0       	ldi	r24, 0x01	; 1
    8fb0:	90 e0       	ldi	r25, 0x00	; 0
    8fb2:	a0 e0       	ldi	r26, 0x00	; 0
    8fb4:	b0 e0       	ldi	r27, 0x00	; 0
    8fb6:	9a 01       	movw	r18, r20
    8fb8:	ab 01       	movw	r20, r22
    8fba:	28 2b       	or	r18, r24
    8fbc:	39 2b       	or	r19, r25
    8fbe:	4a 2b       	or	r20, r26
    8fc0:	5b 2b       	or	r21, r27
    8fc2:	da 01       	movw	r26, r20
    8fc4:	c9 01       	movw	r24, r18
    8fc6:	8f 77       	andi	r24, 0x7F	; 127
    8fc8:	90 70       	andi	r25, 0x00	; 0
    8fca:	a0 70       	andi	r26, 0x00	; 0
    8fcc:	b0 70       	andi	r27, 0x00	; 0
    8fce:	80 34       	cpi	r24, 0x40	; 64
    8fd0:	91 05       	cpc	r25, r1
    8fd2:	a1 05       	cpc	r26, r1
    8fd4:	b1 05       	cpc	r27, r1
    8fd6:	39 f4       	brne	.+14     	; 0x8fe6 <__pack_f+0xee>
    8fd8:	27 ff       	sbrs	r18, 7
    8fda:	09 c0       	rjmp	.+18     	; 0x8fee <__pack_f+0xf6>
    8fdc:	20 5c       	subi	r18, 0xC0	; 192
    8fde:	3f 4f       	sbci	r19, 0xFF	; 255
    8fe0:	4f 4f       	sbci	r20, 0xFF	; 255
    8fe2:	5f 4f       	sbci	r21, 0xFF	; 255
    8fe4:	04 c0       	rjmp	.+8      	; 0x8fee <__pack_f+0xf6>
    8fe6:	21 5c       	subi	r18, 0xC1	; 193
    8fe8:	3f 4f       	sbci	r19, 0xFF	; 255
    8fea:	4f 4f       	sbci	r20, 0xFF	; 255
    8fec:	5f 4f       	sbci	r21, 0xFF	; 255
    8fee:	e0 e0       	ldi	r30, 0x00	; 0
    8ff0:	f0 e0       	ldi	r31, 0x00	; 0
    8ff2:	20 30       	cpi	r18, 0x00	; 0
    8ff4:	a0 e0       	ldi	r26, 0x00	; 0
    8ff6:	3a 07       	cpc	r19, r26
    8ff8:	a0 e0       	ldi	r26, 0x00	; 0
    8ffa:	4a 07       	cpc	r20, r26
    8ffc:	a0 e4       	ldi	r26, 0x40	; 64
    8ffe:	5a 07       	cpc	r21, r26
    9000:	10 f0       	brcs	.+4      	; 0x9006 <__pack_f+0x10e>
    9002:	e1 e0       	ldi	r30, 0x01	; 1
    9004:	f0 e0       	ldi	r31, 0x00	; 0
    9006:	79 01       	movw	r14, r18
    9008:	8a 01       	movw	r16, r20
    900a:	27 c0       	rjmp	.+78     	; 0x905a <__pack_f+0x162>
    900c:	60 38       	cpi	r22, 0x80	; 128
    900e:	71 05       	cpc	r23, r1
    9010:	64 f5       	brge	.+88     	; 0x906a <__pack_f+0x172>
    9012:	fb 01       	movw	r30, r22
    9014:	e1 58       	subi	r30, 0x81	; 129
    9016:	ff 4f       	sbci	r31, 0xFF	; 255
    9018:	d8 01       	movw	r26, r16
    901a:	c7 01       	movw	r24, r14
    901c:	8f 77       	andi	r24, 0x7F	; 127
    901e:	90 70       	andi	r25, 0x00	; 0
    9020:	a0 70       	andi	r26, 0x00	; 0
    9022:	b0 70       	andi	r27, 0x00	; 0
    9024:	80 34       	cpi	r24, 0x40	; 64
    9026:	91 05       	cpc	r25, r1
    9028:	a1 05       	cpc	r26, r1
    902a:	b1 05       	cpc	r27, r1
    902c:	39 f4       	brne	.+14     	; 0x903c <__pack_f+0x144>
    902e:	e7 fe       	sbrs	r14, 7
    9030:	0d c0       	rjmp	.+26     	; 0x904c <__pack_f+0x154>
    9032:	80 e4       	ldi	r24, 0x40	; 64
    9034:	90 e0       	ldi	r25, 0x00	; 0
    9036:	a0 e0       	ldi	r26, 0x00	; 0
    9038:	b0 e0       	ldi	r27, 0x00	; 0
    903a:	04 c0       	rjmp	.+8      	; 0x9044 <__pack_f+0x14c>
    903c:	8f e3       	ldi	r24, 0x3F	; 63
    903e:	90 e0       	ldi	r25, 0x00	; 0
    9040:	a0 e0       	ldi	r26, 0x00	; 0
    9042:	b0 e0       	ldi	r27, 0x00	; 0
    9044:	e8 0e       	add	r14, r24
    9046:	f9 1e       	adc	r15, r25
    9048:	0a 1f       	adc	r16, r26
    904a:	1b 1f       	adc	r17, r27
    904c:	17 ff       	sbrs	r17, 7
    904e:	05 c0       	rjmp	.+10     	; 0x905a <__pack_f+0x162>
    9050:	16 95       	lsr	r17
    9052:	07 95       	ror	r16
    9054:	f7 94       	ror	r15
    9056:	e7 94       	ror	r14
    9058:	31 96       	adiw	r30, 0x01	; 1
    905a:	87 e0       	ldi	r24, 0x07	; 7
    905c:	16 95       	lsr	r17
    905e:	07 95       	ror	r16
    9060:	f7 94       	ror	r15
    9062:	e7 94       	ror	r14
    9064:	8a 95       	dec	r24
    9066:	d1 f7       	brne	.-12     	; 0x905c <__pack_f+0x164>
    9068:	05 c0       	rjmp	.+10     	; 0x9074 <__pack_f+0x17c>
    906a:	ee 24       	eor	r14, r14
    906c:	ff 24       	eor	r15, r15
    906e:	87 01       	movw	r16, r14
    9070:	ef ef       	ldi	r30, 0xFF	; 255
    9072:	f0 e0       	ldi	r31, 0x00	; 0
    9074:	6e 2f       	mov	r22, r30
    9076:	67 95       	ror	r22
    9078:	66 27       	eor	r22, r22
    907a:	67 95       	ror	r22
    907c:	90 2f       	mov	r25, r16
    907e:	9f 77       	andi	r25, 0x7F	; 127
    9080:	d7 94       	ror	r13
    9082:	dd 24       	eor	r13, r13
    9084:	d7 94       	ror	r13
    9086:	8e 2f       	mov	r24, r30
    9088:	86 95       	lsr	r24
    908a:	49 2f       	mov	r20, r25
    908c:	46 2b       	or	r20, r22
    908e:	58 2f       	mov	r21, r24
    9090:	5d 29       	or	r21, r13
    9092:	b7 01       	movw	r22, r14
    9094:	ca 01       	movw	r24, r20
    9096:	1f 91       	pop	r17
    9098:	0f 91       	pop	r16
    909a:	ff 90       	pop	r15
    909c:	ef 90       	pop	r14
    909e:	df 90       	pop	r13
    90a0:	08 95       	ret

000090a2 <__unpack_f>:
    90a2:	fc 01       	movw	r30, r24
    90a4:	db 01       	movw	r26, r22
    90a6:	40 81       	ld	r20, Z
    90a8:	51 81       	ldd	r21, Z+1	; 0x01
    90aa:	22 81       	ldd	r18, Z+2	; 0x02
    90ac:	62 2f       	mov	r22, r18
    90ae:	6f 77       	andi	r22, 0x7F	; 127
    90b0:	70 e0       	ldi	r23, 0x00	; 0
    90b2:	22 1f       	adc	r18, r18
    90b4:	22 27       	eor	r18, r18
    90b6:	22 1f       	adc	r18, r18
    90b8:	93 81       	ldd	r25, Z+3	; 0x03
    90ba:	89 2f       	mov	r24, r25
    90bc:	88 0f       	add	r24, r24
    90be:	82 2b       	or	r24, r18
    90c0:	28 2f       	mov	r18, r24
    90c2:	30 e0       	ldi	r19, 0x00	; 0
    90c4:	99 1f       	adc	r25, r25
    90c6:	99 27       	eor	r25, r25
    90c8:	99 1f       	adc	r25, r25
    90ca:	11 96       	adiw	r26, 0x01	; 1
    90cc:	9c 93       	st	X, r25
    90ce:	11 97       	sbiw	r26, 0x01	; 1
    90d0:	21 15       	cp	r18, r1
    90d2:	31 05       	cpc	r19, r1
    90d4:	a9 f5       	brne	.+106    	; 0x9140 <__unpack_f+0x9e>
    90d6:	41 15       	cp	r20, r1
    90d8:	51 05       	cpc	r21, r1
    90da:	61 05       	cpc	r22, r1
    90dc:	71 05       	cpc	r23, r1
    90de:	11 f4       	brne	.+4      	; 0x90e4 <__unpack_f+0x42>
    90e0:	82 e0       	ldi	r24, 0x02	; 2
    90e2:	37 c0       	rjmp	.+110    	; 0x9152 <__unpack_f+0xb0>
    90e4:	82 e8       	ldi	r24, 0x82	; 130
    90e6:	9f ef       	ldi	r25, 0xFF	; 255
    90e8:	12 96       	adiw	r26, 0x02	; 2
    90ea:	8d 93       	st	X+, r24
    90ec:	9c 93       	st	X, r25
    90ee:	13 97       	sbiw	r26, 0x03	; 3
    90f0:	9a 01       	movw	r18, r20
    90f2:	ab 01       	movw	r20, r22
    90f4:	67 e0       	ldi	r22, 0x07	; 7
    90f6:	22 0f       	add	r18, r18
    90f8:	33 1f       	adc	r19, r19
    90fa:	44 1f       	adc	r20, r20
    90fc:	55 1f       	adc	r21, r21
    90fe:	6a 95       	dec	r22
    9100:	d1 f7       	brne	.-12     	; 0x90f6 <__unpack_f+0x54>
    9102:	83 e0       	ldi	r24, 0x03	; 3
    9104:	8c 93       	st	X, r24
    9106:	0d c0       	rjmp	.+26     	; 0x9122 <__unpack_f+0x80>
    9108:	22 0f       	add	r18, r18
    910a:	33 1f       	adc	r19, r19
    910c:	44 1f       	adc	r20, r20
    910e:	55 1f       	adc	r21, r21
    9110:	12 96       	adiw	r26, 0x02	; 2
    9112:	8d 91       	ld	r24, X+
    9114:	9c 91       	ld	r25, X
    9116:	13 97       	sbiw	r26, 0x03	; 3
    9118:	01 97       	sbiw	r24, 0x01	; 1
    911a:	12 96       	adiw	r26, 0x02	; 2
    911c:	8d 93       	st	X+, r24
    911e:	9c 93       	st	X, r25
    9120:	13 97       	sbiw	r26, 0x03	; 3
    9122:	20 30       	cpi	r18, 0x00	; 0
    9124:	80 e0       	ldi	r24, 0x00	; 0
    9126:	38 07       	cpc	r19, r24
    9128:	80 e0       	ldi	r24, 0x00	; 0
    912a:	48 07       	cpc	r20, r24
    912c:	80 e4       	ldi	r24, 0x40	; 64
    912e:	58 07       	cpc	r21, r24
    9130:	58 f3       	brcs	.-42     	; 0x9108 <__unpack_f+0x66>
    9132:	14 96       	adiw	r26, 0x04	; 4
    9134:	2d 93       	st	X+, r18
    9136:	3d 93       	st	X+, r19
    9138:	4d 93       	st	X+, r20
    913a:	5c 93       	st	X, r21
    913c:	17 97       	sbiw	r26, 0x07	; 7
    913e:	08 95       	ret
    9140:	2f 3f       	cpi	r18, 0xFF	; 255
    9142:	31 05       	cpc	r19, r1
    9144:	79 f4       	brne	.+30     	; 0x9164 <__unpack_f+0xc2>
    9146:	41 15       	cp	r20, r1
    9148:	51 05       	cpc	r21, r1
    914a:	61 05       	cpc	r22, r1
    914c:	71 05       	cpc	r23, r1
    914e:	19 f4       	brne	.+6      	; 0x9156 <__unpack_f+0xb4>
    9150:	84 e0       	ldi	r24, 0x04	; 4
    9152:	8c 93       	st	X, r24
    9154:	08 95       	ret
    9156:	64 ff       	sbrs	r22, 4
    9158:	03 c0       	rjmp	.+6      	; 0x9160 <__unpack_f+0xbe>
    915a:	81 e0       	ldi	r24, 0x01	; 1
    915c:	8c 93       	st	X, r24
    915e:	12 c0       	rjmp	.+36     	; 0x9184 <__unpack_f+0xe2>
    9160:	1c 92       	st	X, r1
    9162:	10 c0       	rjmp	.+32     	; 0x9184 <__unpack_f+0xe2>
    9164:	2f 57       	subi	r18, 0x7F	; 127
    9166:	30 40       	sbci	r19, 0x00	; 0
    9168:	12 96       	adiw	r26, 0x02	; 2
    916a:	2d 93       	st	X+, r18
    916c:	3c 93       	st	X, r19
    916e:	13 97       	sbiw	r26, 0x03	; 3
    9170:	83 e0       	ldi	r24, 0x03	; 3
    9172:	8c 93       	st	X, r24
    9174:	87 e0       	ldi	r24, 0x07	; 7
    9176:	44 0f       	add	r20, r20
    9178:	55 1f       	adc	r21, r21
    917a:	66 1f       	adc	r22, r22
    917c:	77 1f       	adc	r23, r23
    917e:	8a 95       	dec	r24
    9180:	d1 f7       	brne	.-12     	; 0x9176 <__unpack_f+0xd4>
    9182:	70 64       	ori	r23, 0x40	; 64
    9184:	14 96       	adiw	r26, 0x04	; 4
    9186:	4d 93       	st	X+, r20
    9188:	5d 93       	st	X+, r21
    918a:	6d 93       	st	X+, r22
    918c:	7c 93       	st	X, r23
    918e:	17 97       	sbiw	r26, 0x07	; 7
    9190:	08 95       	ret

00009192 <__fpcmp_parts_f>:
    9192:	1f 93       	push	r17
    9194:	dc 01       	movw	r26, r24
    9196:	fb 01       	movw	r30, r22
    9198:	9c 91       	ld	r25, X
    919a:	92 30       	cpi	r25, 0x02	; 2
    919c:	08 f4       	brcc	.+2      	; 0x91a0 <__fpcmp_parts_f+0xe>
    919e:	47 c0       	rjmp	.+142    	; 0x922e <__fpcmp_parts_f+0x9c>
    91a0:	80 81       	ld	r24, Z
    91a2:	82 30       	cpi	r24, 0x02	; 2
    91a4:	08 f4       	brcc	.+2      	; 0x91a8 <__fpcmp_parts_f+0x16>
    91a6:	43 c0       	rjmp	.+134    	; 0x922e <__fpcmp_parts_f+0x9c>
    91a8:	94 30       	cpi	r25, 0x04	; 4
    91aa:	51 f4       	brne	.+20     	; 0x91c0 <__fpcmp_parts_f+0x2e>
    91ac:	11 96       	adiw	r26, 0x01	; 1
    91ae:	1c 91       	ld	r17, X
    91b0:	84 30       	cpi	r24, 0x04	; 4
    91b2:	99 f5       	brne	.+102    	; 0x921a <__fpcmp_parts_f+0x88>
    91b4:	81 81       	ldd	r24, Z+1	; 0x01
    91b6:	68 2f       	mov	r22, r24
    91b8:	70 e0       	ldi	r23, 0x00	; 0
    91ba:	61 1b       	sub	r22, r17
    91bc:	71 09       	sbc	r23, r1
    91be:	3f c0       	rjmp	.+126    	; 0x923e <__fpcmp_parts_f+0xac>
    91c0:	84 30       	cpi	r24, 0x04	; 4
    91c2:	21 f0       	breq	.+8      	; 0x91cc <__fpcmp_parts_f+0x3a>
    91c4:	92 30       	cpi	r25, 0x02	; 2
    91c6:	31 f4       	brne	.+12     	; 0x91d4 <__fpcmp_parts_f+0x42>
    91c8:	82 30       	cpi	r24, 0x02	; 2
    91ca:	b9 f1       	breq	.+110    	; 0x923a <__fpcmp_parts_f+0xa8>
    91cc:	81 81       	ldd	r24, Z+1	; 0x01
    91ce:	88 23       	and	r24, r24
    91d0:	89 f1       	breq	.+98     	; 0x9234 <__fpcmp_parts_f+0xa2>
    91d2:	2d c0       	rjmp	.+90     	; 0x922e <__fpcmp_parts_f+0x9c>
    91d4:	11 96       	adiw	r26, 0x01	; 1
    91d6:	1c 91       	ld	r17, X
    91d8:	11 97       	sbiw	r26, 0x01	; 1
    91da:	82 30       	cpi	r24, 0x02	; 2
    91dc:	f1 f0       	breq	.+60     	; 0x921a <__fpcmp_parts_f+0x88>
    91de:	81 81       	ldd	r24, Z+1	; 0x01
    91e0:	18 17       	cp	r17, r24
    91e2:	d9 f4       	brne	.+54     	; 0x921a <__fpcmp_parts_f+0x88>
    91e4:	12 96       	adiw	r26, 0x02	; 2
    91e6:	2d 91       	ld	r18, X+
    91e8:	3c 91       	ld	r19, X
    91ea:	13 97       	sbiw	r26, 0x03	; 3
    91ec:	82 81       	ldd	r24, Z+2	; 0x02
    91ee:	93 81       	ldd	r25, Z+3	; 0x03
    91f0:	82 17       	cp	r24, r18
    91f2:	93 07       	cpc	r25, r19
    91f4:	94 f0       	brlt	.+36     	; 0x921a <__fpcmp_parts_f+0x88>
    91f6:	28 17       	cp	r18, r24
    91f8:	39 07       	cpc	r19, r25
    91fa:	bc f0       	brlt	.+46     	; 0x922a <__fpcmp_parts_f+0x98>
    91fc:	14 96       	adiw	r26, 0x04	; 4
    91fe:	8d 91       	ld	r24, X+
    9200:	9d 91       	ld	r25, X+
    9202:	0d 90       	ld	r0, X+
    9204:	bc 91       	ld	r27, X
    9206:	a0 2d       	mov	r26, r0
    9208:	24 81       	ldd	r18, Z+4	; 0x04
    920a:	35 81       	ldd	r19, Z+5	; 0x05
    920c:	46 81       	ldd	r20, Z+6	; 0x06
    920e:	57 81       	ldd	r21, Z+7	; 0x07
    9210:	28 17       	cp	r18, r24
    9212:	39 07       	cpc	r19, r25
    9214:	4a 07       	cpc	r20, r26
    9216:	5b 07       	cpc	r21, r27
    9218:	18 f4       	brcc	.+6      	; 0x9220 <__fpcmp_parts_f+0x8e>
    921a:	11 23       	and	r17, r17
    921c:	41 f0       	breq	.+16     	; 0x922e <__fpcmp_parts_f+0x9c>
    921e:	0a c0       	rjmp	.+20     	; 0x9234 <__fpcmp_parts_f+0xa2>
    9220:	82 17       	cp	r24, r18
    9222:	93 07       	cpc	r25, r19
    9224:	a4 07       	cpc	r26, r20
    9226:	b5 07       	cpc	r27, r21
    9228:	40 f4       	brcc	.+16     	; 0x923a <__fpcmp_parts_f+0xa8>
    922a:	11 23       	and	r17, r17
    922c:	19 f0       	breq	.+6      	; 0x9234 <__fpcmp_parts_f+0xa2>
    922e:	61 e0       	ldi	r22, 0x01	; 1
    9230:	70 e0       	ldi	r23, 0x00	; 0
    9232:	05 c0       	rjmp	.+10     	; 0x923e <__fpcmp_parts_f+0xac>
    9234:	6f ef       	ldi	r22, 0xFF	; 255
    9236:	7f ef       	ldi	r23, 0xFF	; 255
    9238:	02 c0       	rjmp	.+4      	; 0x923e <__fpcmp_parts_f+0xac>
    923a:	60 e0       	ldi	r22, 0x00	; 0
    923c:	70 e0       	ldi	r23, 0x00	; 0
    923e:	cb 01       	movw	r24, r22
    9240:	1f 91       	pop	r17
    9242:	08 95       	ret

00009244 <__mulsi3>:
    9244:	62 9f       	mul	r22, r18
    9246:	d0 01       	movw	r26, r0
    9248:	73 9f       	mul	r23, r19
    924a:	f0 01       	movw	r30, r0
    924c:	82 9f       	mul	r24, r18
    924e:	e0 0d       	add	r30, r0
    9250:	f1 1d       	adc	r31, r1
    9252:	64 9f       	mul	r22, r20
    9254:	e0 0d       	add	r30, r0
    9256:	f1 1d       	adc	r31, r1
    9258:	92 9f       	mul	r25, r18
    925a:	f0 0d       	add	r31, r0
    925c:	83 9f       	mul	r24, r19
    925e:	f0 0d       	add	r31, r0
    9260:	74 9f       	mul	r23, r20
    9262:	f0 0d       	add	r31, r0
    9264:	65 9f       	mul	r22, r21
    9266:	f0 0d       	add	r31, r0
    9268:	99 27       	eor	r25, r25
    926a:	72 9f       	mul	r23, r18
    926c:	b0 0d       	add	r27, r0
    926e:	e1 1d       	adc	r30, r1
    9270:	f9 1f       	adc	r31, r25
    9272:	63 9f       	mul	r22, r19
    9274:	b0 0d       	add	r27, r0
    9276:	e1 1d       	adc	r30, r1
    9278:	f9 1f       	adc	r31, r25
    927a:	bd 01       	movw	r22, r26
    927c:	cf 01       	movw	r24, r30
    927e:	11 24       	eor	r1, r1
    9280:	08 95       	ret

00009282 <__udivmodqi4>:
    9282:	99 1b       	sub	r25, r25
    9284:	79 e0       	ldi	r23, 0x09	; 9
    9286:	04 c0       	rjmp	.+8      	; 0x9290 <__udivmodqi4_ep>

00009288 <__udivmodqi4_loop>:
    9288:	99 1f       	adc	r25, r25
    928a:	96 17       	cp	r25, r22
    928c:	08 f0       	brcs	.+2      	; 0x9290 <__udivmodqi4_ep>
    928e:	96 1b       	sub	r25, r22

00009290 <__udivmodqi4_ep>:
    9290:	88 1f       	adc	r24, r24
    9292:	7a 95       	dec	r23
    9294:	c9 f7       	brne	.-14     	; 0x9288 <__udivmodqi4_loop>
    9296:	80 95       	com	r24
    9298:	08 95       	ret

0000929a <__udivmodhi4>:
    929a:	aa 1b       	sub	r26, r26
    929c:	bb 1b       	sub	r27, r27
    929e:	51 e1       	ldi	r21, 0x11	; 17
    92a0:	07 c0       	rjmp	.+14     	; 0x92b0 <__udivmodhi4_ep>

000092a2 <__udivmodhi4_loop>:
    92a2:	aa 1f       	adc	r26, r26
    92a4:	bb 1f       	adc	r27, r27
    92a6:	a6 17       	cp	r26, r22
    92a8:	b7 07       	cpc	r27, r23
    92aa:	10 f0       	brcs	.+4      	; 0x92b0 <__udivmodhi4_ep>
    92ac:	a6 1b       	sub	r26, r22
    92ae:	b7 0b       	sbc	r27, r23

000092b0 <__udivmodhi4_ep>:
    92b0:	88 1f       	adc	r24, r24
    92b2:	99 1f       	adc	r25, r25
    92b4:	5a 95       	dec	r21
    92b6:	a9 f7       	brne	.-22     	; 0x92a2 <__udivmodhi4_loop>
    92b8:	80 95       	com	r24
    92ba:	90 95       	com	r25
    92bc:	bc 01       	movw	r22, r24
    92be:	cd 01       	movw	r24, r26
    92c0:	08 95       	ret

000092c2 <__divmodhi4>:
    92c2:	97 fb       	bst	r25, 7
    92c4:	09 2e       	mov	r0, r25
    92c6:	07 26       	eor	r0, r23
    92c8:	0a d0       	rcall	.+20     	; 0x92de <__divmodhi4_neg1>
    92ca:	77 fd       	sbrc	r23, 7
    92cc:	04 d0       	rcall	.+8      	; 0x92d6 <__divmodhi4_neg2>
    92ce:	e5 df       	rcall	.-54     	; 0x929a <__udivmodhi4>
    92d0:	06 d0       	rcall	.+12     	; 0x92de <__divmodhi4_neg1>
    92d2:	00 20       	and	r0, r0
    92d4:	1a f4       	brpl	.+6      	; 0x92dc <__divmodhi4_exit>

000092d6 <__divmodhi4_neg2>:
    92d6:	70 95       	com	r23
    92d8:	61 95       	neg	r22
    92da:	7f 4f       	sbci	r23, 0xFF	; 255

000092dc <__divmodhi4_exit>:
    92dc:	08 95       	ret

000092de <__divmodhi4_neg1>:
    92de:	f6 f7       	brtc	.-4      	; 0x92dc <__divmodhi4_exit>
    92e0:	90 95       	com	r25
    92e2:	81 95       	neg	r24
    92e4:	9f 4f       	sbci	r25, 0xFF	; 255
    92e6:	08 95       	ret

000092e8 <__udivmodsi4>:
    92e8:	a1 e2       	ldi	r26, 0x21	; 33
    92ea:	1a 2e       	mov	r1, r26
    92ec:	aa 1b       	sub	r26, r26
    92ee:	bb 1b       	sub	r27, r27
    92f0:	fd 01       	movw	r30, r26
    92f2:	0d c0       	rjmp	.+26     	; 0x930e <__udivmodsi4_ep>

000092f4 <__udivmodsi4_loop>:
    92f4:	aa 1f       	adc	r26, r26
    92f6:	bb 1f       	adc	r27, r27
    92f8:	ee 1f       	adc	r30, r30
    92fa:	ff 1f       	adc	r31, r31
    92fc:	a2 17       	cp	r26, r18
    92fe:	b3 07       	cpc	r27, r19
    9300:	e4 07       	cpc	r30, r20
    9302:	f5 07       	cpc	r31, r21
    9304:	20 f0       	brcs	.+8      	; 0x930e <__udivmodsi4_ep>
    9306:	a2 1b       	sub	r26, r18
    9308:	b3 0b       	sbc	r27, r19
    930a:	e4 0b       	sbc	r30, r20
    930c:	f5 0b       	sbc	r31, r21

0000930e <__udivmodsi4_ep>:
    930e:	66 1f       	adc	r22, r22
    9310:	77 1f       	adc	r23, r23
    9312:	88 1f       	adc	r24, r24
    9314:	99 1f       	adc	r25, r25
    9316:	1a 94       	dec	r1
    9318:	69 f7       	brne	.-38     	; 0x92f4 <__udivmodsi4_loop>
    931a:	60 95       	com	r22
    931c:	70 95       	com	r23
    931e:	80 95       	com	r24
    9320:	90 95       	com	r25
    9322:	9b 01       	movw	r18, r22
    9324:	ac 01       	movw	r20, r24
    9326:	bd 01       	movw	r22, r26
    9328:	cf 01       	movw	r24, r30
    932a:	08 95       	ret

0000932c <__divmodsi4>:
    932c:	97 fb       	bst	r25, 7
    932e:	09 2e       	mov	r0, r25
    9330:	05 26       	eor	r0, r21
    9332:	0e d0       	rcall	.+28     	; 0x9350 <__divmodsi4_neg1>
    9334:	57 fd       	sbrc	r21, 7
    9336:	04 d0       	rcall	.+8      	; 0x9340 <__divmodsi4_neg2>
    9338:	d7 df       	rcall	.-82     	; 0x92e8 <__udivmodsi4>
    933a:	0a d0       	rcall	.+20     	; 0x9350 <__divmodsi4_neg1>
    933c:	00 1c       	adc	r0, r0
    933e:	38 f4       	brcc	.+14     	; 0x934e <__divmodsi4_exit>

00009340 <__divmodsi4_neg2>:
    9340:	50 95       	com	r21
    9342:	40 95       	com	r20
    9344:	30 95       	com	r19
    9346:	21 95       	neg	r18
    9348:	3f 4f       	sbci	r19, 0xFF	; 255
    934a:	4f 4f       	sbci	r20, 0xFF	; 255
    934c:	5f 4f       	sbci	r21, 0xFF	; 255

0000934e <__divmodsi4_exit>:
    934e:	08 95       	ret

00009350 <__divmodsi4_neg1>:
    9350:	f6 f7       	brtc	.-4      	; 0x934e <__divmodsi4_exit>
    9352:	90 95       	com	r25
    9354:	80 95       	com	r24
    9356:	70 95       	com	r23
    9358:	61 95       	neg	r22
    935a:	7f 4f       	sbci	r23, 0xFF	; 255
    935c:	8f 4f       	sbci	r24, 0xFF	; 255
    935e:	9f 4f       	sbci	r25, 0xFF	; 255
    9360:	08 95       	ret

00009362 <__prologue_saves__>:
    9362:	2f 92       	push	r2
    9364:	3f 92       	push	r3
    9366:	4f 92       	push	r4
    9368:	5f 92       	push	r5
    936a:	6f 92       	push	r6
    936c:	7f 92       	push	r7
    936e:	8f 92       	push	r8
    9370:	9f 92       	push	r9
    9372:	af 92       	push	r10
    9374:	bf 92       	push	r11
    9376:	cf 92       	push	r12
    9378:	df 92       	push	r13
    937a:	ef 92       	push	r14
    937c:	ff 92       	push	r15
    937e:	0f 93       	push	r16
    9380:	1f 93       	push	r17
    9382:	cf 93       	push	r28
    9384:	df 93       	push	r29
    9386:	cd b7       	in	r28, 0x3d	; 61
    9388:	de b7       	in	r29, 0x3e	; 62
    938a:	ca 1b       	sub	r28, r26
    938c:	db 0b       	sbc	r29, r27
    938e:	0f b6       	in	r0, 0x3f	; 63
    9390:	f8 94       	cli
    9392:	de bf       	out	0x3e, r29	; 62
    9394:	0f be       	out	0x3f, r0	; 63
    9396:	cd bf       	out	0x3d, r28	; 61
    9398:	19 94       	eijmp

0000939a <__epilogue_restores__>:
    939a:	2a 88       	ldd	r2, Y+18	; 0x12
    939c:	39 88       	ldd	r3, Y+17	; 0x11
    939e:	48 88       	ldd	r4, Y+16	; 0x10
    93a0:	5f 84       	ldd	r5, Y+15	; 0x0f
    93a2:	6e 84       	ldd	r6, Y+14	; 0x0e
    93a4:	7d 84       	ldd	r7, Y+13	; 0x0d
    93a6:	8c 84       	ldd	r8, Y+12	; 0x0c
    93a8:	9b 84       	ldd	r9, Y+11	; 0x0b
    93aa:	aa 84       	ldd	r10, Y+10	; 0x0a
    93ac:	b9 84       	ldd	r11, Y+9	; 0x09
    93ae:	c8 84       	ldd	r12, Y+8	; 0x08
    93b0:	df 80       	ldd	r13, Y+7	; 0x07
    93b2:	ee 80       	ldd	r14, Y+6	; 0x06
    93b4:	fd 80       	ldd	r15, Y+5	; 0x05
    93b6:	0c 81       	ldd	r16, Y+4	; 0x04
    93b8:	1b 81       	ldd	r17, Y+3	; 0x03
    93ba:	aa 81       	ldd	r26, Y+2	; 0x02
    93bc:	b9 81       	ldd	r27, Y+1	; 0x01
    93be:	ce 0f       	add	r28, r30
    93c0:	d1 1d       	adc	r29, r1
    93c2:	0f b6       	in	r0, 0x3f	; 63
    93c4:	f8 94       	cli
    93c6:	de bf       	out	0x3e, r29	; 62
    93c8:	0f be       	out	0x3f, r0	; 63
    93ca:	cd bf       	out	0x3d, r28	; 61
    93cc:	ed 01       	movw	r28, r26
    93ce:	08 95       	ret

000093d0 <malloc>:
    93d0:	cf 93       	push	r28
    93d2:	df 93       	push	r29
    93d4:	bc 01       	movw	r22, r24
    93d6:	82 30       	cpi	r24, 0x02	; 2
    93d8:	91 05       	cpc	r25, r1
    93da:	10 f4       	brcc	.+4      	; 0x93e0 <malloc+0x10>
    93dc:	62 e0       	ldi	r22, 0x02	; 2
    93de:	70 e0       	ldi	r23, 0x00	; 0
    93e0:	a0 91 0b 2c 	lds	r26, 0x2C0B
    93e4:	b0 91 0c 2c 	lds	r27, 0x2C0C
    93e8:	ed 01       	movw	r28, r26
    93ea:	e0 e0       	ldi	r30, 0x00	; 0
    93ec:	f0 e0       	ldi	r31, 0x00	; 0
    93ee:	40 e0       	ldi	r20, 0x00	; 0
    93f0:	50 e0       	ldi	r21, 0x00	; 0
    93f2:	21 c0       	rjmp	.+66     	; 0x9436 <malloc+0x66>
    93f4:	88 81       	ld	r24, Y
    93f6:	99 81       	ldd	r25, Y+1	; 0x01
    93f8:	86 17       	cp	r24, r22
    93fa:	97 07       	cpc	r25, r23
    93fc:	69 f4       	brne	.+26     	; 0x9418 <malloc+0x48>
    93fe:	8a 81       	ldd	r24, Y+2	; 0x02
    9400:	9b 81       	ldd	r25, Y+3	; 0x03
    9402:	30 97       	sbiw	r30, 0x00	; 0
    9404:	19 f0       	breq	.+6      	; 0x940c <malloc+0x3c>
    9406:	82 83       	std	Z+2, r24	; 0x02
    9408:	93 83       	std	Z+3, r25	; 0x03
    940a:	04 c0       	rjmp	.+8      	; 0x9414 <malloc+0x44>
    940c:	80 93 0b 2c 	sts	0x2C0B, r24
    9410:	90 93 0c 2c 	sts	0x2C0C, r25
    9414:	fe 01       	movw	r30, r28
    9416:	34 c0       	rjmp	.+104    	; 0x9480 <malloc+0xb0>
    9418:	68 17       	cp	r22, r24
    941a:	79 07       	cpc	r23, r25
    941c:	38 f4       	brcc	.+14     	; 0x942c <malloc+0x5c>
    941e:	41 15       	cp	r20, r1
    9420:	51 05       	cpc	r21, r1
    9422:	19 f0       	breq	.+6      	; 0x942a <malloc+0x5a>
    9424:	84 17       	cp	r24, r20
    9426:	95 07       	cpc	r25, r21
    9428:	08 f4       	brcc	.+2      	; 0x942c <malloc+0x5c>
    942a:	ac 01       	movw	r20, r24
    942c:	fe 01       	movw	r30, r28
    942e:	8a 81       	ldd	r24, Y+2	; 0x02
    9430:	9b 81       	ldd	r25, Y+3	; 0x03
    9432:	9c 01       	movw	r18, r24
    9434:	e9 01       	movw	r28, r18
    9436:	20 97       	sbiw	r28, 0x00	; 0
    9438:	e9 f6       	brne	.-70     	; 0x93f4 <malloc+0x24>
    943a:	41 15       	cp	r20, r1
    943c:	51 05       	cpc	r21, r1
    943e:	a9 f1       	breq	.+106    	; 0x94aa <malloc+0xda>
    9440:	ca 01       	movw	r24, r20
    9442:	86 1b       	sub	r24, r22
    9444:	97 0b       	sbc	r25, r23
    9446:	04 97       	sbiw	r24, 0x04	; 4
    9448:	08 f4       	brcc	.+2      	; 0x944c <malloc+0x7c>
    944a:	ba 01       	movw	r22, r20
    944c:	e0 e0       	ldi	r30, 0x00	; 0
    944e:	f0 e0       	ldi	r31, 0x00	; 0
    9450:	2a c0       	rjmp	.+84     	; 0x94a6 <malloc+0xd6>
    9452:	8d 91       	ld	r24, X+
    9454:	9c 91       	ld	r25, X
    9456:	11 97       	sbiw	r26, 0x01	; 1
    9458:	84 17       	cp	r24, r20
    945a:	95 07       	cpc	r25, r21
    945c:	f9 f4       	brne	.+62     	; 0x949c <malloc+0xcc>
    945e:	64 17       	cp	r22, r20
    9460:	75 07       	cpc	r23, r21
    9462:	81 f4       	brne	.+32     	; 0x9484 <malloc+0xb4>
    9464:	12 96       	adiw	r26, 0x02	; 2
    9466:	8d 91       	ld	r24, X+
    9468:	9c 91       	ld	r25, X
    946a:	13 97       	sbiw	r26, 0x03	; 3
    946c:	30 97       	sbiw	r30, 0x00	; 0
    946e:	19 f0       	breq	.+6      	; 0x9476 <malloc+0xa6>
    9470:	82 83       	std	Z+2, r24	; 0x02
    9472:	93 83       	std	Z+3, r25	; 0x03
    9474:	04 c0       	rjmp	.+8      	; 0x947e <malloc+0xae>
    9476:	80 93 0b 2c 	sts	0x2C0B, r24
    947a:	90 93 0c 2c 	sts	0x2C0C, r25
    947e:	fd 01       	movw	r30, r26
    9480:	32 96       	adiw	r30, 0x02	; 2
    9482:	4f c0       	rjmp	.+158    	; 0x9522 <malloc+0x152>
    9484:	ca 01       	movw	r24, r20
    9486:	86 1b       	sub	r24, r22
    9488:	97 0b       	sbc	r25, r23
    948a:	fd 01       	movw	r30, r26
    948c:	e8 0f       	add	r30, r24
    948e:	f9 1f       	adc	r31, r25
    9490:	61 93       	st	Z+, r22
    9492:	71 93       	st	Z+, r23
    9494:	02 97       	sbiw	r24, 0x02	; 2
    9496:	8d 93       	st	X+, r24
    9498:	9c 93       	st	X, r25
    949a:	43 c0       	rjmp	.+134    	; 0x9522 <malloc+0x152>
    949c:	fd 01       	movw	r30, r26
    949e:	82 81       	ldd	r24, Z+2	; 0x02
    94a0:	93 81       	ldd	r25, Z+3	; 0x03
    94a2:	9c 01       	movw	r18, r24
    94a4:	d9 01       	movw	r26, r18
    94a6:	10 97       	sbiw	r26, 0x00	; 0
    94a8:	a1 f6       	brne	.-88     	; 0x9452 <malloc+0x82>
    94aa:	80 91 09 2c 	lds	r24, 0x2C09
    94ae:	90 91 0a 2c 	lds	r25, 0x2C0A
    94b2:	89 2b       	or	r24, r25
    94b4:	41 f4       	brne	.+16     	; 0x94c6 <malloc+0xf6>
    94b6:	80 91 25 26 	lds	r24, 0x2625
    94ba:	90 91 26 26 	lds	r25, 0x2626
    94be:	80 93 09 2c 	sts	0x2C09, r24
    94c2:	90 93 0a 2c 	sts	0x2C0A, r25
    94c6:	40 91 27 26 	lds	r20, 0x2627
    94ca:	50 91 28 26 	lds	r21, 0x2628
    94ce:	41 15       	cp	r20, r1
    94d0:	51 05       	cpc	r21, r1
    94d2:	41 f4       	brne	.+16     	; 0x94e4 <malloc+0x114>
    94d4:	4d b7       	in	r20, 0x3d	; 61
    94d6:	5e b7       	in	r21, 0x3e	; 62
    94d8:	80 91 23 26 	lds	r24, 0x2623
    94dc:	90 91 24 26 	lds	r25, 0x2624
    94e0:	48 1b       	sub	r20, r24
    94e2:	59 0b       	sbc	r21, r25
    94e4:	20 91 09 2c 	lds	r18, 0x2C09
    94e8:	30 91 0a 2c 	lds	r19, 0x2C0A
    94ec:	24 17       	cp	r18, r20
    94ee:	35 07       	cpc	r19, r21
    94f0:	b0 f4       	brcc	.+44     	; 0x951e <malloc+0x14e>
    94f2:	ca 01       	movw	r24, r20
    94f4:	82 1b       	sub	r24, r18
    94f6:	93 0b       	sbc	r25, r19
    94f8:	86 17       	cp	r24, r22
    94fa:	97 07       	cpc	r25, r23
    94fc:	80 f0       	brcs	.+32     	; 0x951e <malloc+0x14e>
    94fe:	ab 01       	movw	r20, r22
    9500:	4e 5f       	subi	r20, 0xFE	; 254
    9502:	5f 4f       	sbci	r21, 0xFF	; 255
    9504:	84 17       	cp	r24, r20
    9506:	95 07       	cpc	r25, r21
    9508:	50 f0       	brcs	.+20     	; 0x951e <malloc+0x14e>
    950a:	42 0f       	add	r20, r18
    950c:	53 1f       	adc	r21, r19
    950e:	40 93 09 2c 	sts	0x2C09, r20
    9512:	50 93 0a 2c 	sts	0x2C0A, r21
    9516:	f9 01       	movw	r30, r18
    9518:	61 93       	st	Z+, r22
    951a:	71 93       	st	Z+, r23
    951c:	02 c0       	rjmp	.+4      	; 0x9522 <malloc+0x152>
    951e:	e0 e0       	ldi	r30, 0x00	; 0
    9520:	f0 e0       	ldi	r31, 0x00	; 0
    9522:	cf 01       	movw	r24, r30
    9524:	df 91       	pop	r29
    9526:	cf 91       	pop	r28
    9528:	08 95       	ret

0000952a <free>:
    952a:	cf 93       	push	r28
    952c:	df 93       	push	r29
    952e:	00 97       	sbiw	r24, 0x00	; 0
    9530:	09 f4       	brne	.+2      	; 0x9534 <free+0xa>
    9532:	50 c0       	rjmp	.+160    	; 0x95d4 <free+0xaa>
    9534:	ec 01       	movw	r28, r24
    9536:	22 97       	sbiw	r28, 0x02	; 2
    9538:	1a 82       	std	Y+2, r1	; 0x02
    953a:	1b 82       	std	Y+3, r1	; 0x03
    953c:	a0 91 0b 2c 	lds	r26, 0x2C0B
    9540:	b0 91 0c 2c 	lds	r27, 0x2C0C
    9544:	10 97       	sbiw	r26, 0x00	; 0
    9546:	09 f1       	breq	.+66     	; 0x958a <free+0x60>
    9548:	40 e0       	ldi	r20, 0x00	; 0
    954a:	50 e0       	ldi	r21, 0x00	; 0
    954c:	ac 17       	cp	r26, r28
    954e:	bd 07       	cpc	r27, r29
    9550:	08 f1       	brcs	.+66     	; 0x9594 <free+0x6a>
    9552:	aa 83       	std	Y+2, r26	; 0x02
    9554:	bb 83       	std	Y+3, r27	; 0x03
    9556:	fe 01       	movw	r30, r28
    9558:	21 91       	ld	r18, Z+
    955a:	31 91       	ld	r19, Z+
    955c:	e2 0f       	add	r30, r18
    955e:	f3 1f       	adc	r31, r19
    9560:	ae 17       	cp	r26, r30
    9562:	bf 07       	cpc	r27, r31
    9564:	79 f4       	brne	.+30     	; 0x9584 <free+0x5a>
    9566:	8d 91       	ld	r24, X+
    9568:	9c 91       	ld	r25, X
    956a:	11 97       	sbiw	r26, 0x01	; 1
    956c:	28 0f       	add	r18, r24
    956e:	39 1f       	adc	r19, r25
    9570:	2e 5f       	subi	r18, 0xFE	; 254
    9572:	3f 4f       	sbci	r19, 0xFF	; 255
    9574:	28 83       	st	Y, r18
    9576:	39 83       	std	Y+1, r19	; 0x01
    9578:	12 96       	adiw	r26, 0x02	; 2
    957a:	8d 91       	ld	r24, X+
    957c:	9c 91       	ld	r25, X
    957e:	13 97       	sbiw	r26, 0x03	; 3
    9580:	8a 83       	std	Y+2, r24	; 0x02
    9582:	9b 83       	std	Y+3, r25	; 0x03
    9584:	41 15       	cp	r20, r1
    9586:	51 05       	cpc	r21, r1
    9588:	71 f4       	brne	.+28     	; 0x95a6 <free+0x7c>
    958a:	c0 93 0b 2c 	sts	0x2C0B, r28
    958e:	d0 93 0c 2c 	sts	0x2C0C, r29
    9592:	20 c0       	rjmp	.+64     	; 0x95d4 <free+0xaa>
    9594:	12 96       	adiw	r26, 0x02	; 2
    9596:	8d 91       	ld	r24, X+
    9598:	9c 91       	ld	r25, X
    959a:	13 97       	sbiw	r26, 0x03	; 3
    959c:	ad 01       	movw	r20, r26
    959e:	00 97       	sbiw	r24, 0x00	; 0
    95a0:	11 f0       	breq	.+4      	; 0x95a6 <free+0x7c>
    95a2:	dc 01       	movw	r26, r24
    95a4:	d3 cf       	rjmp	.-90     	; 0x954c <free+0x22>
    95a6:	fa 01       	movw	r30, r20
    95a8:	c2 83       	std	Z+2, r28	; 0x02
    95aa:	d3 83       	std	Z+3, r29	; 0x03
    95ac:	21 91       	ld	r18, Z+
    95ae:	31 91       	ld	r19, Z+
    95b0:	e2 0f       	add	r30, r18
    95b2:	f3 1f       	adc	r31, r19
    95b4:	ce 17       	cp	r28, r30
    95b6:	df 07       	cpc	r29, r31
    95b8:	69 f4       	brne	.+26     	; 0x95d4 <free+0xaa>
    95ba:	88 81       	ld	r24, Y
    95bc:	99 81       	ldd	r25, Y+1	; 0x01
    95be:	28 0f       	add	r18, r24
    95c0:	39 1f       	adc	r19, r25
    95c2:	2e 5f       	subi	r18, 0xFE	; 254
    95c4:	3f 4f       	sbci	r19, 0xFF	; 255
    95c6:	fa 01       	movw	r30, r20
    95c8:	20 83       	st	Z, r18
    95ca:	31 83       	std	Z+1, r19	; 0x01
    95cc:	8a 81       	ldd	r24, Y+2	; 0x02
    95ce:	9b 81       	ldd	r25, Y+3	; 0x03
    95d0:	82 83       	std	Z+2, r24	; 0x02
    95d2:	93 83       	std	Z+3, r25	; 0x03
    95d4:	df 91       	pop	r29
    95d6:	cf 91       	pop	r28
    95d8:	08 95       	ret

000095da <atoi>:
    95da:	fc 01       	movw	r30, r24
    95dc:	88 27       	eor	r24, r24
    95de:	99 27       	eor	r25, r25
    95e0:	e8 94       	clt
    95e2:	21 91       	ld	r18, Z+
    95e4:	20 32       	cpi	r18, 0x20	; 32
    95e6:	e9 f3       	breq	.-6      	; 0x95e2 <atoi+0x8>
    95e8:	29 30       	cpi	r18, 0x09	; 9
    95ea:	10 f0       	brcs	.+4      	; 0x95f0 <atoi+0x16>
    95ec:	2e 30       	cpi	r18, 0x0E	; 14
    95ee:	c8 f3       	brcs	.-14     	; 0x95e2 <atoi+0x8>
    95f0:	2b 32       	cpi	r18, 0x2B	; 43
    95f2:	41 f0       	breq	.+16     	; 0x9604 <atoi+0x2a>
    95f4:	2d 32       	cpi	r18, 0x2D	; 45
    95f6:	39 f4       	brne	.+14     	; 0x9606 <atoi+0x2c>
    95f8:	68 94       	set
    95fa:	04 c0       	rjmp	.+8      	; 0x9604 <atoi+0x2a>
    95fc:	0e 94 bb 4b 	call	0x9776	; 0x9776 <__mulhi_const_10>
    9600:	82 0f       	add	r24, r18
    9602:	91 1d       	adc	r25, r1
    9604:	21 91       	ld	r18, Z+
    9606:	20 53       	subi	r18, 0x30	; 48
    9608:	2a 30       	cpi	r18, 0x0A	; 10
    960a:	c0 f3       	brcs	.-16     	; 0x95fc <atoi+0x22>
    960c:	1e f4       	brtc	.+6      	; 0x9614 <atoi+0x3a>
    960e:	90 95       	com	r25
    9610:	81 95       	neg	r24
    9612:	9f 4f       	sbci	r25, 0xFF	; 255
    9614:	08 95       	ret

00009616 <atol>:
    9616:	1f 93       	push	r17
    9618:	fc 01       	movw	r30, r24
    961a:	99 27       	eor	r25, r25
    961c:	88 27       	eor	r24, r24
    961e:	bc 01       	movw	r22, r24
    9620:	e8 94       	clt
    9622:	11 91       	ld	r17, Z+
    9624:	10 32       	cpi	r17, 0x20	; 32
    9626:	e9 f3       	breq	.-6      	; 0x9622 <atol+0xc>
    9628:	19 30       	cpi	r17, 0x09	; 9
    962a:	10 f0       	brcs	.+4      	; 0x9630 <atol+0x1a>
    962c:	1e 30       	cpi	r17, 0x0E	; 14
    962e:	c8 f3       	brcs	.-14     	; 0x9622 <atol+0xc>
    9630:	1b 32       	cpi	r17, 0x2B	; 43
    9632:	51 f0       	breq	.+20     	; 0x9648 <atol+0x32>
    9634:	1d 32       	cpi	r17, 0x2D	; 45
    9636:	49 f4       	brne	.+18     	; 0x964a <atol+0x34>
    9638:	68 94       	set
    963a:	06 c0       	rjmp	.+12     	; 0x9648 <atol+0x32>
    963c:	0e 94 a6 4b 	call	0x974c	; 0x974c <__mulsi_const_10>
    9640:	61 0f       	add	r22, r17
    9642:	71 1d       	adc	r23, r1
    9644:	81 1d       	adc	r24, r1
    9646:	91 1d       	adc	r25, r1
    9648:	11 91       	ld	r17, Z+
    964a:	10 53       	subi	r17, 0x30	; 48
    964c:	1a 30       	cpi	r17, 0x0A	; 10
    964e:	b0 f3       	brcs	.-20     	; 0x963c <atol+0x26>
    9650:	3e f4       	brtc	.+14     	; 0x9660 <atol+0x4a>
    9652:	90 95       	com	r25
    9654:	80 95       	com	r24
    9656:	70 95       	com	r23
    9658:	61 95       	neg	r22
    965a:	7f 4f       	sbci	r23, 0xFF	; 255
    965c:	8f 4f       	sbci	r24, 0xFF	; 255
    965e:	9f 4f       	sbci	r25, 0xFF	; 255
    9660:	1f 91       	pop	r17
    9662:	08 95       	ret

00009664 <strtok>:
    9664:	47 e0       	ldi	r20, 0x07	; 7
    9666:	5c e2       	ldi	r21, 0x2C	; 44
    9668:	0e 94 7f 4b 	call	0x96fe	; 0x96fe <strtok_r>
    966c:	08 95       	ret

0000966e <memcpy>:
    966e:	fb 01       	movw	r30, r22
    9670:	dc 01       	movw	r26, r24
    9672:	02 c0       	rjmp	.+4      	; 0x9678 <memcpy+0xa>
    9674:	01 90       	ld	r0, Z+
    9676:	0d 92       	st	X+, r0
    9678:	41 50       	subi	r20, 0x01	; 1
    967a:	50 40       	sbci	r21, 0x00	; 0
    967c:	d8 f7       	brcc	.-10     	; 0x9674 <memcpy+0x6>
    967e:	08 95       	ret

00009680 <memset>:
    9680:	dc 01       	movw	r26, r24
    9682:	01 c0       	rjmp	.+2      	; 0x9686 <memset+0x6>
    9684:	6d 93       	st	X+, r22
    9686:	41 50       	subi	r20, 0x01	; 1
    9688:	50 40       	sbci	r21, 0x00	; 0
    968a:	e0 f7       	brcc	.-8      	; 0x9684 <memset+0x4>
    968c:	08 95       	ret

0000968e <strchr>:
    968e:	fc 01       	movw	r30, r24
    9690:	81 91       	ld	r24, Z+
    9692:	86 17       	cp	r24, r22
    9694:	21 f0       	breq	.+8      	; 0x969e <strchr+0x10>
    9696:	88 23       	and	r24, r24
    9698:	d9 f7       	brne	.-10     	; 0x9690 <strchr+0x2>
    969a:	99 27       	eor	r25, r25
    969c:	08 95       	ret
    969e:	31 97       	sbiw	r30, 0x01	; 1
    96a0:	cf 01       	movw	r24, r30
    96a2:	08 95       	ret

000096a4 <strcmp>:
    96a4:	fb 01       	movw	r30, r22
    96a6:	dc 01       	movw	r26, r24
    96a8:	8d 91       	ld	r24, X+
    96aa:	01 90       	ld	r0, Z+
    96ac:	80 19       	sub	r24, r0
    96ae:	01 10       	cpse	r0, r1
    96b0:	d9 f3       	breq	.-10     	; 0x96a8 <strcmp+0x4>
    96b2:	99 0b       	sbc	r25, r25
    96b4:	08 95       	ret

000096b6 <strcpy>:
    96b6:	fb 01       	movw	r30, r22
    96b8:	dc 01       	movw	r26, r24
    96ba:	01 90       	ld	r0, Z+
    96bc:	0d 92       	st	X+, r0
    96be:	00 20       	and	r0, r0
    96c0:	e1 f7       	brne	.-8      	; 0x96ba <strcpy+0x4>
    96c2:	08 95       	ret

000096c4 <strncpy>:
    96c4:	fb 01       	movw	r30, r22
    96c6:	dc 01       	movw	r26, r24
    96c8:	41 50       	subi	r20, 0x01	; 1
    96ca:	50 40       	sbci	r21, 0x00	; 0
    96cc:	48 f0       	brcs	.+18     	; 0x96e0 <strncpy+0x1c>
    96ce:	01 90       	ld	r0, Z+
    96d0:	0d 92       	st	X+, r0
    96d2:	00 20       	and	r0, r0
    96d4:	c9 f7       	brne	.-14     	; 0x96c8 <strncpy+0x4>
    96d6:	01 c0       	rjmp	.+2      	; 0x96da <strncpy+0x16>
    96d8:	1d 92       	st	X+, r1
    96da:	41 50       	subi	r20, 0x01	; 1
    96dc:	50 40       	sbci	r21, 0x00	; 0
    96de:	e0 f7       	brcc	.-8      	; 0x96d8 <strncpy+0x14>
    96e0:	08 95       	ret

000096e2 <strpbrk>:
    96e2:	dc 01       	movw	r26, r24
    96e4:	99 27       	eor	r25, r25
    96e6:	8d 91       	ld	r24, X+
    96e8:	88 23       	and	r24, r24
    96ea:	41 f0       	breq	.+16     	; 0x96fc <strpbrk+0x1a>
    96ec:	fb 01       	movw	r30, r22
    96ee:	01 90       	ld	r0, Z+
    96f0:	08 16       	cp	r0, r24
    96f2:	01 10       	cpse	r0, r1
    96f4:	e1 f7       	brne	.-8      	; 0x96ee <strpbrk+0xc>
    96f6:	b9 f7       	brne	.-18     	; 0x96e6 <strpbrk+0x4>
    96f8:	11 97       	sbiw	r26, 0x01	; 1
    96fa:	cd 01       	movw	r24, r26
    96fc:	08 95       	ret

000096fe <strtok_r>:
    96fe:	fa 01       	movw	r30, r20
    9700:	a1 91       	ld	r26, Z+
    9702:	b0 81       	ld	r27, Z
    9704:	00 97       	sbiw	r24, 0x00	; 0
    9706:	19 f4       	brne	.+6      	; 0x970e <strtok_r+0x10>
    9708:	10 97       	sbiw	r26, 0x00	; 0
    970a:	e1 f0       	breq	.+56     	; 0x9744 <strtok_r+0x46>
    970c:	cd 01       	movw	r24, r26
    970e:	dc 01       	movw	r26, r24
    9710:	cd 01       	movw	r24, r26
    9712:	0d 90       	ld	r0, X+
    9714:	00 20       	and	r0, r0
    9716:	11 f4       	brne	.+4      	; 0x971c <strtok_r+0x1e>
    9718:	c0 01       	movw	r24, r0
    971a:	13 c0       	rjmp	.+38     	; 0x9742 <strtok_r+0x44>
    971c:	fb 01       	movw	r30, r22
    971e:	21 91       	ld	r18, Z+
    9720:	22 23       	and	r18, r18
    9722:	19 f0       	breq	.+6      	; 0x972a <strtok_r+0x2c>
    9724:	20 15       	cp	r18, r0
    9726:	d9 f7       	brne	.-10     	; 0x971e <strtok_r+0x20>
    9728:	f3 cf       	rjmp	.-26     	; 0x9710 <strtok_r+0x12>
    972a:	fb 01       	movw	r30, r22
    972c:	21 91       	ld	r18, Z+
    972e:	20 15       	cp	r18, r0
    9730:	19 f4       	brne	.+6      	; 0x9738 <strtok_r+0x3a>
    9732:	1e 92       	st	-X, r1
    9734:	11 96       	adiw	r26, 0x01	; 1
    9736:	06 c0       	rjmp	.+12     	; 0x9744 <strtok_r+0x46>
    9738:	22 23       	and	r18, r18
    973a:	c1 f7       	brne	.-16     	; 0x972c <strtok_r+0x2e>
    973c:	0d 90       	ld	r0, X+
    973e:	00 20       	and	r0, r0
    9740:	a1 f7       	brne	.-24     	; 0x972a <strtok_r+0x2c>
    9742:	d0 01       	movw	r26, r0
    9744:	fa 01       	movw	r30, r20
    9746:	a1 93       	st	Z+, r26
    9748:	b0 83       	st	Z, r27
    974a:	08 95       	ret

0000974c <__mulsi_const_10>:
    974c:	59 2f       	mov	r21, r25
    974e:	48 2f       	mov	r20, r24
    9750:	37 2f       	mov	r19, r23
    9752:	26 2f       	mov	r18, r22
    9754:	66 0f       	add	r22, r22
    9756:	77 1f       	adc	r23, r23
    9758:	88 1f       	adc	r24, r24
    975a:	99 1f       	adc	r25, r25
    975c:	66 0f       	add	r22, r22
    975e:	77 1f       	adc	r23, r23
    9760:	88 1f       	adc	r24, r24
    9762:	99 1f       	adc	r25, r25
    9764:	62 0f       	add	r22, r18
    9766:	73 1f       	adc	r23, r19
    9768:	84 1f       	adc	r24, r20
    976a:	95 1f       	adc	r25, r21
    976c:	66 0f       	add	r22, r22
    976e:	77 1f       	adc	r23, r23
    9770:	88 1f       	adc	r24, r24
    9772:	99 1f       	adc	r25, r25
    9774:	08 95       	ret

00009776 <__mulhi_const_10>:
    9776:	7a e0       	ldi	r23, 0x0A	; 10
    9778:	97 9f       	mul	r25, r23
    977a:	90 2d       	mov	r25, r0
    977c:	87 9f       	mul	r24, r23
    977e:	80 2d       	mov	r24, r0
    9780:	91 0d       	add	r25, r1
    9782:	11 24       	eor	r1, r1
    9784:	08 95       	ret

00009786 <sprintf>:
    9786:	0f 93       	push	r16
    9788:	1f 93       	push	r17
    978a:	df 93       	push	r29
    978c:	cf 93       	push	r28
    978e:	cd b7       	in	r28, 0x3d	; 61
    9790:	de b7       	in	r29, 0x3e	; 62
    9792:	2e 97       	sbiw	r28, 0x0e	; 14
    9794:	cd bf       	out	0x3d, r28	; 61
    9796:	de bf       	out	0x3e, r29	; 62
    9798:	0e 89       	ldd	r16, Y+22	; 0x16
    979a:	1f 89       	ldd	r17, Y+23	; 0x17
    979c:	86 e0       	ldi	r24, 0x06	; 6
    979e:	8c 83       	std	Y+4, r24	; 0x04
    97a0:	09 83       	std	Y+1, r16	; 0x01
    97a2:	1a 83       	std	Y+2, r17	; 0x02
    97a4:	8f ef       	ldi	r24, 0xFF	; 255
    97a6:	9f e7       	ldi	r25, 0x7F	; 127
    97a8:	8d 83       	std	Y+5, r24	; 0x05
    97aa:	9e 83       	std	Y+6, r25	; 0x06
    97ac:	9e 01       	movw	r18, r28
    97ae:	26 5e       	subi	r18, 0xE6	; 230
    97b0:	3f 4f       	sbci	r19, 0xFF	; 255
    97b2:	ce 01       	movw	r24, r28
    97b4:	01 96       	adiw	r24, 0x01	; 1
    97b6:	68 8d       	ldd	r22, Y+24	; 0x18
    97b8:	79 8d       	ldd	r23, Y+25	; 0x19
    97ba:	a9 01       	movw	r20, r18
    97bc:	0e 94 0b 4c 	call	0x9816	; 0x9816 <vfprintf>
    97c0:	2f 81       	ldd	r18, Y+7	; 0x07
    97c2:	38 85       	ldd	r19, Y+8	; 0x08
    97c4:	02 0f       	add	r16, r18
    97c6:	13 1f       	adc	r17, r19
    97c8:	f8 01       	movw	r30, r16
    97ca:	10 82       	st	Z, r1
    97cc:	2e 96       	adiw	r28, 0x0e	; 14
    97ce:	cd bf       	out	0x3d, r28	; 61
    97d0:	de bf       	out	0x3e, r29	; 62
    97d2:	cf 91       	pop	r28
    97d4:	df 91       	pop	r29
    97d6:	1f 91       	pop	r17
    97d8:	0f 91       	pop	r16
    97da:	08 95       	ret

000097dc <sscanf>:
    97dc:	df 93       	push	r29
    97de:	cf 93       	push	r28
    97e0:	cd b7       	in	r28, 0x3d	; 61
    97e2:	de b7       	in	r29, 0x3e	; 62
    97e4:	2e 97       	sbiw	r28, 0x0e	; 14
    97e6:	cd bf       	out	0x3d, r28	; 61
    97e8:	de bf       	out	0x3e, r29	; 62
    97ea:	85 e0       	ldi	r24, 0x05	; 5
    97ec:	8c 83       	std	Y+4, r24	; 0x04
    97ee:	8c 89       	ldd	r24, Y+20	; 0x14
    97f0:	9d 89       	ldd	r25, Y+21	; 0x15
    97f2:	89 83       	std	Y+1, r24	; 0x01
    97f4:	9a 83       	std	Y+2, r25	; 0x02
    97f6:	9e 01       	movw	r18, r28
    97f8:	28 5e       	subi	r18, 0xE8	; 232
    97fa:	3f 4f       	sbci	r19, 0xFF	; 255
    97fc:	ce 01       	movw	r24, r28
    97fe:	01 96       	adiw	r24, 0x01	; 1
    9800:	6e 89       	ldd	r22, Y+22	; 0x16
    9802:	7f 89       	ldd	r23, Y+23	; 0x17
    9804:	a9 01       	movw	r20, r18
    9806:	0e 94 b4 4f 	call	0x9f68	; 0x9f68 <vfscanf>
    980a:	2e 96       	adiw	r28, 0x0e	; 14
    980c:	cd bf       	out	0x3d, r28	; 61
    980e:	de bf       	out	0x3e, r29	; 62
    9810:	cf 91       	pop	r28
    9812:	df 91       	pop	r29
    9814:	08 95       	ret

00009816 <vfprintf>:
    9816:	2f 92       	push	r2
    9818:	3f 92       	push	r3
    981a:	4f 92       	push	r4
    981c:	5f 92       	push	r5
    981e:	6f 92       	push	r6
    9820:	7f 92       	push	r7
    9822:	8f 92       	push	r8
    9824:	9f 92       	push	r9
    9826:	af 92       	push	r10
    9828:	bf 92       	push	r11
    982a:	cf 92       	push	r12
    982c:	df 92       	push	r13
    982e:	ef 92       	push	r14
    9830:	ff 92       	push	r15
    9832:	0f 93       	push	r16
    9834:	1f 93       	push	r17
    9836:	df 93       	push	r29
    9838:	cf 93       	push	r28
    983a:	cd b7       	in	r28, 0x3d	; 61
    983c:	de b7       	in	r29, 0x3e	; 62
    983e:	2b 97       	sbiw	r28, 0x0b	; 11
    9840:	cd bf       	out	0x3d, r28	; 61
    9842:	de bf       	out	0x3e, r29	; 62
    9844:	3c 01       	movw	r6, r24
    9846:	2b 01       	movw	r4, r22
    9848:	5a 01       	movw	r10, r20
    984a:	fc 01       	movw	r30, r24
    984c:	16 82       	std	Z+6, r1	; 0x06
    984e:	17 82       	std	Z+7, r1	; 0x07
    9850:	83 81       	ldd	r24, Z+3	; 0x03
    9852:	81 fd       	sbrc	r24, 1
    9854:	03 c0       	rjmp	.+6      	; 0x985c <vfprintf+0x46>
    9856:	6f ef       	ldi	r22, 0xFF	; 255
    9858:	7f ef       	ldi	r23, 0xFF	; 255
    985a:	c6 c1       	rjmp	.+908    	; 0x9be8 <vfprintf+0x3d2>
    985c:	9a e0       	ldi	r25, 0x0A	; 10
    985e:	89 2e       	mov	r8, r25
    9860:	1e 01       	movw	r2, r28
    9862:	08 94       	sec
    9864:	21 1c       	adc	r2, r1
    9866:	31 1c       	adc	r3, r1
    9868:	f3 01       	movw	r30, r6
    986a:	23 81       	ldd	r18, Z+3	; 0x03
    986c:	f2 01       	movw	r30, r4
    986e:	23 fd       	sbrc	r18, 3
    9870:	85 91       	lpm	r24, Z+
    9872:	23 ff       	sbrs	r18, 3
    9874:	81 91       	ld	r24, Z+
    9876:	2f 01       	movw	r4, r30
    9878:	88 23       	and	r24, r24
    987a:	09 f4       	brne	.+2      	; 0x987e <vfprintf+0x68>
    987c:	b2 c1       	rjmp	.+868    	; 0x9be2 <vfprintf+0x3cc>
    987e:	85 32       	cpi	r24, 0x25	; 37
    9880:	39 f4       	brne	.+14     	; 0x9890 <vfprintf+0x7a>
    9882:	23 fd       	sbrc	r18, 3
    9884:	85 91       	lpm	r24, Z+
    9886:	23 ff       	sbrs	r18, 3
    9888:	81 91       	ld	r24, Z+
    988a:	2f 01       	movw	r4, r30
    988c:	85 32       	cpi	r24, 0x25	; 37
    988e:	29 f4       	brne	.+10     	; 0x989a <vfprintf+0x84>
    9890:	90 e0       	ldi	r25, 0x00	; 0
    9892:	b3 01       	movw	r22, r6
    9894:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9898:	e7 cf       	rjmp	.-50     	; 0x9868 <vfprintf+0x52>
    989a:	98 2f       	mov	r25, r24
    989c:	ff 24       	eor	r15, r15
    989e:	ee 24       	eor	r14, r14
    98a0:	99 24       	eor	r9, r9
    98a2:	ff e1       	ldi	r31, 0x1F	; 31
    98a4:	ff 15       	cp	r31, r15
    98a6:	d0 f0       	brcs	.+52     	; 0x98dc <vfprintf+0xc6>
    98a8:	9b 32       	cpi	r25, 0x2B	; 43
    98aa:	69 f0       	breq	.+26     	; 0x98c6 <vfprintf+0xb0>
    98ac:	9c 32       	cpi	r25, 0x2C	; 44
    98ae:	28 f4       	brcc	.+10     	; 0x98ba <vfprintf+0xa4>
    98b0:	90 32       	cpi	r25, 0x20	; 32
    98b2:	59 f0       	breq	.+22     	; 0x98ca <vfprintf+0xb4>
    98b4:	93 32       	cpi	r25, 0x23	; 35
    98b6:	91 f4       	brne	.+36     	; 0x98dc <vfprintf+0xc6>
    98b8:	0e c0       	rjmp	.+28     	; 0x98d6 <vfprintf+0xc0>
    98ba:	9d 32       	cpi	r25, 0x2D	; 45
    98bc:	49 f0       	breq	.+18     	; 0x98d0 <vfprintf+0xba>
    98be:	90 33       	cpi	r25, 0x30	; 48
    98c0:	69 f4       	brne	.+26     	; 0x98dc <vfprintf+0xc6>
    98c2:	41 e0       	ldi	r20, 0x01	; 1
    98c4:	24 c0       	rjmp	.+72     	; 0x990e <vfprintf+0xf8>
    98c6:	52 e0       	ldi	r21, 0x02	; 2
    98c8:	f5 2a       	or	r15, r21
    98ca:	84 e0       	ldi	r24, 0x04	; 4
    98cc:	f8 2a       	or	r15, r24
    98ce:	28 c0       	rjmp	.+80     	; 0x9920 <vfprintf+0x10a>
    98d0:	98 e0       	ldi	r25, 0x08	; 8
    98d2:	f9 2a       	or	r15, r25
    98d4:	25 c0       	rjmp	.+74     	; 0x9920 <vfprintf+0x10a>
    98d6:	e0 e1       	ldi	r30, 0x10	; 16
    98d8:	fe 2a       	or	r15, r30
    98da:	22 c0       	rjmp	.+68     	; 0x9920 <vfprintf+0x10a>
    98dc:	f7 fc       	sbrc	r15, 7
    98de:	29 c0       	rjmp	.+82     	; 0x9932 <vfprintf+0x11c>
    98e0:	89 2f       	mov	r24, r25
    98e2:	80 53       	subi	r24, 0x30	; 48
    98e4:	8a 30       	cpi	r24, 0x0A	; 10
    98e6:	70 f4       	brcc	.+28     	; 0x9904 <vfprintf+0xee>
    98e8:	f6 fe       	sbrs	r15, 6
    98ea:	05 c0       	rjmp	.+10     	; 0x98f6 <vfprintf+0xe0>
    98ec:	98 9c       	mul	r9, r8
    98ee:	90 2c       	mov	r9, r0
    98f0:	11 24       	eor	r1, r1
    98f2:	98 0e       	add	r9, r24
    98f4:	15 c0       	rjmp	.+42     	; 0x9920 <vfprintf+0x10a>
    98f6:	e8 9c       	mul	r14, r8
    98f8:	e0 2c       	mov	r14, r0
    98fa:	11 24       	eor	r1, r1
    98fc:	e8 0e       	add	r14, r24
    98fe:	f0 e2       	ldi	r31, 0x20	; 32
    9900:	ff 2a       	or	r15, r31
    9902:	0e c0       	rjmp	.+28     	; 0x9920 <vfprintf+0x10a>
    9904:	9e 32       	cpi	r25, 0x2E	; 46
    9906:	29 f4       	brne	.+10     	; 0x9912 <vfprintf+0xfc>
    9908:	f6 fc       	sbrc	r15, 6
    990a:	6b c1       	rjmp	.+726    	; 0x9be2 <vfprintf+0x3cc>
    990c:	40 e4       	ldi	r20, 0x40	; 64
    990e:	f4 2a       	or	r15, r20
    9910:	07 c0       	rjmp	.+14     	; 0x9920 <vfprintf+0x10a>
    9912:	9c 36       	cpi	r25, 0x6C	; 108
    9914:	19 f4       	brne	.+6      	; 0x991c <vfprintf+0x106>
    9916:	50 e8       	ldi	r21, 0x80	; 128
    9918:	f5 2a       	or	r15, r21
    991a:	02 c0       	rjmp	.+4      	; 0x9920 <vfprintf+0x10a>
    991c:	98 36       	cpi	r25, 0x68	; 104
    991e:	49 f4       	brne	.+18     	; 0x9932 <vfprintf+0x11c>
    9920:	f2 01       	movw	r30, r4
    9922:	23 fd       	sbrc	r18, 3
    9924:	95 91       	lpm	r25, Z+
    9926:	23 ff       	sbrs	r18, 3
    9928:	91 91       	ld	r25, Z+
    992a:	2f 01       	movw	r4, r30
    992c:	99 23       	and	r25, r25
    992e:	09 f0       	breq	.+2      	; 0x9932 <vfprintf+0x11c>
    9930:	b8 cf       	rjmp	.-144    	; 0x98a2 <vfprintf+0x8c>
    9932:	89 2f       	mov	r24, r25
    9934:	85 54       	subi	r24, 0x45	; 69
    9936:	83 30       	cpi	r24, 0x03	; 3
    9938:	18 f0       	brcs	.+6      	; 0x9940 <vfprintf+0x12a>
    993a:	80 52       	subi	r24, 0x20	; 32
    993c:	83 30       	cpi	r24, 0x03	; 3
    993e:	38 f4       	brcc	.+14     	; 0x994e <vfprintf+0x138>
    9940:	44 e0       	ldi	r20, 0x04	; 4
    9942:	50 e0       	ldi	r21, 0x00	; 0
    9944:	a4 0e       	add	r10, r20
    9946:	b5 1e       	adc	r11, r21
    9948:	5f e3       	ldi	r21, 0x3F	; 63
    994a:	59 83       	std	Y+1, r21	; 0x01
    994c:	0f c0       	rjmp	.+30     	; 0x996c <vfprintf+0x156>
    994e:	93 36       	cpi	r25, 0x63	; 99
    9950:	31 f0       	breq	.+12     	; 0x995e <vfprintf+0x148>
    9952:	93 37       	cpi	r25, 0x73	; 115
    9954:	79 f0       	breq	.+30     	; 0x9974 <vfprintf+0x15e>
    9956:	93 35       	cpi	r25, 0x53	; 83
    9958:	09 f0       	breq	.+2      	; 0x995c <vfprintf+0x146>
    995a:	56 c0       	rjmp	.+172    	; 0x9a08 <vfprintf+0x1f2>
    995c:	20 c0       	rjmp	.+64     	; 0x999e <vfprintf+0x188>
    995e:	f5 01       	movw	r30, r10
    9960:	80 81       	ld	r24, Z
    9962:	89 83       	std	Y+1, r24	; 0x01
    9964:	42 e0       	ldi	r20, 0x02	; 2
    9966:	50 e0       	ldi	r21, 0x00	; 0
    9968:	a4 0e       	add	r10, r20
    996a:	b5 1e       	adc	r11, r21
    996c:	61 01       	movw	r12, r2
    996e:	01 e0       	ldi	r16, 0x01	; 1
    9970:	10 e0       	ldi	r17, 0x00	; 0
    9972:	12 c0       	rjmp	.+36     	; 0x9998 <vfprintf+0x182>
    9974:	f5 01       	movw	r30, r10
    9976:	c0 80       	ld	r12, Z
    9978:	d1 80       	ldd	r13, Z+1	; 0x01
    997a:	f6 fc       	sbrc	r15, 6
    997c:	03 c0       	rjmp	.+6      	; 0x9984 <vfprintf+0x16e>
    997e:	6f ef       	ldi	r22, 0xFF	; 255
    9980:	7f ef       	ldi	r23, 0xFF	; 255
    9982:	02 c0       	rjmp	.+4      	; 0x9988 <vfprintf+0x172>
    9984:	69 2d       	mov	r22, r9
    9986:	70 e0       	ldi	r23, 0x00	; 0
    9988:	42 e0       	ldi	r20, 0x02	; 2
    998a:	50 e0       	ldi	r21, 0x00	; 0
    998c:	a4 0e       	add	r10, r20
    998e:	b5 1e       	adc	r11, r21
    9990:	c6 01       	movw	r24, r12
    9992:	0e 94 f5 50 	call	0xa1ea	; 0xa1ea <strnlen>
    9996:	8c 01       	movw	r16, r24
    9998:	5f e7       	ldi	r21, 0x7F	; 127
    999a:	f5 22       	and	r15, r21
    999c:	14 c0       	rjmp	.+40     	; 0x99c6 <vfprintf+0x1b0>
    999e:	f5 01       	movw	r30, r10
    99a0:	c0 80       	ld	r12, Z
    99a2:	d1 80       	ldd	r13, Z+1	; 0x01
    99a4:	f6 fc       	sbrc	r15, 6
    99a6:	03 c0       	rjmp	.+6      	; 0x99ae <vfprintf+0x198>
    99a8:	6f ef       	ldi	r22, 0xFF	; 255
    99aa:	7f ef       	ldi	r23, 0xFF	; 255
    99ac:	02 c0       	rjmp	.+4      	; 0x99b2 <vfprintf+0x19c>
    99ae:	69 2d       	mov	r22, r9
    99b0:	70 e0       	ldi	r23, 0x00	; 0
    99b2:	42 e0       	ldi	r20, 0x02	; 2
    99b4:	50 e0       	ldi	r21, 0x00	; 0
    99b6:	a4 0e       	add	r10, r20
    99b8:	b5 1e       	adc	r11, r21
    99ba:	c6 01       	movw	r24, r12
    99bc:	0e 94 ea 50 	call	0xa1d4	; 0xa1d4 <strnlen_P>
    99c0:	8c 01       	movw	r16, r24
    99c2:	50 e8       	ldi	r21, 0x80	; 128
    99c4:	f5 2a       	or	r15, r21
    99c6:	f3 fe       	sbrs	r15, 3
    99c8:	07 c0       	rjmp	.+14     	; 0x99d8 <vfprintf+0x1c2>
    99ca:	1a c0       	rjmp	.+52     	; 0x9a00 <vfprintf+0x1ea>
    99cc:	80 e2       	ldi	r24, 0x20	; 32
    99ce:	90 e0       	ldi	r25, 0x00	; 0
    99d0:	b3 01       	movw	r22, r6
    99d2:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    99d6:	ea 94       	dec	r14
    99d8:	8e 2d       	mov	r24, r14
    99da:	90 e0       	ldi	r25, 0x00	; 0
    99dc:	08 17       	cp	r16, r24
    99de:	19 07       	cpc	r17, r25
    99e0:	a8 f3       	brcs	.-22     	; 0x99cc <vfprintf+0x1b6>
    99e2:	0e c0       	rjmp	.+28     	; 0x9a00 <vfprintf+0x1ea>
    99e4:	f6 01       	movw	r30, r12
    99e6:	f7 fc       	sbrc	r15, 7
    99e8:	85 91       	lpm	r24, Z+
    99ea:	f7 fe       	sbrs	r15, 7
    99ec:	81 91       	ld	r24, Z+
    99ee:	6f 01       	movw	r12, r30
    99f0:	90 e0       	ldi	r25, 0x00	; 0
    99f2:	b3 01       	movw	r22, r6
    99f4:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    99f8:	e1 10       	cpse	r14, r1
    99fa:	ea 94       	dec	r14
    99fc:	01 50       	subi	r16, 0x01	; 1
    99fe:	10 40       	sbci	r17, 0x00	; 0
    9a00:	01 15       	cp	r16, r1
    9a02:	11 05       	cpc	r17, r1
    9a04:	79 f7       	brne	.-34     	; 0x99e4 <vfprintf+0x1ce>
    9a06:	ea c0       	rjmp	.+468    	; 0x9bdc <vfprintf+0x3c6>
    9a08:	94 36       	cpi	r25, 0x64	; 100
    9a0a:	11 f0       	breq	.+4      	; 0x9a10 <vfprintf+0x1fa>
    9a0c:	99 36       	cpi	r25, 0x69	; 105
    9a0e:	69 f5       	brne	.+90     	; 0x9a6a <vfprintf+0x254>
    9a10:	f7 fe       	sbrs	r15, 7
    9a12:	08 c0       	rjmp	.+16     	; 0x9a24 <vfprintf+0x20e>
    9a14:	f5 01       	movw	r30, r10
    9a16:	20 81       	ld	r18, Z
    9a18:	31 81       	ldd	r19, Z+1	; 0x01
    9a1a:	42 81       	ldd	r20, Z+2	; 0x02
    9a1c:	53 81       	ldd	r21, Z+3	; 0x03
    9a1e:	84 e0       	ldi	r24, 0x04	; 4
    9a20:	90 e0       	ldi	r25, 0x00	; 0
    9a22:	0a c0       	rjmp	.+20     	; 0x9a38 <vfprintf+0x222>
    9a24:	f5 01       	movw	r30, r10
    9a26:	80 81       	ld	r24, Z
    9a28:	91 81       	ldd	r25, Z+1	; 0x01
    9a2a:	9c 01       	movw	r18, r24
    9a2c:	44 27       	eor	r20, r20
    9a2e:	37 fd       	sbrc	r19, 7
    9a30:	40 95       	com	r20
    9a32:	54 2f       	mov	r21, r20
    9a34:	82 e0       	ldi	r24, 0x02	; 2
    9a36:	90 e0       	ldi	r25, 0x00	; 0
    9a38:	a8 0e       	add	r10, r24
    9a3a:	b9 1e       	adc	r11, r25
    9a3c:	9f e6       	ldi	r25, 0x6F	; 111
    9a3e:	f9 22       	and	r15, r25
    9a40:	57 ff       	sbrs	r21, 7
    9a42:	09 c0       	rjmp	.+18     	; 0x9a56 <vfprintf+0x240>
    9a44:	50 95       	com	r21
    9a46:	40 95       	com	r20
    9a48:	30 95       	com	r19
    9a4a:	21 95       	neg	r18
    9a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    9a4e:	4f 4f       	sbci	r20, 0xFF	; 255
    9a50:	5f 4f       	sbci	r21, 0xFF	; 255
    9a52:	e0 e8       	ldi	r30, 0x80	; 128
    9a54:	fe 2a       	or	r15, r30
    9a56:	ca 01       	movw	r24, r20
    9a58:	b9 01       	movw	r22, r18
    9a5a:	a1 01       	movw	r20, r2
    9a5c:	2a e0       	ldi	r18, 0x0A	; 10
    9a5e:	30 e0       	ldi	r19, 0x00	; 0
    9a60:	0e 94 88 51 	call	0xa310	; 0xa310 <__ultoa_invert>
    9a64:	d8 2e       	mov	r13, r24
    9a66:	d2 18       	sub	r13, r2
    9a68:	40 c0       	rjmp	.+128    	; 0x9aea <vfprintf+0x2d4>
    9a6a:	95 37       	cpi	r25, 0x75	; 117
    9a6c:	29 f4       	brne	.+10     	; 0x9a78 <vfprintf+0x262>
    9a6e:	1f 2d       	mov	r17, r15
    9a70:	1f 7e       	andi	r17, 0xEF	; 239
    9a72:	2a e0       	ldi	r18, 0x0A	; 10
    9a74:	30 e0       	ldi	r19, 0x00	; 0
    9a76:	1d c0       	rjmp	.+58     	; 0x9ab2 <vfprintf+0x29c>
    9a78:	1f 2d       	mov	r17, r15
    9a7a:	19 7f       	andi	r17, 0xF9	; 249
    9a7c:	9f 36       	cpi	r25, 0x6F	; 111
    9a7e:	61 f0       	breq	.+24     	; 0x9a98 <vfprintf+0x282>
    9a80:	90 37       	cpi	r25, 0x70	; 112
    9a82:	20 f4       	brcc	.+8      	; 0x9a8c <vfprintf+0x276>
    9a84:	98 35       	cpi	r25, 0x58	; 88
    9a86:	09 f0       	breq	.+2      	; 0x9a8a <vfprintf+0x274>
    9a88:	ac c0       	rjmp	.+344    	; 0x9be2 <vfprintf+0x3cc>
    9a8a:	0f c0       	rjmp	.+30     	; 0x9aaa <vfprintf+0x294>
    9a8c:	90 37       	cpi	r25, 0x70	; 112
    9a8e:	39 f0       	breq	.+14     	; 0x9a9e <vfprintf+0x288>
    9a90:	98 37       	cpi	r25, 0x78	; 120
    9a92:	09 f0       	breq	.+2      	; 0x9a96 <vfprintf+0x280>
    9a94:	a6 c0       	rjmp	.+332    	; 0x9be2 <vfprintf+0x3cc>
    9a96:	04 c0       	rjmp	.+8      	; 0x9aa0 <vfprintf+0x28a>
    9a98:	28 e0       	ldi	r18, 0x08	; 8
    9a9a:	30 e0       	ldi	r19, 0x00	; 0
    9a9c:	0a c0       	rjmp	.+20     	; 0x9ab2 <vfprintf+0x29c>
    9a9e:	10 61       	ori	r17, 0x10	; 16
    9aa0:	14 fd       	sbrc	r17, 4
    9aa2:	14 60       	ori	r17, 0x04	; 4
    9aa4:	20 e1       	ldi	r18, 0x10	; 16
    9aa6:	30 e0       	ldi	r19, 0x00	; 0
    9aa8:	04 c0       	rjmp	.+8      	; 0x9ab2 <vfprintf+0x29c>
    9aaa:	14 fd       	sbrc	r17, 4
    9aac:	16 60       	ori	r17, 0x06	; 6
    9aae:	20 e1       	ldi	r18, 0x10	; 16
    9ab0:	32 e0       	ldi	r19, 0x02	; 2
    9ab2:	17 ff       	sbrs	r17, 7
    9ab4:	08 c0       	rjmp	.+16     	; 0x9ac6 <vfprintf+0x2b0>
    9ab6:	f5 01       	movw	r30, r10
    9ab8:	60 81       	ld	r22, Z
    9aba:	71 81       	ldd	r23, Z+1	; 0x01
    9abc:	82 81       	ldd	r24, Z+2	; 0x02
    9abe:	93 81       	ldd	r25, Z+3	; 0x03
    9ac0:	44 e0       	ldi	r20, 0x04	; 4
    9ac2:	50 e0       	ldi	r21, 0x00	; 0
    9ac4:	08 c0       	rjmp	.+16     	; 0x9ad6 <vfprintf+0x2c0>
    9ac6:	f5 01       	movw	r30, r10
    9ac8:	80 81       	ld	r24, Z
    9aca:	91 81       	ldd	r25, Z+1	; 0x01
    9acc:	bc 01       	movw	r22, r24
    9ace:	80 e0       	ldi	r24, 0x00	; 0
    9ad0:	90 e0       	ldi	r25, 0x00	; 0
    9ad2:	42 e0       	ldi	r20, 0x02	; 2
    9ad4:	50 e0       	ldi	r21, 0x00	; 0
    9ad6:	a4 0e       	add	r10, r20
    9ad8:	b5 1e       	adc	r11, r21
    9ada:	a1 01       	movw	r20, r2
    9adc:	0e 94 88 51 	call	0xa310	; 0xa310 <__ultoa_invert>
    9ae0:	d8 2e       	mov	r13, r24
    9ae2:	d2 18       	sub	r13, r2
    9ae4:	8f e7       	ldi	r24, 0x7F	; 127
    9ae6:	f8 2e       	mov	r15, r24
    9ae8:	f1 22       	and	r15, r17
    9aea:	f6 fe       	sbrs	r15, 6
    9aec:	0b c0       	rjmp	.+22     	; 0x9b04 <vfprintf+0x2ee>
    9aee:	5e ef       	ldi	r21, 0xFE	; 254
    9af0:	f5 22       	and	r15, r21
    9af2:	d9 14       	cp	r13, r9
    9af4:	38 f4       	brcc	.+14     	; 0x9b04 <vfprintf+0x2ee>
    9af6:	f4 fe       	sbrs	r15, 4
    9af8:	07 c0       	rjmp	.+14     	; 0x9b08 <vfprintf+0x2f2>
    9afa:	f2 fc       	sbrc	r15, 2
    9afc:	05 c0       	rjmp	.+10     	; 0x9b08 <vfprintf+0x2f2>
    9afe:	8f ee       	ldi	r24, 0xEF	; 239
    9b00:	f8 22       	and	r15, r24
    9b02:	02 c0       	rjmp	.+4      	; 0x9b08 <vfprintf+0x2f2>
    9b04:	1d 2d       	mov	r17, r13
    9b06:	01 c0       	rjmp	.+2      	; 0x9b0a <vfprintf+0x2f4>
    9b08:	19 2d       	mov	r17, r9
    9b0a:	f4 fe       	sbrs	r15, 4
    9b0c:	0d c0       	rjmp	.+26     	; 0x9b28 <vfprintf+0x312>
    9b0e:	fe 01       	movw	r30, r28
    9b10:	ed 0d       	add	r30, r13
    9b12:	f1 1d       	adc	r31, r1
    9b14:	80 81       	ld	r24, Z
    9b16:	80 33       	cpi	r24, 0x30	; 48
    9b18:	19 f4       	brne	.+6      	; 0x9b20 <vfprintf+0x30a>
    9b1a:	99 ee       	ldi	r25, 0xE9	; 233
    9b1c:	f9 22       	and	r15, r25
    9b1e:	08 c0       	rjmp	.+16     	; 0x9b30 <vfprintf+0x31a>
    9b20:	1f 5f       	subi	r17, 0xFF	; 255
    9b22:	f2 fe       	sbrs	r15, 2
    9b24:	05 c0       	rjmp	.+10     	; 0x9b30 <vfprintf+0x31a>
    9b26:	03 c0       	rjmp	.+6      	; 0x9b2e <vfprintf+0x318>
    9b28:	8f 2d       	mov	r24, r15
    9b2a:	86 78       	andi	r24, 0x86	; 134
    9b2c:	09 f0       	breq	.+2      	; 0x9b30 <vfprintf+0x31a>
    9b2e:	1f 5f       	subi	r17, 0xFF	; 255
    9b30:	0f 2d       	mov	r16, r15
    9b32:	f3 fc       	sbrc	r15, 3
    9b34:	14 c0       	rjmp	.+40     	; 0x9b5e <vfprintf+0x348>
    9b36:	f0 fe       	sbrs	r15, 0
    9b38:	0f c0       	rjmp	.+30     	; 0x9b58 <vfprintf+0x342>
    9b3a:	1e 15       	cp	r17, r14
    9b3c:	10 f0       	brcs	.+4      	; 0x9b42 <vfprintf+0x32c>
    9b3e:	9d 2c       	mov	r9, r13
    9b40:	0b c0       	rjmp	.+22     	; 0x9b58 <vfprintf+0x342>
    9b42:	9d 2c       	mov	r9, r13
    9b44:	9e 0c       	add	r9, r14
    9b46:	91 1a       	sub	r9, r17
    9b48:	1e 2d       	mov	r17, r14
    9b4a:	06 c0       	rjmp	.+12     	; 0x9b58 <vfprintf+0x342>
    9b4c:	80 e2       	ldi	r24, 0x20	; 32
    9b4e:	90 e0       	ldi	r25, 0x00	; 0
    9b50:	b3 01       	movw	r22, r6
    9b52:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9b56:	1f 5f       	subi	r17, 0xFF	; 255
    9b58:	1e 15       	cp	r17, r14
    9b5a:	c0 f3       	brcs	.-16     	; 0x9b4c <vfprintf+0x336>
    9b5c:	04 c0       	rjmp	.+8      	; 0x9b66 <vfprintf+0x350>
    9b5e:	1e 15       	cp	r17, r14
    9b60:	10 f4       	brcc	.+4      	; 0x9b66 <vfprintf+0x350>
    9b62:	e1 1a       	sub	r14, r17
    9b64:	01 c0       	rjmp	.+2      	; 0x9b68 <vfprintf+0x352>
    9b66:	ee 24       	eor	r14, r14
    9b68:	04 ff       	sbrs	r16, 4
    9b6a:	0f c0       	rjmp	.+30     	; 0x9b8a <vfprintf+0x374>
    9b6c:	80 e3       	ldi	r24, 0x30	; 48
    9b6e:	90 e0       	ldi	r25, 0x00	; 0
    9b70:	b3 01       	movw	r22, r6
    9b72:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9b76:	02 ff       	sbrs	r16, 2
    9b78:	1d c0       	rjmp	.+58     	; 0x9bb4 <vfprintf+0x39e>
    9b7a:	01 fd       	sbrc	r16, 1
    9b7c:	03 c0       	rjmp	.+6      	; 0x9b84 <vfprintf+0x36e>
    9b7e:	88 e7       	ldi	r24, 0x78	; 120
    9b80:	90 e0       	ldi	r25, 0x00	; 0
    9b82:	0e c0       	rjmp	.+28     	; 0x9ba0 <vfprintf+0x38a>
    9b84:	88 e5       	ldi	r24, 0x58	; 88
    9b86:	90 e0       	ldi	r25, 0x00	; 0
    9b88:	0b c0       	rjmp	.+22     	; 0x9ba0 <vfprintf+0x38a>
    9b8a:	80 2f       	mov	r24, r16
    9b8c:	86 78       	andi	r24, 0x86	; 134
    9b8e:	91 f0       	breq	.+36     	; 0x9bb4 <vfprintf+0x39e>
    9b90:	01 ff       	sbrs	r16, 1
    9b92:	02 c0       	rjmp	.+4      	; 0x9b98 <vfprintf+0x382>
    9b94:	8b e2       	ldi	r24, 0x2B	; 43
    9b96:	01 c0       	rjmp	.+2      	; 0x9b9a <vfprintf+0x384>
    9b98:	80 e2       	ldi	r24, 0x20	; 32
    9b9a:	f7 fc       	sbrc	r15, 7
    9b9c:	8d e2       	ldi	r24, 0x2D	; 45
    9b9e:	90 e0       	ldi	r25, 0x00	; 0
    9ba0:	b3 01       	movw	r22, r6
    9ba2:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9ba6:	06 c0       	rjmp	.+12     	; 0x9bb4 <vfprintf+0x39e>
    9ba8:	80 e3       	ldi	r24, 0x30	; 48
    9baa:	90 e0       	ldi	r25, 0x00	; 0
    9bac:	b3 01       	movw	r22, r6
    9bae:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9bb2:	9a 94       	dec	r9
    9bb4:	d9 14       	cp	r13, r9
    9bb6:	c0 f3       	brcs	.-16     	; 0x9ba8 <vfprintf+0x392>
    9bb8:	da 94       	dec	r13
    9bba:	f1 01       	movw	r30, r2
    9bbc:	ed 0d       	add	r30, r13
    9bbe:	f1 1d       	adc	r31, r1
    9bc0:	80 81       	ld	r24, Z
    9bc2:	90 e0       	ldi	r25, 0x00	; 0
    9bc4:	b3 01       	movw	r22, r6
    9bc6:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9bca:	dd 20       	and	r13, r13
    9bcc:	a9 f7       	brne	.-22     	; 0x9bb8 <vfprintf+0x3a2>
    9bce:	06 c0       	rjmp	.+12     	; 0x9bdc <vfprintf+0x3c6>
    9bd0:	80 e2       	ldi	r24, 0x20	; 32
    9bd2:	90 e0       	ldi	r25, 0x00	; 0
    9bd4:	b3 01       	movw	r22, r6
    9bd6:	0e 94 42 51 	call	0xa284	; 0xa284 <fputc>
    9bda:	ea 94       	dec	r14
    9bdc:	ee 20       	and	r14, r14
    9bde:	c1 f7       	brne	.-16     	; 0x9bd0 <vfprintf+0x3ba>
    9be0:	43 ce       	rjmp	.-890    	; 0x9868 <vfprintf+0x52>
    9be2:	f3 01       	movw	r30, r6
    9be4:	66 81       	ldd	r22, Z+6	; 0x06
    9be6:	77 81       	ldd	r23, Z+7	; 0x07
    9be8:	cb 01       	movw	r24, r22
    9bea:	2b 96       	adiw	r28, 0x0b	; 11
    9bec:	cd bf       	out	0x3d, r28	; 61
    9bee:	de bf       	out	0x3e, r29	; 62
    9bf0:	cf 91       	pop	r28
    9bf2:	df 91       	pop	r29
    9bf4:	1f 91       	pop	r17
    9bf6:	0f 91       	pop	r16
    9bf8:	ff 90       	pop	r15
    9bfa:	ef 90       	pop	r14
    9bfc:	df 90       	pop	r13
    9bfe:	cf 90       	pop	r12
    9c00:	bf 90       	pop	r11
    9c02:	af 90       	pop	r10
    9c04:	9f 90       	pop	r9
    9c06:	8f 90       	pop	r8
    9c08:	7f 90       	pop	r7
    9c0a:	6f 90       	pop	r6
    9c0c:	5f 90       	pop	r5
    9c0e:	4f 90       	pop	r4
    9c10:	3f 90       	pop	r3
    9c12:	2f 90       	pop	r2
    9c14:	08 95       	ret

00009c16 <putval>:
    9c16:	fc 01       	movw	r30, r24
    9c18:	20 fd       	sbrc	r18, 0
    9c1a:	08 c0       	rjmp	.+16     	; 0x9c2c <putval+0x16>
    9c1c:	23 fd       	sbrc	r18, 3
    9c1e:	05 c0       	rjmp	.+10     	; 0x9c2a <putval+0x14>
    9c20:	22 ff       	sbrs	r18, 2
    9c22:	02 c0       	rjmp	.+4      	; 0x9c28 <putval+0x12>
    9c24:	73 83       	std	Z+3, r23	; 0x03
    9c26:	62 83       	std	Z+2, r22	; 0x02
    9c28:	51 83       	std	Z+1, r21	; 0x01
    9c2a:	40 83       	st	Z, r20
    9c2c:	08 95       	ret

00009c2e <mulacc>:
    9c2e:	ef 92       	push	r14
    9c30:	ff 92       	push	r15
    9c32:	0f 93       	push	r16
    9c34:	1f 93       	push	r17
    9c36:	44 ff       	sbrs	r20, 4
    9c38:	02 c0       	rjmp	.+4      	; 0x9c3e <mulacc+0x10>
    9c3a:	33 e0       	ldi	r19, 0x03	; 3
    9c3c:	11 c0       	rjmp	.+34     	; 0x9c60 <mulacc+0x32>
    9c3e:	46 ff       	sbrs	r20, 6
    9c40:	02 c0       	rjmp	.+4      	; 0x9c46 <mulacc+0x18>
    9c42:	34 e0       	ldi	r19, 0x04	; 4
    9c44:	0d c0       	rjmp	.+26     	; 0x9c60 <mulacc+0x32>
    9c46:	db 01       	movw	r26, r22
    9c48:	fc 01       	movw	r30, r24
    9c4a:	aa 0f       	add	r26, r26
    9c4c:	bb 1f       	adc	r27, r27
    9c4e:	ee 1f       	adc	r30, r30
    9c50:	ff 1f       	adc	r31, r31
    9c52:	10 94       	com	r1
    9c54:	d1 f7       	brne	.-12     	; 0x9c4a <mulacc+0x1c>
    9c56:	6a 0f       	add	r22, r26
    9c58:	7b 1f       	adc	r23, r27
    9c5a:	8e 1f       	adc	r24, r30
    9c5c:	9f 1f       	adc	r25, r31
    9c5e:	31 e0       	ldi	r19, 0x01	; 1
    9c60:	66 0f       	add	r22, r22
    9c62:	77 1f       	adc	r23, r23
    9c64:	88 1f       	adc	r24, r24
    9c66:	99 1f       	adc	r25, r25
    9c68:	31 50       	subi	r19, 0x01	; 1
    9c6a:	d1 f7       	brne	.-12     	; 0x9c60 <mulacc+0x32>
    9c6c:	7b 01       	movw	r14, r22
    9c6e:	8c 01       	movw	r16, r24
    9c70:	e2 0e       	add	r14, r18
    9c72:	f1 1c       	adc	r15, r1
    9c74:	01 1d       	adc	r16, r1
    9c76:	11 1d       	adc	r17, r1
    9c78:	a8 01       	movw	r20, r16
    9c7a:	97 01       	movw	r18, r14
    9c7c:	b7 01       	movw	r22, r14
    9c7e:	ca 01       	movw	r24, r20
    9c80:	1f 91       	pop	r17
    9c82:	0f 91       	pop	r16
    9c84:	ff 90       	pop	r15
    9c86:	ef 90       	pop	r14
    9c88:	08 95       	ret

00009c8a <skip_spaces>:
    9c8a:	0f 93       	push	r16
    9c8c:	1f 93       	push	r17
    9c8e:	cf 93       	push	r28
    9c90:	df 93       	push	r29
    9c92:	8c 01       	movw	r16, r24
    9c94:	c8 01       	movw	r24, r16
    9c96:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9c9a:	ec 01       	movw	r28, r24
    9c9c:	97 fd       	sbrc	r25, 7
    9c9e:	08 c0       	rjmp	.+16     	; 0x9cb0 <skip_spaces+0x26>
    9ca0:	0e 94 d7 50 	call	0xa1ae	; 0xa1ae <isspace>
    9ca4:	89 2b       	or	r24, r25
    9ca6:	b1 f7       	brne	.-20     	; 0x9c94 <skip_spaces+0xa>
    9ca8:	ce 01       	movw	r24, r28
    9caa:	b8 01       	movw	r22, r16
    9cac:	0e 94 6e 51 	call	0xa2dc	; 0xa2dc <ungetc>
    9cb0:	ce 01       	movw	r24, r28
    9cb2:	df 91       	pop	r29
    9cb4:	cf 91       	pop	r28
    9cb6:	1f 91       	pop	r17
    9cb8:	0f 91       	pop	r16
    9cba:	08 95       	ret

00009cbc <conv_int>:
    9cbc:	af 92       	push	r10
    9cbe:	bf 92       	push	r11
    9cc0:	cf 92       	push	r12
    9cc2:	df 92       	push	r13
    9cc4:	ef 92       	push	r14
    9cc6:	ff 92       	push	r15
    9cc8:	0f 93       	push	r16
    9cca:	1f 93       	push	r17
    9ccc:	cf 93       	push	r28
    9cce:	df 93       	push	r29
    9cd0:	ec 01       	movw	r28, r24
    9cd2:	c6 2e       	mov	r12, r22
    9cd4:	5a 01       	movw	r10, r20
    9cd6:	12 2f       	mov	r17, r18
    9cd8:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9cdc:	ac 01       	movw	r20, r24
    9cde:	8b 32       	cpi	r24, 0x2B	; 43
    9ce0:	19 f0       	breq	.+6      	; 0x9ce8 <conv_int+0x2c>
    9ce2:	8d 32       	cpi	r24, 0x2D	; 45
    9ce4:	51 f4       	brne	.+20     	; 0x9cfa <conv_int+0x3e>
    9ce6:	10 68       	ori	r17, 0x80	; 128
    9ce8:	ca 94       	dec	r12
    9cea:	09 f4       	brne	.+2      	; 0x9cee <conv_int+0x32>
    9cec:	6d c0       	rjmp	.+218    	; 0x9dc8 <conv_int+0x10c>
    9cee:	ce 01       	movw	r24, r28
    9cf0:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9cf4:	ac 01       	movw	r20, r24
    9cf6:	97 fd       	sbrc	r25, 7
    9cf8:	67 c0       	rjmp	.+206    	; 0x9dc8 <conv_int+0x10c>
    9cfa:	6d ef       	ldi	r22, 0xFD	; 253
    9cfc:	d6 2e       	mov	r13, r22
    9cfe:	d1 22       	and	r13, r17
    9d00:	8d 2d       	mov	r24, r13
    9d02:	80 73       	andi	r24, 0x30	; 48
    9d04:	01 f5       	brne	.+64     	; 0x9d46 <conv_int+0x8a>
    9d06:	40 33       	cpi	r20, 0x30	; 48
    9d08:	f1 f4       	brne	.+60     	; 0x9d46 <conv_int+0x8a>
    9d0a:	ca 94       	dec	r12
    9d0c:	09 f4       	brne	.+2      	; 0x9d10 <conv_int+0x54>
    9d0e:	47 c0       	rjmp	.+142    	; 0x9d9e <conv_int+0xe2>
    9d10:	ce 01       	movw	r24, r28
    9d12:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9d16:	ac 01       	movw	r20, r24
    9d18:	97 fd       	sbrc	r25, 7
    9d1a:	41 c0       	rjmp	.+130    	; 0x9d9e <conv_int+0xe2>
    9d1c:	82 e0       	ldi	r24, 0x02	; 2
    9d1e:	d8 2a       	or	r13, r24
    9d20:	48 37       	cpi	r20, 0x78	; 120
    9d22:	11 f0       	breq	.+4      	; 0x9d28 <conv_int+0x6c>
    9d24:	48 35       	cpi	r20, 0x58	; 88
    9d26:	59 f4       	brne	.+22     	; 0x9d3e <conv_int+0x82>
    9d28:	80 e4       	ldi	r24, 0x40	; 64
    9d2a:	d8 2a       	or	r13, r24
    9d2c:	ca 94       	dec	r12
    9d2e:	b9 f1       	breq	.+110    	; 0x9d9e <conv_int+0xe2>
    9d30:	ce 01       	movw	r24, r28
    9d32:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9d36:	ac 01       	movw	r20, r24
    9d38:	99 23       	and	r25, r25
    9d3a:	2c f4       	brge	.+10     	; 0x9d46 <conv_int+0x8a>
    9d3c:	30 c0       	rjmp	.+96     	; 0x9d9e <conv_int+0xe2>
    9d3e:	d6 fc       	sbrc	r13, 6
    9d40:	02 c0       	rjmp	.+4      	; 0x9d46 <conv_int+0x8a>
    9d42:	80 e1       	ldi	r24, 0x10	; 16
    9d44:	d8 2a       	or	r13, r24
    9d46:	ee 24       	eor	r14, r14
    9d48:	ff 24       	eor	r15, r15
    9d4a:	87 01       	movw	r16, r14
    9d4c:	24 2f       	mov	r18, r20
    9d4e:	20 53       	subi	r18, 0x30	; 48
    9d50:	28 30       	cpi	r18, 0x08	; 8
    9d52:	88 f0       	brcs	.+34     	; 0x9d76 <conv_int+0xba>
    9d54:	d4 fc       	sbrc	r13, 4
    9d56:	09 c0       	rjmp	.+18     	; 0x9d6a <conv_int+0xae>
    9d58:	2a 30       	cpi	r18, 0x0A	; 10
    9d5a:	68 f0       	brcs	.+26     	; 0x9d76 <conv_int+0xba>
    9d5c:	d6 fe       	sbrs	r13, 6
    9d5e:	05 c0       	rjmp	.+10     	; 0x9d6a <conv_int+0xae>
    9d60:	2f 7d       	andi	r18, 0xDF	; 223
    9d62:	82 2f       	mov	r24, r18
    9d64:	81 51       	subi	r24, 0x11	; 17
    9d66:	86 30       	cpi	r24, 0x06	; 6
    9d68:	28 f0       	brcs	.+10     	; 0x9d74 <conv_int+0xb8>
    9d6a:	ca 01       	movw	r24, r20
    9d6c:	be 01       	movw	r22, r28
    9d6e:	0e 94 6e 51 	call	0xa2dc	; 0xa2dc <ungetc>
    9d72:	12 c0       	rjmp	.+36     	; 0x9d98 <conv_int+0xdc>
    9d74:	27 50       	subi	r18, 0x07	; 7
    9d76:	c8 01       	movw	r24, r16
    9d78:	b7 01       	movw	r22, r14
    9d7a:	4d 2d       	mov	r20, r13
    9d7c:	0e 94 17 4e 	call	0x9c2e	; 0x9c2e <mulacc>
    9d80:	7b 01       	movw	r14, r22
    9d82:	8c 01       	movw	r16, r24
    9d84:	82 e0       	ldi	r24, 0x02	; 2
    9d86:	d8 2a       	or	r13, r24
    9d88:	ca 94       	dec	r12
    9d8a:	61 f0       	breq	.+24     	; 0x9da4 <conv_int+0xe8>
    9d8c:	ce 01       	movw	r24, r28
    9d8e:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9d92:	ac 01       	movw	r20, r24
    9d94:	97 ff       	sbrs	r25, 7
    9d96:	da cf       	rjmp	.-76     	; 0x9d4c <conv_int+0x90>
    9d98:	d1 fc       	sbrc	r13, 1
    9d9a:	04 c0       	rjmp	.+8      	; 0x9da4 <conv_int+0xe8>
    9d9c:	15 c0       	rjmp	.+42     	; 0x9dc8 <conv_int+0x10c>
    9d9e:	ee 24       	eor	r14, r14
    9da0:	ff 24       	eor	r15, r15
    9da2:	87 01       	movw	r16, r14
    9da4:	d7 fe       	sbrs	r13, 7
    9da6:	08 c0       	rjmp	.+16     	; 0x9db8 <conv_int+0xfc>
    9da8:	10 95       	com	r17
    9daa:	00 95       	com	r16
    9dac:	f0 94       	com	r15
    9dae:	e0 94       	com	r14
    9db0:	e1 1c       	adc	r14, r1
    9db2:	f1 1c       	adc	r15, r1
    9db4:	01 1d       	adc	r16, r1
    9db6:	11 1d       	adc	r17, r1
    9db8:	c5 01       	movw	r24, r10
    9dba:	b8 01       	movw	r22, r16
    9dbc:	a7 01       	movw	r20, r14
    9dbe:	2d 2d       	mov	r18, r13
    9dc0:	0e 94 0b 4e 	call	0x9c16	; 0x9c16 <putval>
    9dc4:	81 e0       	ldi	r24, 0x01	; 1
    9dc6:	01 c0       	rjmp	.+2      	; 0x9dca <conv_int+0x10e>
    9dc8:	80 e0       	ldi	r24, 0x00	; 0
    9dca:	df 91       	pop	r29
    9dcc:	cf 91       	pop	r28
    9dce:	1f 91       	pop	r17
    9dd0:	0f 91       	pop	r16
    9dd2:	ff 90       	pop	r15
    9dd4:	ef 90       	pop	r14
    9dd6:	df 90       	pop	r13
    9dd8:	cf 90       	pop	r12
    9dda:	bf 90       	pop	r11
    9ddc:	af 90       	pop	r10
    9dde:	08 95       	ret

00009de0 <conv_brk>:
    9de0:	6f 92       	push	r6
    9de2:	7f 92       	push	r7
    9de4:	8f 92       	push	r8
    9de6:	9f 92       	push	r9
    9de8:	af 92       	push	r10
    9dea:	bf 92       	push	r11
    9dec:	cf 92       	push	r12
    9dee:	df 92       	push	r13
    9df0:	ef 92       	push	r14
    9df2:	ff 92       	push	r15
    9df4:	0f 93       	push	r16
    9df6:	1f 93       	push	r17
    9df8:	df 93       	push	r29
    9dfa:	cf 93       	push	r28
    9dfc:	cd b7       	in	r28, 0x3d	; 61
    9dfe:	de b7       	in	r29, 0x3e	; 62
    9e00:	a0 97       	sbiw	r28, 0x20	; 32
    9e02:	cd bf       	out	0x3d, r28	; 61
    9e04:	de bf       	out	0x3e, r29	; 62
    9e06:	6c 01       	movw	r12, r24
    9e08:	a6 2e       	mov	r10, r22
    9e0a:	8a 01       	movw	r16, r20
    9e0c:	79 01       	movw	r14, r18
    9e0e:	fe 01       	movw	r30, r28
    9e10:	31 96       	adiw	r30, 0x01	; 1
    9e12:	80 e2       	ldi	r24, 0x20	; 32
    9e14:	df 01       	movw	r26, r30
    9e16:	1d 92       	st	X+, r1
    9e18:	8a 95       	dec	r24
    9e1a:	e9 f7       	brne	.-6      	; 0x9e16 <conv_brk+0x36>
    9e1c:	70 e0       	ldi	r23, 0x00	; 0
    9e1e:	30 e0       	ldi	r19, 0x00	; 0
    9e20:	60 e0       	ldi	r22, 0x00	; 0
    9e22:	40 e0       	ldi	r20, 0x00	; 0
    9e24:	50 e0       	ldi	r21, 0x00	; 0
    9e26:	4f 01       	movw	r8, r30
    9e28:	a1 e0       	ldi	r26, 0x01	; 1
    9e2a:	b0 e0       	ldi	r27, 0x00	; 0
    9e2c:	f6 01       	movw	r30, r12
    9e2e:	83 81       	ldd	r24, Z+3	; 0x03
    9e30:	f7 01       	movw	r30, r14
    9e32:	83 fd       	sbrc	r24, 3
    9e34:	25 91       	lpm	r18, Z+
    9e36:	83 ff       	sbrs	r24, 3
    9e38:	21 91       	ld	r18, Z+
    9e3a:	7f 01       	movw	r14, r30
    9e3c:	22 23       	and	r18, r18
    9e3e:	09 f4       	brne	.+2      	; 0x9e42 <conv_brk+0x62>
    9e40:	7e c0       	rjmp	.+252    	; 0x9f3e <conv_brk+0x15e>
    9e42:	2e 35       	cpi	r18, 0x5E	; 94
    9e44:	19 f4       	brne	.+6      	; 0x9e4c <conv_brk+0x6c>
    9e46:	41 15       	cp	r20, r1
    9e48:	51 05       	cpc	r21, r1
    9e4a:	69 f1       	breq	.+90     	; 0x9ea6 <conv_brk+0xc6>
    9e4c:	87 2f       	mov	r24, r23
    9e4e:	90 e0       	ldi	r25, 0x00	; 0
    9e50:	84 17       	cp	r24, r20
    9e52:	95 07       	cpc	r25, r21
    9e54:	44 f4       	brge	.+16     	; 0x9e66 <conv_brk+0x86>
    9e56:	2d 35       	cpi	r18, 0x5D	; 93
    9e58:	51 f1       	breq	.+84     	; 0x9eae <conv_brk+0xce>
    9e5a:	2d 32       	cpi	r18, 0x2D	; 45
    9e5c:	21 f4       	brne	.+8      	; 0x9e66 <conv_brk+0x86>
    9e5e:	33 23       	and	r19, r19
    9e60:	29 f4       	brne	.+10     	; 0x9e6c <conv_brk+0x8c>
    9e62:	31 e0       	ldi	r19, 0x01	; 1
    9e64:	21 c0       	rjmp	.+66     	; 0x9ea8 <conv_brk+0xc8>
    9e66:	33 23       	and	r19, r19
    9e68:	09 f4       	brne	.+2      	; 0x9e6c <conv_brk+0x8c>
    9e6a:	62 2f       	mov	r22, r18
    9e6c:	32 2f       	mov	r19, r18
    9e6e:	83 2f       	mov	r24, r19
    9e70:	86 95       	lsr	r24
    9e72:	86 95       	lsr	r24
    9e74:	86 95       	lsr	r24
    9e76:	f4 01       	movw	r30, r8
    9e78:	e8 0f       	add	r30, r24
    9e7a:	f1 1d       	adc	r31, r1
    9e7c:	83 2f       	mov	r24, r19
    9e7e:	87 70       	andi	r24, 0x07	; 7
    9e80:	3d 01       	movw	r6, r26
    9e82:	02 c0       	rjmp	.+4      	; 0x9e88 <conv_brk+0xa8>
    9e84:	66 0c       	add	r6, r6
    9e86:	77 1c       	adc	r7, r7
    9e88:	8a 95       	dec	r24
    9e8a:	e2 f7       	brpl	.-8      	; 0x9e84 <conv_brk+0xa4>
    9e8c:	20 81       	ld	r18, Z
    9e8e:	26 29       	or	r18, r6
    9e90:	20 83       	st	Z, r18
    9e92:	36 17       	cp	r19, r22
    9e94:	11 f4       	brne	.+4      	; 0x9e9a <conv_brk+0xba>
    9e96:	30 e0       	ldi	r19, 0x00	; 0
    9e98:	07 c0       	rjmp	.+14     	; 0x9ea8 <conv_brk+0xc8>
    9e9a:	36 17       	cp	r19, r22
    9e9c:	10 f4       	brcc	.+4      	; 0x9ea2 <conv_brk+0xc2>
    9e9e:	3f 5f       	subi	r19, 0xFF	; 255
    9ea0:	e6 cf       	rjmp	.-52     	; 0x9e6e <conv_brk+0x8e>
    9ea2:	31 50       	subi	r19, 0x01	; 1
    9ea4:	e4 cf       	rjmp	.-56     	; 0x9e6e <conv_brk+0x8e>
    9ea6:	71 e0       	ldi	r23, 0x01	; 1
    9ea8:	4f 5f       	subi	r20, 0xFF	; 255
    9eaa:	5f 4f       	sbci	r21, 0xFF	; 255
    9eac:	bf cf       	rjmp	.-130    	; 0x9e2c <conv_brk+0x4c>
    9eae:	33 23       	and	r19, r19
    9eb0:	19 f0       	breq	.+6      	; 0x9eb8 <conv_brk+0xd8>
    9eb2:	8e 81       	ldd	r24, Y+6	; 0x06
    9eb4:	80 62       	ori	r24, 0x20	; 32
    9eb6:	8e 83       	std	Y+6, r24	; 0x06
    9eb8:	77 23       	and	r23, r23
    9eba:	59 f0       	breq	.+22     	; 0x9ed2 <conv_brk+0xf2>
    9ebc:	fe 01       	movw	r30, r28
    9ebe:	31 96       	adiw	r30, 0x01	; 1
    9ec0:	9e 01       	movw	r18, r28
    9ec2:	2f 5d       	subi	r18, 0xDF	; 223
    9ec4:	3f 4f       	sbci	r19, 0xFF	; 255
    9ec6:	80 81       	ld	r24, Z
    9ec8:	80 95       	com	r24
    9eca:	81 93       	st	Z+, r24
    9ecc:	e2 17       	cp	r30, r18
    9ece:	f3 07       	cpc	r31, r19
    9ed0:	d1 f7       	brne	.-12     	; 0x9ec6 <conv_brk+0xe6>
    9ed2:	bb 24       	eor	r11, r11
    9ed4:	b3 94       	inc	r11
    9ed6:	4e 01       	movw	r8, r28
    9ed8:	08 94       	sec
    9eda:	81 1c       	adc	r8, r1
    9edc:	91 1c       	adc	r9, r1
    9ede:	c6 01       	movw	r24, r12
    9ee0:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9ee4:	ac 01       	movw	r20, r24
    9ee6:	97 fd       	sbrc	r25, 7
    9ee8:	22 c0       	rjmp	.+68     	; 0x9f2e <conv_brk+0x14e>
    9eea:	86 95       	lsr	r24
    9eec:	86 95       	lsr	r24
    9eee:	86 95       	lsr	r24
    9ef0:	f4 01       	movw	r30, r8
    9ef2:	e8 0f       	add	r30, r24
    9ef4:	f1 1d       	adc	r31, r1
    9ef6:	80 81       	ld	r24, Z
    9ef8:	90 e0       	ldi	r25, 0x00	; 0
    9efa:	9a 01       	movw	r18, r20
    9efc:	27 70       	andi	r18, 0x07	; 7
    9efe:	30 70       	andi	r19, 0x00	; 0
    9f00:	02 c0       	rjmp	.+4      	; 0x9f06 <conv_brk+0x126>
    9f02:	95 95       	asr	r25
    9f04:	87 95       	ror	r24
    9f06:	2a 95       	dec	r18
    9f08:	e2 f7       	brpl	.-8      	; 0x9f02 <conv_brk+0x122>
    9f0a:	80 fd       	sbrc	r24, 0
    9f0c:	05 c0       	rjmp	.+10     	; 0x9f18 <conv_brk+0x138>
    9f0e:	ca 01       	movw	r24, r20
    9f10:	b6 01       	movw	r22, r12
    9f12:	0e 94 6e 51 	call	0xa2dc	; 0xa2dc <ungetc>
    9f16:	0b c0       	rjmp	.+22     	; 0x9f2e <conv_brk+0x14e>
    9f18:	01 15       	cp	r16, r1
    9f1a:	11 05       	cpc	r17, r1
    9f1c:	19 f0       	breq	.+6      	; 0x9f24 <conv_brk+0x144>
    9f1e:	d8 01       	movw	r26, r16
    9f20:	4d 93       	st	X+, r20
    9f22:	8d 01       	movw	r16, r26
    9f24:	aa 94       	dec	r10
    9f26:	bb 24       	eor	r11, r11
    9f28:	aa 20       	and	r10, r10
    9f2a:	c9 f6       	brne	.-78     	; 0x9ede <conv_brk+0xfe>
    9f2c:	02 c0       	rjmp	.+4      	; 0x9f32 <conv_brk+0x152>
    9f2e:	bb 20       	and	r11, r11
    9f30:	31 f4       	brne	.+12     	; 0x9f3e <conv_brk+0x15e>
    9f32:	01 15       	cp	r16, r1
    9f34:	11 05       	cpc	r17, r1
    9f36:	29 f0       	breq	.+10     	; 0x9f42 <conv_brk+0x162>
    9f38:	f8 01       	movw	r30, r16
    9f3a:	10 82       	st	Z, r1
    9f3c:	02 c0       	rjmp	.+4      	; 0x9f42 <conv_brk+0x162>
    9f3e:	ee 24       	eor	r14, r14
    9f40:	ff 24       	eor	r15, r15
    9f42:	c7 01       	movw	r24, r14
    9f44:	a0 96       	adiw	r28, 0x20	; 32
    9f46:	cd bf       	out	0x3d, r28	; 61
    9f48:	de bf       	out	0x3e, r29	; 62
    9f4a:	cf 91       	pop	r28
    9f4c:	df 91       	pop	r29
    9f4e:	1f 91       	pop	r17
    9f50:	0f 91       	pop	r16
    9f52:	ff 90       	pop	r15
    9f54:	ef 90       	pop	r14
    9f56:	df 90       	pop	r13
    9f58:	cf 90       	pop	r12
    9f5a:	bf 90       	pop	r11
    9f5c:	af 90       	pop	r10
    9f5e:	9f 90       	pop	r9
    9f60:	8f 90       	pop	r8
    9f62:	7f 90       	pop	r7
    9f64:	6f 90       	pop	r6
    9f66:	08 95       	ret

00009f68 <vfscanf>:
    9f68:	6f 92       	push	r6
    9f6a:	7f 92       	push	r7
    9f6c:	8f 92       	push	r8
    9f6e:	9f 92       	push	r9
    9f70:	af 92       	push	r10
    9f72:	bf 92       	push	r11
    9f74:	cf 92       	push	r12
    9f76:	df 92       	push	r13
    9f78:	ef 92       	push	r14
    9f7a:	ff 92       	push	r15
    9f7c:	0f 93       	push	r16
    9f7e:	1f 93       	push	r17
    9f80:	cf 93       	push	r28
    9f82:	df 93       	push	r29
    9f84:	5c 01       	movw	r10, r24
    9f86:	6b 01       	movw	r12, r22
    9f88:	3a 01       	movw	r6, r20
    9f8a:	fc 01       	movw	r30, r24
    9f8c:	16 82       	std	Z+6, r1	; 0x06
    9f8e:	17 82       	std	Z+7, r1	; 0x07
    9f90:	88 24       	eor	r8, r8
    9f92:	ea c0       	rjmp	.+468    	; 0xa168 <vfscanf+0x200>
    9f94:	81 2f       	mov	r24, r17
    9f96:	90 e0       	ldi	r25, 0x00	; 0
    9f98:	0e 94 d7 50 	call	0xa1ae	; 0xa1ae <isspace>
    9f9c:	89 2b       	or	r24, r25
    9f9e:	21 f0       	breq	.+8      	; 0x9fa8 <vfscanf+0x40>
    9fa0:	c5 01       	movw	r24, r10
    9fa2:	0e 94 45 4e 	call	0x9c8a	; 0x9c8a <skip_spaces>
    9fa6:	e0 c0       	rjmp	.+448    	; 0xa168 <vfscanf+0x200>
    9fa8:	15 32       	cpi	r17, 0x25	; 37
    9faa:	49 f4       	brne	.+18     	; 0x9fbe <vfscanf+0x56>
    9fac:	f6 01       	movw	r30, r12
    9fae:	f3 fc       	sbrc	r15, 3
    9fb0:	65 91       	lpm	r22, Z+
    9fb2:	f3 fe       	sbrs	r15, 3
    9fb4:	61 91       	ld	r22, Z+
    9fb6:	6f 01       	movw	r12, r30
    9fb8:	65 32       	cpi	r22, 0x25	; 37
    9fba:	69 f4       	brne	.+26     	; 0x9fd6 <vfscanf+0x6e>
    9fbc:	15 e2       	ldi	r17, 0x25	; 37
    9fbe:	c5 01       	movw	r24, r10
    9fc0:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    9fc4:	97 fd       	sbrc	r25, 7
    9fc6:	dc c0       	rjmp	.+440    	; 0xa180 <vfscanf+0x218>
    9fc8:	18 17       	cp	r17, r24
    9fca:	09 f4       	brne	.+2      	; 0x9fce <vfscanf+0x66>
    9fcc:	cd c0       	rjmp	.+410    	; 0xa168 <vfscanf+0x200>
    9fce:	b5 01       	movw	r22, r10
    9fd0:	0e 94 6e 51 	call	0xa2dc	; 0xa2dc <ungetc>
    9fd4:	da c0       	rjmp	.+436    	; 0xa18a <vfscanf+0x222>
    9fd6:	6a 32       	cpi	r22, 0x2A	; 42
    9fd8:	19 f0       	breq	.+6      	; 0x9fe0 <vfscanf+0x78>
    9fda:	16 2f       	mov	r17, r22
    9fdc:	00 e0       	ldi	r16, 0x00	; 0
    9fde:	06 c0       	rjmp	.+12     	; 0x9fec <vfscanf+0x84>
    9fe0:	f3 fc       	sbrc	r15, 3
    9fe2:	15 91       	lpm	r17, Z+
    9fe4:	f3 fe       	sbrs	r15, 3
    9fe6:	11 91       	ld	r17, Z+
    9fe8:	6f 01       	movw	r12, r30
    9fea:	01 e0       	ldi	r16, 0x01	; 1
    9fec:	99 24       	eor	r9, r9
    9fee:	0f c0       	rjmp	.+30     	; 0xa00e <vfscanf+0xa6>
    9ff0:	02 60       	ori	r16, 0x02	; 2
    9ff2:	69 2d       	mov	r22, r9
    9ff4:	70 e0       	ldi	r23, 0x00	; 0
    9ff6:	80 e0       	ldi	r24, 0x00	; 0
    9ff8:	90 e0       	ldi	r25, 0x00	; 0
    9ffa:	40 e2       	ldi	r20, 0x20	; 32
    9ffc:	0e 94 17 4e 	call	0x9c2e	; 0x9c2e <mulacc>
    a000:	96 2e       	mov	r9, r22
    a002:	f6 01       	movw	r30, r12
    a004:	f3 fc       	sbrc	r15, 3
    a006:	15 91       	lpm	r17, Z+
    a008:	f3 fe       	sbrs	r15, 3
    a00a:	11 91       	ld	r17, Z+
    a00c:	6f 01       	movw	r12, r30
    a00e:	21 2f       	mov	r18, r17
    a010:	20 53       	subi	r18, 0x30	; 48
    a012:	2a 30       	cpi	r18, 0x0A	; 10
    a014:	68 f3       	brcs	.-38     	; 0x9ff0 <vfscanf+0x88>
    a016:	01 fd       	sbrc	r16, 1
    a018:	03 c0       	rjmp	.+6      	; 0xa020 <vfscanf+0xb8>
    a01a:	99 24       	eor	r9, r9
    a01c:	9a 94       	dec	r9
    a01e:	03 c0       	rjmp	.+6      	; 0xa026 <vfscanf+0xbe>
    a020:	99 20       	and	r9, r9
    a022:	09 f4       	brne	.+2      	; 0xa026 <vfscanf+0xbe>
    a024:	b2 c0       	rjmp	.+356    	; 0xa18a <vfscanf+0x222>
    a026:	18 36       	cpi	r17, 0x68	; 104
    a028:	21 f0       	breq	.+8      	; 0xa032 <vfscanf+0xca>
    a02a:	1c 36       	cpi	r17, 0x6C	; 108
    a02c:	99 f4       	brne	.+38     	; 0xa054 <vfscanf+0xec>
    a02e:	f6 01       	movw	r30, r12
    a030:	0b c0       	rjmp	.+22     	; 0xa048 <vfscanf+0xe0>
    a032:	f6 01       	movw	r30, r12
    a034:	f3 fc       	sbrc	r15, 3
    a036:	65 91       	lpm	r22, Z+
    a038:	f3 fe       	sbrs	r15, 3
    a03a:	61 91       	ld	r22, Z+
    a03c:	68 36       	cpi	r22, 0x68	; 104
    a03e:	19 f0       	breq	.+6      	; 0xa046 <vfscanf+0xde>
    a040:	6f 01       	movw	r12, r30
    a042:	16 2f       	mov	r17, r22
    a044:	07 c0       	rjmp	.+14     	; 0xa054 <vfscanf+0xec>
    a046:	08 60       	ori	r16, 0x08	; 8
    a048:	04 60       	ori	r16, 0x04	; 4
    a04a:	f3 fc       	sbrc	r15, 3
    a04c:	15 91       	lpm	r17, Z+
    a04e:	f3 fe       	sbrs	r15, 3
    a050:	11 91       	ld	r17, Z+
    a052:	6f 01       	movw	r12, r30
    a054:	11 23       	and	r17, r17
    a056:	09 f4       	brne	.+2      	; 0xa05a <vfscanf+0xf2>
    a058:	98 c0       	rjmp	.+304    	; 0xa18a <vfscanf+0x222>
    a05a:	84 ef       	ldi	r24, 0xF4	; 244
    a05c:	91 e0       	ldi	r25, 0x01	; 1
    a05e:	61 2f       	mov	r22, r17
    a060:	70 e0       	ldi	r23, 0x00	; 0
    a062:	0e 94 df 50 	call	0xa1be	; 0xa1be <strchr_P>
    a066:	89 2b       	or	r24, r25
    a068:	09 f4       	brne	.+2      	; 0xa06c <vfscanf+0x104>
    a06a:	8f c0       	rjmp	.+286    	; 0xa18a <vfscanf+0x222>
    a06c:	80 2f       	mov	r24, r16
    a06e:	00 ff       	sbrs	r16, 0
    a070:	03 c0       	rjmp	.+6      	; 0xa078 <vfscanf+0x110>
    a072:	ee 24       	eor	r14, r14
    a074:	ff 24       	eor	r15, r15
    a076:	07 c0       	rjmp	.+14     	; 0xa086 <vfscanf+0x11e>
    a078:	f3 01       	movw	r30, r6
    a07a:	e0 80       	ld	r14, Z
    a07c:	f1 80       	ldd	r15, Z+1	; 0x01
    a07e:	22 e0       	ldi	r18, 0x02	; 2
    a080:	30 e0       	ldi	r19, 0x00	; 0
    a082:	62 0e       	add	r6, r18
    a084:	73 1e       	adc	r7, r19
    a086:	1e 36       	cpi	r17, 0x6E	; 110
    a088:	51 f4       	brne	.+20     	; 0xa09e <vfscanf+0x136>
    a08a:	f5 01       	movw	r30, r10
    a08c:	46 81       	ldd	r20, Z+6	; 0x06
    a08e:	57 81       	ldd	r21, Z+7	; 0x07
    a090:	60 e0       	ldi	r22, 0x00	; 0
    a092:	70 e0       	ldi	r23, 0x00	; 0
    a094:	c7 01       	movw	r24, r14
    a096:	20 2f       	mov	r18, r16
    a098:	0e 94 0b 4e 	call	0x9c16	; 0x9c16 <putval>
    a09c:	65 c0       	rjmp	.+202    	; 0xa168 <vfscanf+0x200>
    a09e:	13 36       	cpi	r17, 0x63	; 99
    a0a0:	91 f4       	brne	.+36     	; 0xa0c6 <vfscanf+0x15e>
    a0a2:	81 fd       	sbrc	r24, 1
    a0a4:	02 c0       	rjmp	.+4      	; 0xa0aa <vfscanf+0x142>
    a0a6:	99 24       	eor	r9, r9
    a0a8:	93 94       	inc	r9
    a0aa:	c5 01       	movw	r24, r10
    a0ac:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    a0b0:	97 fd       	sbrc	r25, 7
    a0b2:	66 c0       	rjmp	.+204    	; 0xa180 <vfscanf+0x218>
    a0b4:	e1 14       	cp	r14, r1
    a0b6:	f1 04       	cpc	r15, r1
    a0b8:	19 f0       	breq	.+6      	; 0xa0c0 <vfscanf+0x158>
    a0ba:	f7 01       	movw	r30, r14
    a0bc:	81 93       	st	Z+, r24
    a0be:	7f 01       	movw	r14, r30
    a0c0:	9a 94       	dec	r9
    a0c2:	99 f7       	brne	.-26     	; 0xa0aa <vfscanf+0x142>
    a0c4:	4f c0       	rjmp	.+158    	; 0xa164 <vfscanf+0x1fc>
    a0c6:	1b 35       	cpi	r17, 0x5B	; 91
    a0c8:	59 f4       	brne	.+22     	; 0xa0e0 <vfscanf+0x178>
    a0ca:	c5 01       	movw	r24, r10
    a0cc:	69 2d       	mov	r22, r9
    a0ce:	a7 01       	movw	r20, r14
    a0d0:	96 01       	movw	r18, r12
    a0d2:	0e 94 f0 4e 	call	0x9de0	; 0x9de0 <conv_brk>
    a0d6:	6c 01       	movw	r12, r24
    a0d8:	00 97       	sbiw	r24, 0x00	; 0
    a0da:	09 f0       	breq	.+2      	; 0xa0de <vfscanf+0x176>
    a0dc:	43 c0       	rjmp	.+134    	; 0xa164 <vfscanf+0x1fc>
    a0de:	3d c0       	rjmp	.+122    	; 0xa15a <vfscanf+0x1f2>
    a0e0:	c5 01       	movw	r24, r10
    a0e2:	0e 94 45 4e 	call	0x9c8a	; 0x9c8a <skip_spaces>
    a0e6:	97 fd       	sbrc	r25, 7
    a0e8:	4b c0       	rjmp	.+150    	; 0xa180 <vfscanf+0x218>
    a0ea:	1f 36       	cpi	r17, 0x6F	; 111
    a0ec:	59 f1       	breq	.+86     	; 0xa144 <vfscanf+0x1dc>
    a0ee:	10 37       	cpi	r17, 0x70	; 112
    a0f0:	28 f4       	brcc	.+10     	; 0xa0fc <vfscanf+0x194>
    a0f2:	14 36       	cpi	r17, 0x64	; 100
    a0f4:	29 f1       	breq	.+74     	; 0xa140 <vfscanf+0x1d8>
    a0f6:	19 36       	cpi	r17, 0x69	; 105
    a0f8:	39 f5       	brne	.+78     	; 0xa148 <vfscanf+0x1e0>
    a0fa:	27 c0       	rjmp	.+78     	; 0xa14a <vfscanf+0x1e2>
    a0fc:	13 37       	cpi	r17, 0x73	; 115
    a0fe:	19 f0       	breq	.+6      	; 0xa106 <vfscanf+0x19e>
    a100:	15 37       	cpi	r17, 0x75	; 117
    a102:	11 f5       	brne	.+68     	; 0xa148 <vfscanf+0x1e0>
    a104:	1d c0       	rjmp	.+58     	; 0xa140 <vfscanf+0x1d8>
    a106:	c5 01       	movw	r24, r10
    a108:	0e 94 00 51 	call	0xa200	; 0xa200 <fgetc>
    a10c:	ec 01       	movw	r28, r24
    a10e:	97 fd       	sbrc	r25, 7
    a110:	11 c0       	rjmp	.+34     	; 0xa134 <vfscanf+0x1cc>
    a112:	0e 94 d7 50 	call	0xa1ae	; 0xa1ae <isspace>
    a116:	89 2b       	or	r24, r25
    a118:	29 f0       	breq	.+10     	; 0xa124 <vfscanf+0x1bc>
    a11a:	ce 01       	movw	r24, r28
    a11c:	b5 01       	movw	r22, r10
    a11e:	0e 94 6e 51 	call	0xa2dc	; 0xa2dc <ungetc>
    a122:	08 c0       	rjmp	.+16     	; 0xa134 <vfscanf+0x1cc>
    a124:	e1 14       	cp	r14, r1
    a126:	f1 04       	cpc	r15, r1
    a128:	19 f0       	breq	.+6      	; 0xa130 <vfscanf+0x1c8>
    a12a:	f7 01       	movw	r30, r14
    a12c:	c1 93       	st	Z+, r28
    a12e:	7f 01       	movw	r14, r30
    a130:	9a 94       	dec	r9
    a132:	49 f7       	brne	.-46     	; 0xa106 <vfscanf+0x19e>
    a134:	e1 14       	cp	r14, r1
    a136:	f1 04       	cpc	r15, r1
    a138:	a9 f0       	breq	.+42     	; 0xa164 <vfscanf+0x1fc>
    a13a:	f7 01       	movw	r30, r14
    a13c:	10 82       	st	Z, r1
    a13e:	12 c0       	rjmp	.+36     	; 0xa164 <vfscanf+0x1fc>
    a140:	00 62       	ori	r16, 0x20	; 32
    a142:	03 c0       	rjmp	.+6      	; 0xa14a <vfscanf+0x1e2>
    a144:	00 61       	ori	r16, 0x10	; 16
    a146:	01 c0       	rjmp	.+2      	; 0xa14a <vfscanf+0x1e2>
    a148:	00 64       	ori	r16, 0x40	; 64
    a14a:	c5 01       	movw	r24, r10
    a14c:	69 2d       	mov	r22, r9
    a14e:	a7 01       	movw	r20, r14
    a150:	20 2f       	mov	r18, r16
    a152:	0e 94 5e 4e 	call	0x9cbc	; 0x9cbc <conv_int>
    a156:	88 23       	and	r24, r24
    a158:	29 f4       	brne	.+10     	; 0xa164 <vfscanf+0x1fc>
    a15a:	f5 01       	movw	r30, r10
    a15c:	83 81       	ldd	r24, Z+3	; 0x03
    a15e:	80 73       	andi	r24, 0x30	; 48
    a160:	79 f4       	brne	.+30     	; 0xa180 <vfscanf+0x218>
    a162:	13 c0       	rjmp	.+38     	; 0xa18a <vfscanf+0x222>
    a164:	00 ff       	sbrs	r16, 0
    a166:	83 94       	inc	r8
    a168:	f5 01       	movw	r30, r10
    a16a:	f3 80       	ldd	r15, Z+3	; 0x03
    a16c:	f6 01       	movw	r30, r12
    a16e:	f3 fc       	sbrc	r15, 3
    a170:	15 91       	lpm	r17, Z+
    a172:	f3 fe       	sbrs	r15, 3
    a174:	11 91       	ld	r17, Z+
    a176:	6f 01       	movw	r12, r30
    a178:	11 23       	and	r17, r17
    a17a:	09 f0       	breq	.+2      	; 0xa17e <vfscanf+0x216>
    a17c:	0b cf       	rjmp	.-490    	; 0x9f94 <vfscanf+0x2c>
    a17e:	05 c0       	rjmp	.+10     	; 0xa18a <vfscanf+0x222>
    a180:	88 20       	and	r8, r8
    a182:	19 f4       	brne	.+6      	; 0xa18a <vfscanf+0x222>
    a184:	2f ef       	ldi	r18, 0xFF	; 255
    a186:	3f ef       	ldi	r19, 0xFF	; 255
    a188:	02 c0       	rjmp	.+4      	; 0xa18e <vfscanf+0x226>
    a18a:	28 2d       	mov	r18, r8
    a18c:	30 e0       	ldi	r19, 0x00	; 0
    a18e:	c9 01       	movw	r24, r18
    a190:	df 91       	pop	r29
    a192:	cf 91       	pop	r28
    a194:	1f 91       	pop	r17
    a196:	0f 91       	pop	r16
    a198:	ff 90       	pop	r15
    a19a:	ef 90       	pop	r14
    a19c:	df 90       	pop	r13
    a19e:	cf 90       	pop	r12
    a1a0:	bf 90       	pop	r11
    a1a2:	af 90       	pop	r10
    a1a4:	9f 90       	pop	r9
    a1a6:	8f 90       	pop	r8
    a1a8:	7f 90       	pop	r7
    a1aa:	6f 90       	pop	r6
    a1ac:	08 95       	ret

0000a1ae <isspace>:
    a1ae:	91 11       	cpse	r25, r1
    a1b0:	0d c1       	rjmp	.+538    	; 0xa3cc <__ctype_isfalse>
    a1b2:	80 32       	cpi	r24, 0x20	; 32
    a1b4:	19 f0       	breq	.+6      	; 0xa1bc <isspace+0xe>
    a1b6:	89 50       	subi	r24, 0x09	; 9
    a1b8:	85 50       	subi	r24, 0x05	; 5
    a1ba:	d0 f7       	brcc	.-12     	; 0xa1b0 <isspace+0x2>
    a1bc:	08 95       	ret

0000a1be <strchr_P>:
    a1be:	fc 01       	movw	r30, r24
    a1c0:	05 90       	lpm	r0, Z+
    a1c2:	06 16       	cp	r0, r22
    a1c4:	21 f0       	breq	.+8      	; 0xa1ce <strchr_P+0x10>
    a1c6:	00 20       	and	r0, r0
    a1c8:	d9 f7       	brne	.-10     	; 0xa1c0 <strchr_P+0x2>
    a1ca:	c0 01       	movw	r24, r0
    a1cc:	08 95       	ret
    a1ce:	31 97       	sbiw	r30, 0x01	; 1
    a1d0:	cf 01       	movw	r24, r30
    a1d2:	08 95       	ret

0000a1d4 <strnlen_P>:
    a1d4:	fc 01       	movw	r30, r24
    a1d6:	05 90       	lpm	r0, Z+
    a1d8:	61 50       	subi	r22, 0x01	; 1
    a1da:	70 40       	sbci	r23, 0x00	; 0
    a1dc:	01 10       	cpse	r0, r1
    a1de:	d8 f7       	brcc	.-10     	; 0xa1d6 <strnlen_P+0x2>
    a1e0:	80 95       	com	r24
    a1e2:	90 95       	com	r25
    a1e4:	8e 0f       	add	r24, r30
    a1e6:	9f 1f       	adc	r25, r31
    a1e8:	08 95       	ret

0000a1ea <strnlen>:
    a1ea:	fc 01       	movw	r30, r24
    a1ec:	61 50       	subi	r22, 0x01	; 1
    a1ee:	70 40       	sbci	r23, 0x00	; 0
    a1f0:	01 90       	ld	r0, Z+
    a1f2:	01 10       	cpse	r0, r1
    a1f4:	d8 f7       	brcc	.-10     	; 0xa1ec <strnlen+0x2>
    a1f6:	80 95       	com	r24
    a1f8:	90 95       	com	r25
    a1fa:	8e 0f       	add	r24, r30
    a1fc:	9f 1f       	adc	r25, r31
    a1fe:	08 95       	ret

0000a200 <fgetc>:
    a200:	cf 93       	push	r28
    a202:	df 93       	push	r29
    a204:	ec 01       	movw	r28, r24
    a206:	4b 81       	ldd	r20, Y+3	; 0x03
    a208:	40 ff       	sbrs	r20, 0
    a20a:	1a c0       	rjmp	.+52     	; 0xa240 <fgetc+0x40>
    a20c:	46 ff       	sbrs	r20, 6
    a20e:	0a c0       	rjmp	.+20     	; 0xa224 <fgetc+0x24>
    a210:	4f 7b       	andi	r20, 0xBF	; 191
    a212:	4b 83       	std	Y+3, r20	; 0x03
    a214:	8e 81       	ldd	r24, Y+6	; 0x06
    a216:	9f 81       	ldd	r25, Y+7	; 0x07
    a218:	01 96       	adiw	r24, 0x01	; 1
    a21a:	8e 83       	std	Y+6, r24	; 0x06
    a21c:	9f 83       	std	Y+7, r25	; 0x07
    a21e:	8a 81       	ldd	r24, Y+2	; 0x02
    a220:	28 2f       	mov	r18, r24
    a222:	2b c0       	rjmp	.+86     	; 0xa27a <fgetc+0x7a>
    a224:	42 ff       	sbrs	r20, 2
    a226:	13 c0       	rjmp	.+38     	; 0xa24e <fgetc+0x4e>
    a228:	e8 81       	ld	r30, Y
    a22a:	f9 81       	ldd	r31, Y+1	; 0x01
    a22c:	80 81       	ld	r24, Z
    a22e:	28 2f       	mov	r18, r24
    a230:	33 27       	eor	r19, r19
    a232:	27 fd       	sbrc	r18, 7
    a234:	30 95       	com	r19
    a236:	21 15       	cp	r18, r1
    a238:	31 05       	cpc	r19, r1
    a23a:	29 f4       	brne	.+10     	; 0xa246 <fgetc+0x46>
    a23c:	40 62       	ori	r20, 0x20	; 32
    a23e:	4b 83       	std	Y+3, r20	; 0x03
    a240:	2f ef       	ldi	r18, 0xFF	; 255
    a242:	3f ef       	ldi	r19, 0xFF	; 255
    a244:	1b c0       	rjmp	.+54     	; 0xa27c <fgetc+0x7c>
    a246:	31 96       	adiw	r30, 0x01	; 1
    a248:	e8 83       	st	Y, r30
    a24a:	f9 83       	std	Y+1, r31	; 0x01
    a24c:	11 c0       	rjmp	.+34     	; 0xa270 <fgetc+0x70>
    a24e:	ea 85       	ldd	r30, Y+10	; 0x0a
    a250:	fb 85       	ldd	r31, Y+11	; 0x0b
    a252:	ce 01       	movw	r24, r28
    a254:	19 95       	eicall
    a256:	9c 01       	movw	r18, r24
    a258:	97 ff       	sbrs	r25, 7
    a25a:	0a c0       	rjmp	.+20     	; 0xa270 <fgetc+0x70>
    a25c:	9b 81       	ldd	r25, Y+3	; 0x03
    a25e:	2f 5f       	subi	r18, 0xFF	; 255
    a260:	3f 4f       	sbci	r19, 0xFF	; 255
    a262:	11 f0       	breq	.+4      	; 0xa268 <fgetc+0x68>
    a264:	80 e2       	ldi	r24, 0x20	; 32
    a266:	01 c0       	rjmp	.+2      	; 0xa26a <fgetc+0x6a>
    a268:	80 e1       	ldi	r24, 0x10	; 16
    a26a:	89 2b       	or	r24, r25
    a26c:	8b 83       	std	Y+3, r24	; 0x03
    a26e:	e8 cf       	rjmp	.-48     	; 0xa240 <fgetc+0x40>
    a270:	8e 81       	ldd	r24, Y+6	; 0x06
    a272:	9f 81       	ldd	r25, Y+7	; 0x07
    a274:	01 96       	adiw	r24, 0x01	; 1
    a276:	8e 83       	std	Y+6, r24	; 0x06
    a278:	9f 83       	std	Y+7, r25	; 0x07
    a27a:	30 e0       	ldi	r19, 0x00	; 0
    a27c:	c9 01       	movw	r24, r18
    a27e:	df 91       	pop	r29
    a280:	cf 91       	pop	r28
    a282:	08 95       	ret

0000a284 <fputc>:
    a284:	0f 93       	push	r16
    a286:	1f 93       	push	r17
    a288:	cf 93       	push	r28
    a28a:	df 93       	push	r29
    a28c:	8c 01       	movw	r16, r24
    a28e:	eb 01       	movw	r28, r22
    a290:	8b 81       	ldd	r24, Y+3	; 0x03
    a292:	81 ff       	sbrs	r24, 1
    a294:	1b c0       	rjmp	.+54     	; 0xa2cc <fputc+0x48>
    a296:	82 ff       	sbrs	r24, 2
    a298:	0d c0       	rjmp	.+26     	; 0xa2b4 <fputc+0x30>
    a29a:	2e 81       	ldd	r18, Y+6	; 0x06
    a29c:	3f 81       	ldd	r19, Y+7	; 0x07
    a29e:	8c 81       	ldd	r24, Y+4	; 0x04
    a2a0:	9d 81       	ldd	r25, Y+5	; 0x05
    a2a2:	28 17       	cp	r18, r24
    a2a4:	39 07       	cpc	r19, r25
    a2a6:	64 f4       	brge	.+24     	; 0xa2c0 <fputc+0x3c>
    a2a8:	e8 81       	ld	r30, Y
    a2aa:	f9 81       	ldd	r31, Y+1	; 0x01
    a2ac:	01 93       	st	Z+, r16
    a2ae:	e8 83       	st	Y, r30
    a2b0:	f9 83       	std	Y+1, r31	; 0x01
    a2b2:	06 c0       	rjmp	.+12     	; 0xa2c0 <fputc+0x3c>
    a2b4:	e8 85       	ldd	r30, Y+8	; 0x08
    a2b6:	f9 85       	ldd	r31, Y+9	; 0x09
    a2b8:	80 2f       	mov	r24, r16
    a2ba:	19 95       	eicall
    a2bc:	89 2b       	or	r24, r25
    a2be:	31 f4       	brne	.+12     	; 0xa2cc <fputc+0x48>
    a2c0:	8e 81       	ldd	r24, Y+6	; 0x06
    a2c2:	9f 81       	ldd	r25, Y+7	; 0x07
    a2c4:	01 96       	adiw	r24, 0x01	; 1
    a2c6:	8e 83       	std	Y+6, r24	; 0x06
    a2c8:	9f 83       	std	Y+7, r25	; 0x07
    a2ca:	02 c0       	rjmp	.+4      	; 0xa2d0 <fputc+0x4c>
    a2cc:	0f ef       	ldi	r16, 0xFF	; 255
    a2ce:	1f ef       	ldi	r17, 0xFF	; 255
    a2d0:	c8 01       	movw	r24, r16
    a2d2:	df 91       	pop	r29
    a2d4:	cf 91       	pop	r28
    a2d6:	1f 91       	pop	r17
    a2d8:	0f 91       	pop	r16
    a2da:	08 95       	ret

0000a2dc <ungetc>:
    a2dc:	9c 01       	movw	r18, r24
    a2de:	fb 01       	movw	r30, r22
    a2e0:	83 81       	ldd	r24, Z+3	; 0x03
    a2e2:	80 ff       	sbrs	r24, 0
    a2e4:	11 c0       	rjmp	.+34     	; 0xa308 <ungetc+0x2c>
    a2e6:	86 fd       	sbrc	r24, 6
    a2e8:	0f c0       	rjmp	.+30     	; 0xa308 <ungetc+0x2c>
    a2ea:	9f ef       	ldi	r25, 0xFF	; 255
    a2ec:	2f 3f       	cpi	r18, 0xFF	; 255
    a2ee:	39 07       	cpc	r19, r25
    a2f0:	59 f0       	breq	.+22     	; 0xa308 <ungetc+0x2c>
    a2f2:	22 83       	std	Z+2, r18	; 0x02
    a2f4:	80 64       	ori	r24, 0x40	; 64
    a2f6:	8f 7d       	andi	r24, 0xDF	; 223
    a2f8:	83 83       	std	Z+3, r24	; 0x03
    a2fa:	86 81       	ldd	r24, Z+6	; 0x06
    a2fc:	97 81       	ldd	r25, Z+7	; 0x07
    a2fe:	01 97       	sbiw	r24, 0x01	; 1
    a300:	86 83       	std	Z+6, r24	; 0x06
    a302:	97 83       	std	Z+7, r25	; 0x07
    a304:	30 e0       	ldi	r19, 0x00	; 0
    a306:	02 c0       	rjmp	.+4      	; 0xa30c <ungetc+0x30>
    a308:	2f ef       	ldi	r18, 0xFF	; 255
    a30a:	3f ef       	ldi	r19, 0xFF	; 255
    a30c:	c9 01       	movw	r24, r18
    a30e:	08 95       	ret

0000a310 <__ultoa_invert>:
    a310:	fa 01       	movw	r30, r20
    a312:	aa 27       	eor	r26, r26
    a314:	28 30       	cpi	r18, 0x08	; 8
    a316:	51 f1       	breq	.+84     	; 0xa36c <__ultoa_invert+0x5c>
    a318:	20 31       	cpi	r18, 0x10	; 16
    a31a:	81 f1       	breq	.+96     	; 0xa37c <__ultoa_invert+0x6c>
    a31c:	e8 94       	clt
    a31e:	6f 93       	push	r22
    a320:	6e 7f       	andi	r22, 0xFE	; 254
    a322:	6e 5f       	subi	r22, 0xFE	; 254
    a324:	7f 4f       	sbci	r23, 0xFF	; 255
    a326:	8f 4f       	sbci	r24, 0xFF	; 255
    a328:	9f 4f       	sbci	r25, 0xFF	; 255
    a32a:	af 4f       	sbci	r26, 0xFF	; 255
    a32c:	b1 e0       	ldi	r27, 0x01	; 1
    a32e:	3e d0       	rcall	.+124    	; 0xa3ac <__ultoa_invert+0x9c>
    a330:	b4 e0       	ldi	r27, 0x04	; 4
    a332:	3c d0       	rcall	.+120    	; 0xa3ac <__ultoa_invert+0x9c>
    a334:	67 0f       	add	r22, r23
    a336:	78 1f       	adc	r23, r24
    a338:	89 1f       	adc	r24, r25
    a33a:	9a 1f       	adc	r25, r26
    a33c:	a1 1d       	adc	r26, r1
    a33e:	68 0f       	add	r22, r24
    a340:	79 1f       	adc	r23, r25
    a342:	8a 1f       	adc	r24, r26
    a344:	91 1d       	adc	r25, r1
    a346:	a1 1d       	adc	r26, r1
    a348:	6a 0f       	add	r22, r26
    a34a:	71 1d       	adc	r23, r1
    a34c:	81 1d       	adc	r24, r1
    a34e:	91 1d       	adc	r25, r1
    a350:	a1 1d       	adc	r26, r1
    a352:	20 d0       	rcall	.+64     	; 0xa394 <__ultoa_invert+0x84>
    a354:	09 f4       	brne	.+2      	; 0xa358 <__ultoa_invert+0x48>
    a356:	68 94       	set
    a358:	3f 91       	pop	r19
    a35a:	2a e0       	ldi	r18, 0x0A	; 10
    a35c:	26 9f       	mul	r18, r22
    a35e:	11 24       	eor	r1, r1
    a360:	30 19       	sub	r19, r0
    a362:	30 5d       	subi	r19, 0xD0	; 208
    a364:	31 93       	st	Z+, r19
    a366:	de f6       	brtc	.-74     	; 0xa31e <__ultoa_invert+0xe>
    a368:	cf 01       	movw	r24, r30
    a36a:	08 95       	ret
    a36c:	46 2f       	mov	r20, r22
    a36e:	47 70       	andi	r20, 0x07	; 7
    a370:	40 5d       	subi	r20, 0xD0	; 208
    a372:	41 93       	st	Z+, r20
    a374:	b3 e0       	ldi	r27, 0x03	; 3
    a376:	0f d0       	rcall	.+30     	; 0xa396 <__ultoa_invert+0x86>
    a378:	c9 f7       	brne	.-14     	; 0xa36c <__ultoa_invert+0x5c>
    a37a:	f6 cf       	rjmp	.-20     	; 0xa368 <__ultoa_invert+0x58>
    a37c:	46 2f       	mov	r20, r22
    a37e:	4f 70       	andi	r20, 0x0F	; 15
    a380:	40 5d       	subi	r20, 0xD0	; 208
    a382:	4a 33       	cpi	r20, 0x3A	; 58
    a384:	18 f0       	brcs	.+6      	; 0xa38c <__ultoa_invert+0x7c>
    a386:	49 5d       	subi	r20, 0xD9	; 217
    a388:	31 fd       	sbrc	r19, 1
    a38a:	40 52       	subi	r20, 0x20	; 32
    a38c:	41 93       	st	Z+, r20
    a38e:	02 d0       	rcall	.+4      	; 0xa394 <__ultoa_invert+0x84>
    a390:	a9 f7       	brne	.-22     	; 0xa37c <__ultoa_invert+0x6c>
    a392:	ea cf       	rjmp	.-44     	; 0xa368 <__ultoa_invert+0x58>
    a394:	b4 e0       	ldi	r27, 0x04	; 4
    a396:	a6 95       	lsr	r26
    a398:	97 95       	ror	r25
    a39a:	87 95       	ror	r24
    a39c:	77 95       	ror	r23
    a39e:	67 95       	ror	r22
    a3a0:	ba 95       	dec	r27
    a3a2:	c9 f7       	brne	.-14     	; 0xa396 <__ultoa_invert+0x86>
    a3a4:	00 97       	sbiw	r24, 0x00	; 0
    a3a6:	61 05       	cpc	r22, r1
    a3a8:	71 05       	cpc	r23, r1
    a3aa:	08 95       	ret
    a3ac:	9b 01       	movw	r18, r22
    a3ae:	ac 01       	movw	r20, r24
    a3b0:	0a 2e       	mov	r0, r26
    a3b2:	06 94       	lsr	r0
    a3b4:	57 95       	ror	r21
    a3b6:	47 95       	ror	r20
    a3b8:	37 95       	ror	r19
    a3ba:	27 95       	ror	r18
    a3bc:	ba 95       	dec	r27
    a3be:	c9 f7       	brne	.-14     	; 0xa3b2 <__ultoa_invert+0xa2>
    a3c0:	62 0f       	add	r22, r18
    a3c2:	73 1f       	adc	r23, r19
    a3c4:	84 1f       	adc	r24, r20
    a3c6:	95 1f       	adc	r25, r21
    a3c8:	a0 1d       	adc	r26, r0
    a3ca:	08 95       	ret

0000a3cc <__ctype_isfalse>:
    a3cc:	99 27       	eor	r25, r25
    a3ce:	88 27       	eor	r24, r24

0000a3d0 <__ctype_istrue>:
    a3d0:	08 95       	ret

0000a3d2 <_exit>:
    a3d2:	f8 94       	cli

0000a3d4 <__stop_program>:
    a3d4:	ff cf       	rjmp	.-2      	; 0xa3d4 <__stop_program>
